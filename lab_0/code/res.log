; *** IR Dump After Annotation2MetadataPass on [module] ***
; ModuleID = 'main.c'
source_filename = "main.c"
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128"
target triple = "x86_64-pc-linux-gnu"

@.str = private unnamed_addr constant [3 x i8] c"%d\00", align 1
@.str.1 = private unnamed_addr constant [6 x i8] c"%llu\0A\00", align 1

; Function Attrs: nounwind uwtable
define dso_local i32 @main() #0 {
  %1 = alloca i32, align 4
  %2 = alloca i32, align 4
  %3 = alloca i64, align 8
  %4 = alloca i32, align 4
  store i32 0, ptr %1, align 4
  call void @llvm.lifetime.start.p0(i64 4, ptr %2) #3
  call void @llvm.lifetime.start.p0(i64 8, ptr %3) #3
  store i64 1, ptr %3, align 8, !tbaa !5
  %5 = call i32 (ptr, ...) @__isoc99_scanf(ptr noundef @.str, ptr noundef %2)
  call void @llvm.lifetime.start.p0(i64 4, ptr %4) #3
  store i32 1, ptr %4, align 4, !tbaa !9
  br label %6

6:                                                ; preds = %16, %0
  %7 = load i32, ptr %4, align 4, !tbaa !9
  %8 = load i32, ptr %2, align 4, !tbaa !9
  %9 = icmp sle i32 %7, %8
  br i1 %9, label %11, label %10

10:                                               ; preds = %6
  call void @llvm.lifetime.end.p0(i64 4, ptr %4) #3
  br label %19

11:                                               ; preds = %6
  %12 = load i32, ptr %4, align 4, !tbaa !9
  %13 = sext i32 %12 to i64
  %14 = load i64, ptr %3, align 8, !tbaa !5
  %15 = mul i64 %14, %13
  store i64 %15, ptr %3, align 8, !tbaa !5
  br label %16

16:                                               ; preds = %11
  %17 = load i32, ptr %4, align 4, !tbaa !9
  %18 = add nsw i32 %17, 1
  store i32 %18, ptr %4, align 4, !tbaa !9
  br label %6, !llvm.loop !11

19:                                               ; preds = %10
  %20 = load i64, ptr %3, align 8, !tbaa !5
  %21 = call i32 (ptr, ...) @printf(ptr noundef @.str.1, i64 noundef %20)
  call void @llvm.lifetime.end.p0(i64 8, ptr %3) #3
  call void @llvm.lifetime.end.p0(i64 4, ptr %2) #3
  ret i32 0
}

; Function Attrs: nocallback nofree nosync nounwind willreturn memory(argmem: readwrite)
declare void @llvm.lifetime.start.p0(i64 immarg, ptr nocapture) #1

declare i32 @__isoc99_scanf(ptr noundef, ...) #2

; Function Attrs: nocallback nofree nosync nounwind willreturn memory(argmem: readwrite)
declare void @llvm.lifetime.end.p0(i64 immarg, ptr nocapture) #1

declare i32 @printf(ptr noundef, ...) #2

attributes #0 = { nounwind uwtable "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #1 = { nocallback nofree nosync nounwind willreturn memory(argmem: readwrite) }
attributes #2 = { "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #3 = { nounwind }

!llvm.module.flags = !{!0, !1, !2, !3}
!llvm.ident = !{!4}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{i32 8, !"PIC Level", i32 2}
!2 = !{i32 7, !"PIE Level", i32 2}
!3 = !{i32 7, !"uwtable", i32 2}
!4 = !{!"Ubuntu clang version 18.1.3 (1ubuntu1)"}
!5 = !{!6, !6, i64 0}
!6 = !{!"long long", !7, i64 0}
!7 = !{!"omnipotent char", !8, i64 0}
!8 = !{!"Simple C/C++ TBAA"}
!9 = !{!10, !10, i64 0}
!10 = !{!"int", !7, i64 0}
!11 = distinct !{!11, !12}
!12 = !{!"llvm.loop.mustprogress"}
; *** IR Dump After ForceFunctionAttrsPass on [module] ***
; ModuleID = 'main.c'
source_filename = "main.c"
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128"
target triple = "x86_64-pc-linux-gnu"

@.str = private unnamed_addr constant [3 x i8] c"%d\00", align 1
@.str.1 = private unnamed_addr constant [6 x i8] c"%llu\0A\00", align 1

; Function Attrs: nounwind uwtable
define dso_local i32 @main() #0 {
  %1 = alloca i32, align 4
  %2 = alloca i32, align 4
  %3 = alloca i64, align 8
  %4 = alloca i32, align 4
  store i32 0, ptr %1, align 4
  call void @llvm.lifetime.start.p0(i64 4, ptr %2) #3
  call void @llvm.lifetime.start.p0(i64 8, ptr %3) #3
  store i64 1, ptr %3, align 8, !tbaa !5
  %5 = call i32 (ptr, ...) @__isoc99_scanf(ptr noundef @.str, ptr noundef %2)
  call void @llvm.lifetime.start.p0(i64 4, ptr %4) #3
  store i32 1, ptr %4, align 4, !tbaa !9
  br label %6

6:                                                ; preds = %16, %0
  %7 = load i32, ptr %4, align 4, !tbaa !9
  %8 = load i32, ptr %2, align 4, !tbaa !9
  %9 = icmp sle i32 %7, %8
  br i1 %9, label %11, label %10

10:                                               ; preds = %6
  call void @llvm.lifetime.end.p0(i64 4, ptr %4) #3
  br label %19

11:                                               ; preds = %6
  %12 = load i32, ptr %4, align 4, !tbaa !9
  %13 = sext i32 %12 to i64
  %14 = load i64, ptr %3, align 8, !tbaa !5
  %15 = mul i64 %14, %13
  store i64 %15, ptr %3, align 8, !tbaa !5
  br label %16

16:                                               ; preds = %11
  %17 = load i32, ptr %4, align 4, !tbaa !9
  %18 = add nsw i32 %17, 1
  store i32 %18, ptr %4, align 4, !tbaa !9
  br label %6, !llvm.loop !11

19:                                               ; preds = %10
  %20 = load i64, ptr %3, align 8, !tbaa !5
  %21 = call i32 (ptr, ...) @printf(ptr noundef @.str.1, i64 noundef %20)
  call void @llvm.lifetime.end.p0(i64 8, ptr %3) #3
  call void @llvm.lifetime.end.p0(i64 4, ptr %2) #3
  ret i32 0
}

; Function Attrs: nocallback nofree nosync nounwind willreturn memory(argmem: readwrite)
declare void @llvm.lifetime.start.p0(i64 immarg, ptr nocapture) #1

declare i32 @__isoc99_scanf(ptr noundef, ...) #2

; Function Attrs: nocallback nofree nosync nounwind willreturn memory(argmem: readwrite)
declare void @llvm.lifetime.end.p0(i64 immarg, ptr nocapture) #1

declare i32 @printf(ptr noundef, ...) #2

attributes #0 = { nounwind uwtable "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #1 = { nocallback nofree nosync nounwind willreturn memory(argmem: readwrite) }
attributes #2 = { "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #3 = { nounwind }

!llvm.module.flags = !{!0, !1, !2, !3}
!llvm.ident = !{!4}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{i32 8, !"PIC Level", i32 2}
!2 = !{i32 7, !"PIE Level", i32 2}
!3 = !{i32 7, !"uwtable", i32 2}
!4 = !{!"Ubuntu clang version 18.1.3 (1ubuntu1)"}
!5 = !{!6, !6, i64 0}
!6 = !{!"long long", !7, i64 0}
!7 = !{!"omnipotent char", !8, i64 0}
!8 = !{!"Simple C/C++ TBAA"}
!9 = !{!10, !10, i64 0}
!10 = !{!"int", !7, i64 0}
!11 = distinct !{!11, !12}
!12 = !{!"llvm.loop.mustprogress"}
; *** IR Dump After AssignmentTrackingPass on [module] ***
; ModuleID = 'main.c'
source_filename = "main.c"
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128"
target triple = "x86_64-pc-linux-gnu"

@.str = private unnamed_addr constant [3 x i8] c"%d\00", align 1
@.str.1 = private unnamed_addr constant [6 x i8] c"%llu\0A\00", align 1

; Function Attrs: nounwind uwtable
define dso_local i32 @main() #0 {
  %1 = alloca i32, align 4
  %2 = alloca i32, align 4
  %3 = alloca i64, align 8
  %4 = alloca i32, align 4
  store i32 0, ptr %1, align 4
  call void @llvm.lifetime.start.p0(i64 4, ptr %2) #3
  call void @llvm.lifetime.start.p0(i64 8, ptr %3) #3
  store i64 1, ptr %3, align 8, !tbaa !5
  %5 = call i32 (ptr, ...) @__isoc99_scanf(ptr noundef @.str, ptr noundef %2)
  call void @llvm.lifetime.start.p0(i64 4, ptr %4) #3
  store i32 1, ptr %4, align 4, !tbaa !9
  br label %6

6:                                                ; preds = %16, %0
  %7 = load i32, ptr %4, align 4, !tbaa !9
  %8 = load i32, ptr %2, align 4, !tbaa !9
  %9 = icmp sle i32 %7, %8
  br i1 %9, label %11, label %10

10:                                               ; preds = %6
  call void @llvm.lifetime.end.p0(i64 4, ptr %4) #3
  br label %19

11:                                               ; preds = %6
  %12 = load i32, ptr %4, align 4, !tbaa !9
  %13 = sext i32 %12 to i64
  %14 = load i64, ptr %3, align 8, !tbaa !5
  %15 = mul i64 %14, %13
  store i64 %15, ptr %3, align 8, !tbaa !5
  br label %16

16:                                               ; preds = %11
  %17 = load i32, ptr %4, align 4, !tbaa !9
  %18 = add nsw i32 %17, 1
  store i32 %18, ptr %4, align 4, !tbaa !9
  br label %6, !llvm.loop !11

19:                                               ; preds = %10
  %20 = load i64, ptr %3, align 8, !tbaa !5
  %21 = call i32 (ptr, ...) @printf(ptr noundef @.str.1, i64 noundef %20)
  call void @llvm.lifetime.end.p0(i64 8, ptr %3) #3
  call void @llvm.lifetime.end.p0(i64 4, ptr %2) #3
  ret i32 0
}

; Function Attrs: nocallback nofree nosync nounwind willreturn memory(argmem: readwrite)
declare void @llvm.lifetime.start.p0(i64 immarg, ptr nocapture) #1

declare i32 @__isoc99_scanf(ptr noundef, ...) #2

; Function Attrs: nocallback nofree nosync nounwind willreturn memory(argmem: readwrite)
declare void @llvm.lifetime.end.p0(i64 immarg, ptr nocapture) #1

declare i32 @printf(ptr noundef, ...) #2

attributes #0 = { nounwind uwtable "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #1 = { nocallback nofree nosync nounwind willreturn memory(argmem: readwrite) }
attributes #2 = { "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #3 = { nounwind }

!llvm.module.flags = !{!0, !1, !2, !3}
!llvm.ident = !{!4}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{i32 8, !"PIC Level", i32 2}
!2 = !{i32 7, !"PIE Level", i32 2}
!3 = !{i32 7, !"uwtable", i32 2}
!4 = !{!"Ubuntu clang version 18.1.3 (1ubuntu1)"}
!5 = !{!6, !6, i64 0}
!6 = !{!"long long", !7, i64 0}
!7 = !{!"omnipotent char", !8, i64 0}
!8 = !{!"Simple C/C++ TBAA"}
!9 = !{!10, !10, i64 0}
!10 = !{!"int", !7, i64 0}
!11 = distinct !{!11, !12}
!12 = !{!"llvm.loop.mustprogress"}
; *** IR Dump After InferFunctionAttrsPass on [module] ***
; ModuleID = 'main.c'
source_filename = "main.c"
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128"
target triple = "x86_64-pc-linux-gnu"

@.str = private unnamed_addr constant [3 x i8] c"%d\00", align 1
@.str.1 = private unnamed_addr constant [6 x i8] c"%llu\0A\00", align 1

; Function Attrs: nounwind uwtable
define dso_local i32 @main() #0 {
  %1 = alloca i32, align 4
  %2 = alloca i32, align 4
  %3 = alloca i64, align 8
  %4 = alloca i32, align 4
  store i32 0, ptr %1, align 4
  call void @llvm.lifetime.start.p0(i64 4, ptr %2) #3
  call void @llvm.lifetime.start.p0(i64 8, ptr %3) #3
  store i64 1, ptr %3, align 8, !tbaa !5
  %5 = call i32 (ptr, ...) @__isoc99_scanf(ptr noundef @.str, ptr noundef %2)
  call void @llvm.lifetime.start.p0(i64 4, ptr %4) #3
  store i32 1, ptr %4, align 4, !tbaa !9
  br label %6

6:                                                ; preds = %16, %0
  %7 = load i32, ptr %4, align 4, !tbaa !9
  %8 = load i32, ptr %2, align 4, !tbaa !9
  %9 = icmp sle i32 %7, %8
  br i1 %9, label %11, label %10

10:                                               ; preds = %6
  call void @llvm.lifetime.end.p0(i64 4, ptr %4) #3
  br label %19

11:                                               ; preds = %6
  %12 = load i32, ptr %4, align 4, !tbaa !9
  %13 = sext i32 %12 to i64
  %14 = load i64, ptr %3, align 8, !tbaa !5
  %15 = mul i64 %14, %13
  store i64 %15, ptr %3, align 8, !tbaa !5
  br label %16

16:                                               ; preds = %11
  %17 = load i32, ptr %4, align 4, !tbaa !9
  %18 = add nsw i32 %17, 1
  store i32 %18, ptr %4, align 4, !tbaa !9
  br label %6, !llvm.loop !11

19:                                               ; preds = %10
  %20 = load i64, ptr %3, align 8, !tbaa !5
  %21 = call i32 (ptr, ...) @printf(ptr noundef @.str.1, i64 noundef %20)
  call void @llvm.lifetime.end.p0(i64 8, ptr %3) #3
  call void @llvm.lifetime.end.p0(i64 4, ptr %2) #3
  ret i32 0
}

; Function Attrs: mustprogress nocallback nofree nosync nounwind willreturn memory(argmem: readwrite)
declare void @llvm.lifetime.start.p0(i64 immarg, ptr nocapture) #1

; Function Attrs: nofree nounwind
declare noundef i32 @__isoc99_scanf(ptr nocapture noundef readonly, ...) #2

; Function Attrs: mustprogress nocallback nofree nosync nounwind willreturn memory(argmem: readwrite)
declare void @llvm.lifetime.end.p0(i64 immarg, ptr nocapture) #1

; Function Attrs: nofree nounwind
declare noundef i32 @printf(ptr nocapture noundef readonly, ...) #2

attributes #0 = { nounwind uwtable "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #1 = { mustprogress nocallback nofree nosync nounwind willreturn memory(argmem: readwrite) }
attributes #2 = { nofree nounwind "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #3 = { nounwind }

!llvm.module.flags = !{!0, !1, !2, !3}
!llvm.ident = !{!4}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{i32 8, !"PIC Level", i32 2}
!2 = !{i32 7, !"PIE Level", i32 2}
!3 = !{i32 7, !"uwtable", i32 2}
!4 = !{!"Ubuntu clang version 18.1.3 (1ubuntu1)"}
!5 = !{!6, !6, i64 0}
!6 = !{!"long long", !7, i64 0}
!7 = !{!"omnipotent char", !8, i64 0}
!8 = !{!"Simple C/C++ TBAA"}
!9 = !{!10, !10, i64 0}
!10 = !{!"int", !7, i64 0}
!11 = distinct !{!11, !12}
!12 = !{!"llvm.loop.mustprogress"}
; *** IR Dump After CoroEarlyPass on [module] ***
; ModuleID = 'main.c'
source_filename = "main.c"
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128"
target triple = "x86_64-pc-linux-gnu"

@.str = private unnamed_addr constant [3 x i8] c"%d\00", align 1
@.str.1 = private unnamed_addr constant [6 x i8] c"%llu\0A\00", align 1

; Function Attrs: nounwind uwtable
define dso_local i32 @main() #0 {
  %1 = alloca i32, align 4
  %2 = alloca i32, align 4
  %3 = alloca i64, align 8
  %4 = alloca i32, align 4
  store i32 0, ptr %1, align 4
  call void @llvm.lifetime.start.p0(i64 4, ptr %2) #3
  call void @llvm.lifetime.start.p0(i64 8, ptr %3) #3
  store i64 1, ptr %3, align 8, !tbaa !5
  %5 = call i32 (ptr, ...) @__isoc99_scanf(ptr noundef @.str, ptr noundef %2)
  call void @llvm.lifetime.start.p0(i64 4, ptr %4) #3
  store i32 1, ptr %4, align 4, !tbaa !9
  br label %6

6:                                                ; preds = %16, %0
  %7 = load i32, ptr %4, align 4, !tbaa !9
  %8 = load i32, ptr %2, align 4, !tbaa !9
  %9 = icmp sle i32 %7, %8
  br i1 %9, label %11, label %10

10:                                               ; preds = %6
  call void @llvm.lifetime.end.p0(i64 4, ptr %4) #3
  br label %19

11:                                               ; preds = %6
  %12 = load i32, ptr %4, align 4, !tbaa !9
  %13 = sext i32 %12 to i64
  %14 = load i64, ptr %3, align 8, !tbaa !5
  %15 = mul i64 %14, %13
  store i64 %15, ptr %3, align 8, !tbaa !5
  br label %16

16:                                               ; preds = %11
  %17 = load i32, ptr %4, align 4, !tbaa !9
  %18 = add nsw i32 %17, 1
  store i32 %18, ptr %4, align 4, !tbaa !9
  br label %6, !llvm.loop !11

19:                                               ; preds = %10
  %20 = load i64, ptr %3, align 8, !tbaa !5
  %21 = call i32 (ptr, ...) @printf(ptr noundef @.str.1, i64 noundef %20)
  call void @llvm.lifetime.end.p0(i64 8, ptr %3) #3
  call void @llvm.lifetime.end.p0(i64 4, ptr %2) #3
  ret i32 0
}

; Function Attrs: mustprogress nocallback nofree nosync nounwind willreturn memory(argmem: readwrite)
declare void @llvm.lifetime.start.p0(i64 immarg, ptr nocapture) #1

; Function Attrs: nofree nounwind
declare noundef i32 @__isoc99_scanf(ptr nocapture noundef readonly, ...) #2

; Function Attrs: mustprogress nocallback nofree nosync nounwind willreturn memory(argmem: readwrite)
declare void @llvm.lifetime.end.p0(i64 immarg, ptr nocapture) #1

; Function Attrs: nofree nounwind
declare noundef i32 @printf(ptr nocapture noundef readonly, ...) #2

attributes #0 = { nounwind uwtable "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #1 = { mustprogress nocallback nofree nosync nounwind willreturn memory(argmem: readwrite) }
attributes #2 = { nofree nounwind "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #3 = { nounwind }

!llvm.module.flags = !{!0, !1, !2, !3}
!llvm.ident = !{!4}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{i32 8, !"PIC Level", i32 2}
!2 = !{i32 7, !"PIE Level", i32 2}
!3 = !{i32 7, !"uwtable", i32 2}
!4 = !{!"Ubuntu clang version 18.1.3 (1ubuntu1)"}
!5 = !{!6, !6, i64 0}
!6 = !{!"long long", !7, i64 0}
!7 = !{!"omnipotent char", !8, i64 0}
!8 = !{!"Simple C/C++ TBAA"}
!9 = !{!10, !10, i64 0}
!10 = !{!"int", !7, i64 0}
!11 = distinct !{!11, !12}
!12 = !{!"llvm.loop.mustprogress"}
; *** IR Dump After LowerExpectIntrinsicPass on main ***
; Function Attrs: nounwind uwtable
define dso_local i32 @main() #0 {
  %1 = alloca i32, align 4
  %2 = alloca i32, align 4
  %3 = alloca i64, align 8
  %4 = alloca i32, align 4
  store i32 0, ptr %1, align 4
  call void @llvm.lifetime.start.p0(i64 4, ptr %2) #3
  call void @llvm.lifetime.start.p0(i64 8, ptr %3) #3
  store i64 1, ptr %3, align 8, !tbaa !5
  %5 = call i32 (ptr, ...) @__isoc99_scanf(ptr noundef @.str, ptr noundef %2)
  call void @llvm.lifetime.start.p0(i64 4, ptr %4) #3
  store i32 1, ptr %4, align 4, !tbaa !9
  br label %6

6:                                                ; preds = %16, %0
  %7 = load i32, ptr %4, align 4, !tbaa !9
  %8 = load i32, ptr %2, align 4, !tbaa !9
  %9 = icmp sle i32 %7, %8
  br i1 %9, label %11, label %10

10:                                               ; preds = %6
  call void @llvm.lifetime.end.p0(i64 4, ptr %4) #3
  br label %19

11:                                               ; preds = %6
  %12 = load i32, ptr %4, align 4, !tbaa !9
  %13 = sext i32 %12 to i64
  %14 = load i64, ptr %3, align 8, !tbaa !5
  %15 = mul i64 %14, %13
  store i64 %15, ptr %3, align 8, !tbaa !5
  br label %16

16:                                               ; preds = %11
  %17 = load i32, ptr %4, align 4, !tbaa !9
  %18 = add nsw i32 %17, 1
  store i32 %18, ptr %4, align 4, !tbaa !9
  br label %6, !llvm.loop !11

19:                                               ; preds = %10
  %20 = load i64, ptr %3, align 8, !tbaa !5
  %21 = call i32 (ptr, ...) @printf(ptr noundef @.str.1, i64 noundef %20)
  call void @llvm.lifetime.end.p0(i64 8, ptr %3) #3
  call void @llvm.lifetime.end.p0(i64 4, ptr %2) #3
  ret i32 0
}
; *** IR Dump After SimplifyCFGPass on main ***
; Function Attrs: nounwind uwtable
define dso_local i32 @main() #0 {
  %1 = alloca i32, align 4
  %2 = alloca i32, align 4
  %3 = alloca i64, align 8
  %4 = alloca i32, align 4
  store i32 0, ptr %1, align 4
  call void @llvm.lifetime.start.p0(i64 4, ptr %2) #3
  call void @llvm.lifetime.start.p0(i64 8, ptr %3) #3
  store i64 1, ptr %3, align 8, !tbaa !5
  %5 = call i32 (ptr, ...) @__isoc99_scanf(ptr noundef @.str, ptr noundef %2)
  call void @llvm.lifetime.start.p0(i64 4, ptr %4) #3
  store i32 1, ptr %4, align 4, !tbaa !9
  br label %6

6:                                                ; preds = %13, %0
  %7 = load i32, ptr %4, align 4, !tbaa !9
  %8 = load i32, ptr %2, align 4, !tbaa !9
  %9 = icmp sle i32 %7, %8
  br i1 %9, label %13, label %10

10:                                               ; preds = %6
  call void @llvm.lifetime.end.p0(i64 4, ptr %4) #3
  %11 = load i64, ptr %3, align 8, !tbaa !5
  %12 = call i32 (ptr, ...) @printf(ptr noundef @.str.1, i64 noundef %11)
  call void @llvm.lifetime.end.p0(i64 8, ptr %3) #3
  call void @llvm.lifetime.end.p0(i64 4, ptr %2) #3
  ret i32 0

13:                                               ; preds = %6
  %14 = load i32, ptr %4, align 4, !tbaa !9
  %15 = sext i32 %14 to i64
  %16 = load i64, ptr %3, align 8, !tbaa !5
  %17 = mul i64 %16, %15
  store i64 %17, ptr %3, align 8, !tbaa !5
  %18 = load i32, ptr %4, align 4, !tbaa !9
  %19 = add nsw i32 %18, 1
  store i32 %19, ptr %4, align 4, !tbaa !9
  br label %6, !llvm.loop !11
}
; *** IR Dump After SROAPass on main ***
; Function Attrs: nounwind uwtable
define dso_local i32 @main() #0 {
  %1 = alloca i32, align 4
  call void @llvm.lifetime.start.p0(i64 4, ptr %1) #3
  %2 = call i32 (ptr, ...) @__isoc99_scanf(ptr noundef @.str, ptr noundef %1)
  br label %3

3:                                                ; preds = %10, %0
  %4 = phi i64 [ 1, %0 ], [ %12, %10 ]
  %5 = phi i32 [ 1, %0 ], [ %13, %10 ]
  %6 = load i32, ptr %1, align 4, !tbaa !5
  %7 = icmp sle i32 %5, %6
  br i1 %7, label %10, label %8

8:                                                ; preds = %3
  %9 = call i32 (ptr, ...) @printf(ptr noundef @.str.1, i64 noundef %4)
  call void @llvm.lifetime.end.p0(i64 4, ptr %1) #3
  ret i32 0

10:                                               ; preds = %3
  %11 = sext i32 %5 to i64
  %12 = mul i64 %4, %11
  %13 = add nsw i32 %5, 1
  br label %3, !llvm.loop !9
}
; *** IR Dump After EarlyCSEPass on main ***
; Function Attrs: nounwind uwtable
define dso_local i32 @main() #0 {
  %1 = alloca i32, align 4
  call void @llvm.lifetime.start.p0(i64 4, ptr %1) #3
  %2 = call i32 (ptr, ...) @__isoc99_scanf(ptr noundef @.str, ptr noundef %1)
  br label %3

3:                                                ; preds = %10, %0
  %4 = phi i64 [ 1, %0 ], [ %12, %10 ]
  %5 = phi i32 [ 1, %0 ], [ %13, %10 ]
  %6 = load i32, ptr %1, align 4, !tbaa !5
  %7 = icmp sle i32 %5, %6
  br i1 %7, label %10, label %8

8:                                                ; preds = %3
  %9 = call i32 (ptr, ...) @printf(ptr noundef @.str.1, i64 noundef %4)
  call void @llvm.lifetime.end.p0(i64 4, ptr %1) #3
  ret i32 0

10:                                               ; preds = %3
  %11 = sext i32 %5 to i64
  %12 = mul i64 %4, %11
  %13 = add nsw i32 %5, 1
  br label %3, !llvm.loop !9
}
; *** IR Dump After OpenMPOptPass on [module] ***
; ModuleID = 'main.c'
source_filename = "main.c"
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128"
target triple = "x86_64-pc-linux-gnu"

@.str = private unnamed_addr constant [3 x i8] c"%d\00", align 1
@.str.1 = private unnamed_addr constant [6 x i8] c"%llu\0A\00", align 1

; Function Attrs: nounwind uwtable
define dso_local i32 @main() #0 {
  %1 = alloca i32, align 4
  call void @llvm.lifetime.start.p0(i64 4, ptr %1) #3
  %2 = call i32 (ptr, ...) @__isoc99_scanf(ptr noundef @.str, ptr noundef %1)
  br label %3

3:                                                ; preds = %10, %0
  %4 = phi i64 [ 1, %0 ], [ %12, %10 ]
  %5 = phi i32 [ 1, %0 ], [ %13, %10 ]
  %6 = load i32, ptr %1, align 4, !tbaa !5
  %7 = icmp sle i32 %5, %6
  br i1 %7, label %10, label %8

8:                                                ; preds = %3
  %9 = call i32 (ptr, ...) @printf(ptr noundef @.str.1, i64 noundef %4)
  call void @llvm.lifetime.end.p0(i64 4, ptr %1) #3
  ret i32 0

10:                                               ; preds = %3
  %11 = sext i32 %5 to i64
  %12 = mul i64 %4, %11
  %13 = add nsw i32 %5, 1
  br label %3, !llvm.loop !9
}

; Function Attrs: mustprogress nocallback nofree nosync nounwind willreturn memory(argmem: readwrite)
declare void @llvm.lifetime.start.p0(i64 immarg, ptr nocapture) #1

; Function Attrs: nofree nounwind
declare noundef i32 @__isoc99_scanf(ptr nocapture noundef readonly, ...) #2

; Function Attrs: mustprogress nocallback nofree nosync nounwind willreturn memory(argmem: readwrite)
declare void @llvm.lifetime.end.p0(i64 immarg, ptr nocapture) #1

; Function Attrs: nofree nounwind
declare noundef i32 @printf(ptr nocapture noundef readonly, ...) #2

attributes #0 = { nounwind uwtable "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #1 = { mustprogress nocallback nofree nosync nounwind willreturn memory(argmem: readwrite) }
attributes #2 = { nofree nounwind "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #3 = { nounwind }

!llvm.module.flags = !{!0, !1, !2, !3}
!llvm.ident = !{!4}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{i32 8, !"PIC Level", i32 2}
!2 = !{i32 7, !"PIE Level", i32 2}
!3 = !{i32 7, !"uwtable", i32 2}
!4 = !{!"Ubuntu clang version 18.1.3 (1ubuntu1)"}
!5 = !{!6, !6, i64 0}
!6 = !{!"int", !7, i64 0}
!7 = !{!"omnipotent char", !8, i64 0}
!8 = !{!"Simple C/C++ TBAA"}
!9 = distinct !{!9, !10}
!10 = !{!"llvm.loop.mustprogress"}
; *** IR Dump After IPSCCPPass on [module] ***
; ModuleID = 'main.c'
source_filename = "main.c"
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128"
target triple = "x86_64-pc-linux-gnu"

@.str = private unnamed_addr constant [3 x i8] c"%d\00", align 1
@.str.1 = private unnamed_addr constant [6 x i8] c"%llu\0A\00", align 1

; Function Attrs: nounwind uwtable
define dso_local i32 @main() #0 {
  %1 = alloca i32, align 4
  call void @llvm.lifetime.start.p0(i64 4, ptr %1) #3
  %2 = call i32 (ptr, ...) @__isoc99_scanf(ptr noundef @.str, ptr noundef %1)
  br label %3

3:                                                ; preds = %10, %0
  %4 = phi i64 [ 1, %0 ], [ %12, %10 ]
  %5 = phi i32 [ 1, %0 ], [ %13, %10 ]
  %6 = load i32, ptr %1, align 4, !tbaa !5
  %7 = icmp sle i32 %5, %6
  br i1 %7, label %10, label %8

8:                                                ; preds = %3
  %9 = call i32 (ptr, ...) @printf(ptr noundef @.str.1, i64 noundef %4)
  call void @llvm.lifetime.end.p0(i64 4, ptr %1) #3
  ret i32 0

10:                                               ; preds = %3
  %11 = sext i32 %5 to i64
  %12 = mul i64 %4, %11
  %13 = add nsw i32 %5, 1
  br label %3, !llvm.loop !9
}

; Function Attrs: mustprogress nocallback nofree nosync nounwind willreturn memory(argmem: readwrite)
declare void @llvm.lifetime.start.p0(i64 immarg, ptr nocapture) #1

; Function Attrs: nofree nounwind
declare noundef i32 @__isoc99_scanf(ptr nocapture noundef readonly, ...) #2

; Function Attrs: mustprogress nocallback nofree nosync nounwind willreturn memory(argmem: readwrite)
declare void @llvm.lifetime.end.p0(i64 immarg, ptr nocapture) #1

; Function Attrs: nofree nounwind
declare noundef i32 @printf(ptr nocapture noundef readonly, ...) #2

attributes #0 = { nounwind uwtable "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #1 = { mustprogress nocallback nofree nosync nounwind willreturn memory(argmem: readwrite) }
attributes #2 = { nofree nounwind "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #3 = { nounwind }

!llvm.module.flags = !{!0, !1, !2, !3}
!llvm.ident = !{!4}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{i32 8, !"PIC Level", i32 2}
!2 = !{i32 7, !"PIE Level", i32 2}
!3 = !{i32 7, !"uwtable", i32 2}
!4 = !{!"Ubuntu clang version 18.1.3 (1ubuntu1)"}
!5 = !{!6, !6, i64 0}
!6 = !{!"int", !7, i64 0}
!7 = !{!"omnipotent char", !8, i64 0}
!8 = !{!"Simple C/C++ TBAA"}
!9 = distinct !{!9, !10}
!10 = !{!"llvm.loop.mustprogress"}
; *** IR Dump After CalledValuePropagationPass on [module] ***
; ModuleID = 'main.c'
source_filename = "main.c"
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128"
target triple = "x86_64-pc-linux-gnu"

@.str = private unnamed_addr constant [3 x i8] c"%d\00", align 1
@.str.1 = private unnamed_addr constant [6 x i8] c"%llu\0A\00", align 1

; Function Attrs: nounwind uwtable
define dso_local i32 @main() #0 {
  %1 = alloca i32, align 4
  call void @llvm.lifetime.start.p0(i64 4, ptr %1) #3
  %2 = call i32 (ptr, ...) @__isoc99_scanf(ptr noundef @.str, ptr noundef %1)
  br label %3

3:                                                ; preds = %10, %0
  %4 = phi i64 [ 1, %0 ], [ %12, %10 ]
  %5 = phi i32 [ 1, %0 ], [ %13, %10 ]
  %6 = load i32, ptr %1, align 4, !tbaa !5
  %7 = icmp sle i32 %5, %6
  br i1 %7, label %10, label %8

8:                                                ; preds = %3
  %9 = call i32 (ptr, ...) @printf(ptr noundef @.str.1, i64 noundef %4)
  call void @llvm.lifetime.end.p0(i64 4, ptr %1) #3
  ret i32 0

10:                                               ; preds = %3
  %11 = sext i32 %5 to i64
  %12 = mul i64 %4, %11
  %13 = add nsw i32 %5, 1
  br label %3, !llvm.loop !9
}

; Function Attrs: mustprogress nocallback nofree nosync nounwind willreturn memory(argmem: readwrite)
declare void @llvm.lifetime.start.p0(i64 immarg, ptr nocapture) #1

; Function Attrs: nofree nounwind
declare noundef i32 @__isoc99_scanf(ptr nocapture noundef readonly, ...) #2

; Function Attrs: mustprogress nocallback nofree nosync nounwind willreturn memory(argmem: readwrite)
declare void @llvm.lifetime.end.p0(i64 immarg, ptr nocapture) #1

; Function Attrs: nofree nounwind
declare noundef i32 @printf(ptr nocapture noundef readonly, ...) #2

attributes #0 = { nounwind uwtable "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #1 = { mustprogress nocallback nofree nosync nounwind willreturn memory(argmem: readwrite) }
attributes #2 = { nofree nounwind "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #3 = { nounwind }

!llvm.module.flags = !{!0, !1, !2, !3}
!llvm.ident = !{!4}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{i32 8, !"PIC Level", i32 2}
!2 = !{i32 7, !"PIE Level", i32 2}
!3 = !{i32 7, !"uwtable", i32 2}
!4 = !{!"Ubuntu clang version 18.1.3 (1ubuntu1)"}
!5 = !{!6, !6, i64 0}
!6 = !{!"int", !7, i64 0}
!7 = !{!"omnipotent char", !8, i64 0}
!8 = !{!"Simple C/C++ TBAA"}
!9 = distinct !{!9, !10}
!10 = !{!"llvm.loop.mustprogress"}
; *** IR Dump After GlobalOptPass on [module] ***
; ModuleID = 'main.c'
source_filename = "main.c"
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128"
target triple = "x86_64-pc-linux-gnu"

@.str = private unnamed_addr constant [3 x i8] c"%d\00", align 1
@.str.1 = private unnamed_addr constant [6 x i8] c"%llu\0A\00", align 1

; Function Attrs: nounwind uwtable
define dso_local i32 @main() local_unnamed_addr #0 {
  %1 = alloca i32, align 4
  call void @llvm.lifetime.start.p0(i64 4, ptr %1) #3
  %2 = call i32 (ptr, ...) @__isoc99_scanf(ptr noundef @.str, ptr noundef %1)
  br label %3

3:                                                ; preds = %10, %0
  %4 = phi i64 [ 1, %0 ], [ %12, %10 ]
  %5 = phi i32 [ 1, %0 ], [ %13, %10 ]
  %6 = load i32, ptr %1, align 4, !tbaa !5
  %7 = icmp sle i32 %5, %6
  br i1 %7, label %10, label %8

8:                                                ; preds = %3
  %9 = call i32 (ptr, ...) @printf(ptr noundef @.str.1, i64 noundef %4)
  call void @llvm.lifetime.end.p0(i64 4, ptr %1) #3
  ret i32 0

10:                                               ; preds = %3
  %11 = sext i32 %5 to i64
  %12 = mul i64 %4, %11
  %13 = add nsw i32 %5, 1
  br label %3, !llvm.loop !9
}

; Function Attrs: mustprogress nocallback nofree nosync nounwind willreturn memory(argmem: readwrite)
declare void @llvm.lifetime.start.p0(i64 immarg, ptr nocapture) #1

; Function Attrs: nofree nounwind
declare noundef i32 @__isoc99_scanf(ptr nocapture noundef readonly, ...) local_unnamed_addr #2

; Function Attrs: mustprogress nocallback nofree nosync nounwind willreturn memory(argmem: readwrite)
declare void @llvm.lifetime.end.p0(i64 immarg, ptr nocapture) #1

; Function Attrs: nofree nounwind
declare noundef i32 @printf(ptr nocapture noundef readonly, ...) local_unnamed_addr #2

attributes #0 = { nounwind uwtable "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #1 = { mustprogress nocallback nofree nosync nounwind willreturn memory(argmem: readwrite) }
attributes #2 = { nofree nounwind "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #3 = { nounwind }

!llvm.module.flags = !{!0, !1, !2, !3}
!llvm.ident = !{!4}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{i32 8, !"PIC Level", i32 2}
!2 = !{i32 7, !"PIE Level", i32 2}
!3 = !{i32 7, !"uwtable", i32 2}
!4 = !{!"Ubuntu clang version 18.1.3 (1ubuntu1)"}
!5 = !{!6, !6, i64 0}
!6 = !{!"int", !7, i64 0}
!7 = !{!"omnipotent char", !8, i64 0}
!8 = !{!"Simple C/C++ TBAA"}
!9 = distinct !{!9, !10}
!10 = !{!"llvm.loop.mustprogress"}
; *** IR Dump After PromotePass on main ***
; Function Attrs: nounwind uwtable
define dso_local i32 @main() local_unnamed_addr #0 {
  %1 = alloca i32, align 4
  call void @llvm.lifetime.start.p0(i64 4, ptr %1) #3
  %2 = call i32 (ptr, ...) @__isoc99_scanf(ptr noundef @.str, ptr noundef %1)
  br label %3

3:                                                ; preds = %10, %0
  %4 = phi i64 [ 1, %0 ], [ %12, %10 ]
  %5 = phi i32 [ 1, %0 ], [ %13, %10 ]
  %6 = load i32, ptr %1, align 4, !tbaa !5
  %7 = icmp sle i32 %5, %6
  br i1 %7, label %10, label %8

8:                                                ; preds = %3
  %9 = call i32 (ptr, ...) @printf(ptr noundef @.str.1, i64 noundef %4)
  call void @llvm.lifetime.end.p0(i64 4, ptr %1) #3
  ret i32 0

10:                                               ; preds = %3
  %11 = sext i32 %5 to i64
  %12 = mul i64 %4, %11
  %13 = add nsw i32 %5, 1
  br label %3, !llvm.loop !9
}
; *** IR Dump After InstCombinePass on main ***
; Function Attrs: nounwind uwtable
define dso_local i32 @main() local_unnamed_addr #0 {
  %1 = alloca i32, align 4
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %1) #3
  %2 = call i32 (ptr, ...) @__isoc99_scanf(ptr noundef nonnull @.str, ptr noundef nonnull %1)
  br label %3

3:                                                ; preds = %10, %0
  %4 = phi i64 [ 1, %0 ], [ %12, %10 ]
  %5 = phi i32 [ 1, %0 ], [ %13, %10 ]
  %6 = load i32, ptr %1, align 4, !tbaa !5
  %7 = icmp sgt i32 %5, %6
  br i1 %7, label %8, label %10

8:                                                ; preds = %3
  %9 = call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.1, i64 noundef %4)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %1) #3
  ret i32 0

10:                                               ; preds = %3
  %11 = zext nneg i32 %5 to i64
  %12 = mul i64 %4, %11
  %13 = add nuw nsw i32 %5, 1
  br label %3, !llvm.loop !9
}
; *** IR Dump After SimplifyCFGPass on main ***
; Function Attrs: nounwind uwtable
define dso_local i32 @main() local_unnamed_addr #0 {
  %1 = alloca i32, align 4
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %1) #3
  %2 = call i32 (ptr, ...) @__isoc99_scanf(ptr noundef nonnull @.str, ptr noundef nonnull %1)
  br label %3

3:                                                ; preds = %10, %0
  %4 = phi i64 [ 1, %0 ], [ %12, %10 ]
  %5 = phi i32 [ 1, %0 ], [ %13, %10 ]
  %6 = load i32, ptr %1, align 4, !tbaa !5
  %7 = icmp sgt i32 %5, %6
  br i1 %7, label %8, label %10

8:                                                ; preds = %3
  %9 = call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.1, i64 noundef %4)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %1) #3
  ret i32 0

10:                                               ; preds = %3
  %11 = zext nneg i32 %5 to i64
  %12 = mul i64 %4, %11
  %13 = add nuw nsw i32 %5, 1
  br label %3, !llvm.loop !9
}
; *** IR Dump After AlwaysInlinerPass on [module] ***
; ModuleID = 'main.c'
source_filename = "main.c"
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128"
target triple = "x86_64-pc-linux-gnu"

@.str = private unnamed_addr constant [3 x i8] c"%d\00", align 1
@.str.1 = private unnamed_addr constant [6 x i8] c"%llu\0A\00", align 1

; Function Attrs: nounwind uwtable
define dso_local i32 @main() local_unnamed_addr #0 {
  %1 = alloca i32, align 4
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %1) #3
  %2 = call i32 (ptr, ...) @__isoc99_scanf(ptr noundef nonnull @.str, ptr noundef nonnull %1)
  br label %3

3:                                                ; preds = %10, %0
  %4 = phi i64 [ 1, %0 ], [ %12, %10 ]
  %5 = phi i32 [ 1, %0 ], [ %13, %10 ]
  %6 = load i32, ptr %1, align 4, !tbaa !5
  %7 = icmp sgt i32 %5, %6
  br i1 %7, label %8, label %10

8:                                                ; preds = %3
  %9 = call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.1, i64 noundef %4)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %1) #3
  ret i32 0

10:                                               ; preds = %3
  %11 = zext nneg i32 %5 to i64
  %12 = mul i64 %4, %11
  %13 = add nuw nsw i32 %5, 1
  br label %3, !llvm.loop !9
}

; Function Attrs: mustprogress nocallback nofree nosync nounwind willreturn memory(argmem: readwrite)
declare void @llvm.lifetime.start.p0(i64 immarg, ptr nocapture) #1

; Function Attrs: nofree nounwind
declare noundef i32 @__isoc99_scanf(ptr nocapture noundef readonly, ...) local_unnamed_addr #2

; Function Attrs: mustprogress nocallback nofree nosync nounwind willreturn memory(argmem: readwrite)
declare void @llvm.lifetime.end.p0(i64 immarg, ptr nocapture) #1

; Function Attrs: nofree nounwind
declare noundef i32 @printf(ptr nocapture noundef readonly, ...) local_unnamed_addr #2

attributes #0 = { nounwind uwtable "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #1 = { mustprogress nocallback nofree nosync nounwind willreturn memory(argmem: readwrite) }
attributes #2 = { nofree nounwind "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #3 = { nounwind }

!llvm.module.flags = !{!0, !1, !2, !3}
!llvm.ident = !{!4}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{i32 8, !"PIC Level", i32 2}
!2 = !{i32 7, !"PIE Level", i32 2}
!3 = !{i32 7, !"uwtable", i32 2}
!4 = !{!"Ubuntu clang version 18.1.3 (1ubuntu1)"}
!5 = !{!6, !6, i64 0}
!6 = !{!"int", !7, i64 0}
!7 = !{!"omnipotent char", !8, i64 0}
!8 = !{!"Simple C/C++ TBAA"}
!9 = distinct !{!9, !10}
!10 = !{!"llvm.loop.mustprogress"}
; *** IR Dump After RequireAnalysisPass<llvm::GlobalsAA, llvm::Module, llvm::AnalysisManager<Module>> on [module] ***
; ModuleID = 'main.c'
source_filename = "main.c"
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128"
target triple = "x86_64-pc-linux-gnu"

@.str = private unnamed_addr constant [3 x i8] c"%d\00", align 1
@.str.1 = private unnamed_addr constant [6 x i8] c"%llu\0A\00", align 1

; Function Attrs: nounwind uwtable
define dso_local i32 @main() local_unnamed_addr #0 {
  %1 = alloca i32, align 4
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %1) #3
  %2 = call i32 (ptr, ...) @__isoc99_scanf(ptr noundef nonnull @.str, ptr noundef nonnull %1)
  br label %3

3:                                                ; preds = %10, %0
  %4 = phi i64 [ 1, %0 ], [ %12, %10 ]
  %5 = phi i32 [ 1, %0 ], [ %13, %10 ]
  %6 = load i32, ptr %1, align 4, !tbaa !5
  %7 = icmp sgt i32 %5, %6
  br i1 %7, label %8, label %10

8:                                                ; preds = %3
  %9 = call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.1, i64 noundef %4)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %1) #3
  ret i32 0

10:                                               ; preds = %3
  %11 = zext nneg i32 %5 to i64
  %12 = mul i64 %4, %11
  %13 = add nuw nsw i32 %5, 1
  br label %3, !llvm.loop !9
}

; Function Attrs: mustprogress nocallback nofree nosync nounwind willreturn memory(argmem: readwrite)
declare void @llvm.lifetime.start.p0(i64 immarg, ptr nocapture) #1

; Function Attrs: nofree nounwind
declare noundef i32 @__isoc99_scanf(ptr nocapture noundef readonly, ...) local_unnamed_addr #2

; Function Attrs: mustprogress nocallback nofree nosync nounwind willreturn memory(argmem: readwrite)
declare void @llvm.lifetime.end.p0(i64 immarg, ptr nocapture) #1

; Function Attrs: nofree nounwind
declare noundef i32 @printf(ptr nocapture noundef readonly, ...) local_unnamed_addr #2

attributes #0 = { nounwind uwtable "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #1 = { mustprogress nocallback nofree nosync nounwind willreturn memory(argmem: readwrite) }
attributes #2 = { nofree nounwind "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #3 = { nounwind }

!llvm.module.flags = !{!0, !1, !2, !3}
!llvm.ident = !{!4}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{i32 8, !"PIC Level", i32 2}
!2 = !{i32 7, !"PIE Level", i32 2}
!3 = !{i32 7, !"uwtable", i32 2}
!4 = !{!"Ubuntu clang version 18.1.3 (1ubuntu1)"}
!5 = !{!6, !6, i64 0}
!6 = !{!"int", !7, i64 0}
!7 = !{!"omnipotent char", !8, i64 0}
!8 = !{!"Simple C/C++ TBAA"}
!9 = distinct !{!9, !10}
!10 = !{!"llvm.loop.mustprogress"}
; *** IR Dump After InvalidateAnalysisPass<llvm::AAManager> on main ***
; Function Attrs: nounwind uwtable
define dso_local i32 @main() local_unnamed_addr #0 {
  %1 = alloca i32, align 4
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %1) #3
  %2 = call i32 (ptr, ...) @__isoc99_scanf(ptr noundef nonnull @.str, ptr noundef nonnull %1)
  br label %3

3:                                                ; preds = %10, %0
  %4 = phi i64 [ 1, %0 ], [ %12, %10 ]
  %5 = phi i32 [ 1, %0 ], [ %13, %10 ]
  %6 = load i32, ptr %1, align 4, !tbaa !5
  %7 = icmp sgt i32 %5, %6
  br i1 %7, label %8, label %10

8:                                                ; preds = %3
  %9 = call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.1, i64 noundef %4)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %1) #3
  ret i32 0

10:                                               ; preds = %3
  %11 = zext nneg i32 %5 to i64
  %12 = mul i64 %4, %11
  %13 = add nuw nsw i32 %5, 1
  br label %3, !llvm.loop !9
}
; *** IR Dump After RequireAnalysisPass<llvm::ProfileSummaryAnalysis, llvm::Module, llvm::AnalysisManager<Module>> on [module] ***
; ModuleID = 'main.c'
source_filename = "main.c"
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128"
target triple = "x86_64-pc-linux-gnu"

@.str = private unnamed_addr constant [3 x i8] c"%d\00", align 1
@.str.1 = private unnamed_addr constant [6 x i8] c"%llu\0A\00", align 1

; Function Attrs: nounwind uwtable
define dso_local i32 @main() local_unnamed_addr #0 {
  %1 = alloca i32, align 4
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %1) #3
  %2 = call i32 (ptr, ...) @__isoc99_scanf(ptr noundef nonnull @.str, ptr noundef nonnull %1)
  br label %3

3:                                                ; preds = %10, %0
  %4 = phi i64 [ 1, %0 ], [ %12, %10 ]
  %5 = phi i32 [ 1, %0 ], [ %13, %10 ]
  %6 = load i32, ptr %1, align 4, !tbaa !5
  %7 = icmp sgt i32 %5, %6
  br i1 %7, label %8, label %10

8:                                                ; preds = %3
  %9 = call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.1, i64 noundef %4)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %1) #3
  ret i32 0

10:                                               ; preds = %3
  %11 = zext nneg i32 %5 to i64
  %12 = mul i64 %4, %11
  %13 = add nuw nsw i32 %5, 1
  br label %3, !llvm.loop !9
}

; Function Attrs: mustprogress nocallback nofree nosync nounwind willreturn memory(argmem: readwrite)
declare void @llvm.lifetime.start.p0(i64 immarg, ptr nocapture) #1

; Function Attrs: nofree nounwind
declare noundef i32 @__isoc99_scanf(ptr nocapture noundef readonly, ...) local_unnamed_addr #2

; Function Attrs: mustprogress nocallback nofree nosync nounwind willreturn memory(argmem: readwrite)
declare void @llvm.lifetime.end.p0(i64 immarg, ptr nocapture) #1

; Function Attrs: nofree nounwind
declare noundef i32 @printf(ptr nocapture noundef readonly, ...) local_unnamed_addr #2

attributes #0 = { nounwind uwtable "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #1 = { mustprogress nocallback nofree nosync nounwind willreturn memory(argmem: readwrite) }
attributes #2 = { nofree nounwind "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #3 = { nounwind }

!llvm.module.flags = !{!0, !1, !2, !3}
!llvm.ident = !{!4}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{i32 8, !"PIC Level", i32 2}
!2 = !{i32 7, !"PIE Level", i32 2}
!3 = !{i32 7, !"uwtable", i32 2}
!4 = !{!"Ubuntu clang version 18.1.3 (1ubuntu1)"}
!5 = !{!6, !6, i64 0}
!6 = !{!"int", !7, i64 0}
!7 = !{!"omnipotent char", !8, i64 0}
!8 = !{!"Simple C/C++ TBAA"}
!9 = distinct !{!9, !10}
!10 = !{!"llvm.loop.mustprogress"}
; *** IR Dump After InlinerPass on (main) ***
; Function Attrs: nounwind uwtable
define dso_local i32 @main() local_unnamed_addr #0 {
  %1 = alloca i32, align 4
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %1) #3
  %2 = call i32 (ptr, ...) @__isoc99_scanf(ptr noundef nonnull @.str, ptr noundef nonnull %1)
  br label %3

3:                                                ; preds = %10, %0
  %4 = phi i64 [ 1, %0 ], [ %12, %10 ]
  %5 = phi i32 [ 1, %0 ], [ %13, %10 ]
  %6 = load i32, ptr %1, align 4, !tbaa !5
  %7 = icmp sgt i32 %5, %6
  br i1 %7, label %8, label %10

8:                                                ; preds = %3
  %9 = call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.1, i64 noundef %4)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %1) #3
  ret i32 0

10:                                               ; preds = %3
  %11 = zext nneg i32 %5 to i64
  %12 = mul i64 %4, %11
  %13 = add nuw nsw i32 %5, 1
  br label %3, !llvm.loop !9
}
; *** IR Dump After PostOrderFunctionAttrsPass on (main) ***
; Function Attrs: nounwind uwtable
define dso_local i32 @main() local_unnamed_addr #0 {
  %1 = alloca i32, align 4
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %1) #3
  %2 = call i32 (ptr, ...) @__isoc99_scanf(ptr noundef nonnull @.str, ptr noundef nonnull %1)
  br label %3

3:                                                ; preds = %10, %0
  %4 = phi i64 [ 1, %0 ], [ %12, %10 ]
  %5 = phi i32 [ 1, %0 ], [ %13, %10 ]
  %6 = load i32, ptr %1, align 4, !tbaa !5
  %7 = icmp sgt i32 %5, %6
  br i1 %7, label %8, label %10

8:                                                ; preds = %3
  %9 = call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.1, i64 noundef %4)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %1) #3
  ret i32 0

10:                                               ; preds = %3
  %11 = zext nneg i32 %5 to i64
  %12 = mul i64 %4, %11
  %13 = add nuw nsw i32 %5, 1
  br label %3, !llvm.loop !9
}
; *** IR Dump After OpenMPOptCGSCCPass on (main) ***
; Function Attrs: nounwind uwtable
define dso_local i32 @main() local_unnamed_addr #0 {
  %1 = alloca i32, align 4
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %1) #3
  %2 = call i32 (ptr, ...) @__isoc99_scanf(ptr noundef nonnull @.str, ptr noundef nonnull %1)
  br label %3

3:                                                ; preds = %10, %0
  %4 = phi i64 [ 1, %0 ], [ %12, %10 ]
  %5 = phi i32 [ 1, %0 ], [ %13, %10 ]
  %6 = load i32, ptr %1, align 4, !tbaa !5
  %7 = icmp sgt i32 %5, %6
  br i1 %7, label %8, label %10

8:                                                ; preds = %3
  %9 = call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.1, i64 noundef %4)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %1) #3
  ret i32 0

10:                                               ; preds = %3
  %11 = zext nneg i32 %5 to i64
  %12 = mul i64 %4, %11
  %13 = add nuw nsw i32 %5, 1
  br label %3, !llvm.loop !9
}
; *** IR Dump After SROAPass on main ***
; Function Attrs: nounwind uwtable
define dso_local i32 @main() local_unnamed_addr #0 {
  %1 = alloca i32, align 4
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %1) #3
  %2 = call i32 (ptr, ...) @__isoc99_scanf(ptr noundef nonnull @.str, ptr noundef nonnull %1)
  br label %3

3:                                                ; preds = %10, %0
  %4 = phi i64 [ 1, %0 ], [ %12, %10 ]
  %5 = phi i32 [ 1, %0 ], [ %13, %10 ]
  %6 = load i32, ptr %1, align 4, !tbaa !5
  %7 = icmp sgt i32 %5, %6
  br i1 %7, label %8, label %10

8:                                                ; preds = %3
  %9 = call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.1, i64 noundef %4)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %1) #3
  ret i32 0

10:                                               ; preds = %3
  %11 = zext nneg i32 %5 to i64
  %12 = mul i64 %4, %11
  %13 = add nuw nsw i32 %5, 1
  br label %3, !llvm.loop !9
}
; *** IR Dump After EarlyCSEPass on main ***
; Function Attrs: nounwind uwtable
define dso_local i32 @main() local_unnamed_addr #0 {
  %1 = alloca i32, align 4
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %1) #3
  %2 = call i32 (ptr, ...) @__isoc99_scanf(ptr noundef nonnull @.str, ptr noundef nonnull %1)
  br label %3

3:                                                ; preds = %10, %0
  %4 = phi i64 [ 1, %0 ], [ %12, %10 ]
  %5 = phi i32 [ 1, %0 ], [ %13, %10 ]
  %6 = load i32, ptr %1, align 4, !tbaa !5
  %7 = icmp sgt i32 %5, %6
  br i1 %7, label %8, label %10

8:                                                ; preds = %3
  %9 = call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.1, i64 noundef %4)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %1) #3
  ret i32 0

10:                                               ; preds = %3
  %11 = zext nneg i32 %5 to i64
  %12 = mul i64 %4, %11
  %13 = add nuw nsw i32 %5, 1
  br label %3, !llvm.loop !9
}
; *** IR Dump After SpeculativeExecutionPass on main ***
; Function Attrs: nounwind uwtable
define dso_local i32 @main() local_unnamed_addr #0 {
  %1 = alloca i32, align 4
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %1) #3
  %2 = call i32 (ptr, ...) @__isoc99_scanf(ptr noundef nonnull @.str, ptr noundef nonnull %1)
  br label %3

3:                                                ; preds = %10, %0
  %4 = phi i64 [ 1, %0 ], [ %12, %10 ]
  %5 = phi i32 [ 1, %0 ], [ %13, %10 ]
  %6 = load i32, ptr %1, align 4, !tbaa !5
  %7 = icmp sgt i32 %5, %6
  br i1 %7, label %8, label %10

8:                                                ; preds = %3
  %9 = call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.1, i64 noundef %4)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %1) #3
  ret i32 0

10:                                               ; preds = %3
  %11 = zext nneg i32 %5 to i64
  %12 = mul i64 %4, %11
  %13 = add nuw nsw i32 %5, 1
  br label %3, !llvm.loop !9
}
; *** IR Dump After JumpThreadingPass on main ***
; Function Attrs: nounwind uwtable
define dso_local i32 @main() local_unnamed_addr #0 {
  %1 = alloca i32, align 4
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %1) #3
  %2 = call i32 (ptr, ...) @__isoc99_scanf(ptr noundef nonnull @.str, ptr noundef nonnull %1)
  br label %3

3:                                                ; preds = %10, %0
  %4 = phi i64 [ 1, %0 ], [ %12, %10 ]
  %5 = phi i32 [ 1, %0 ], [ %13, %10 ]
  %6 = load i32, ptr %1, align 4, !tbaa !5
  %7 = icmp sgt i32 %5, %6
  br i1 %7, label %8, label %10

8:                                                ; preds = %3
  %9 = call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.1, i64 noundef %4)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %1) #3
  ret i32 0

10:                                               ; preds = %3
  %11 = zext nneg i32 %5 to i64
  %12 = mul i64 %4, %11
  %13 = add nuw nsw i32 %5, 1
  br label %3, !llvm.loop !9
}
; *** IR Dump After CorrelatedValuePropagationPass on main ***
; Function Attrs: nounwind uwtable
define dso_local i32 @main() local_unnamed_addr #0 {
  %1 = alloca i32, align 4
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %1) #3
  %2 = call i32 (ptr, ...) @__isoc99_scanf(ptr noundef nonnull @.str, ptr noundef nonnull %1)
  br label %3

3:                                                ; preds = %10, %0
  %4 = phi i64 [ 1, %0 ], [ %12, %10 ]
  %5 = phi i32 [ 1, %0 ], [ %13, %10 ]
  %6 = load i32, ptr %1, align 4, !tbaa !5
  %7 = icmp sgt i32 %5, %6
  br i1 %7, label %8, label %10

8:                                                ; preds = %3
  %9 = call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.1, i64 noundef %4)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %1) #3
  ret i32 0

10:                                               ; preds = %3
  %11 = zext nneg i32 %5 to i64
  %12 = mul i64 %4, %11
  %13 = add nuw nsw i32 %5, 1
  br label %3, !llvm.loop !9
}
; *** IR Dump After SimplifyCFGPass on main ***
; Function Attrs: nounwind uwtable
define dso_local i32 @main() local_unnamed_addr #0 {
  %1 = alloca i32, align 4
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %1) #3
  %2 = call i32 (ptr, ...) @__isoc99_scanf(ptr noundef nonnull @.str, ptr noundef nonnull %1)
  br label %3

3:                                                ; preds = %10, %0
  %4 = phi i64 [ 1, %0 ], [ %12, %10 ]
  %5 = phi i32 [ 1, %0 ], [ %13, %10 ]
  %6 = load i32, ptr %1, align 4, !tbaa !5
  %7 = icmp sgt i32 %5, %6
  br i1 %7, label %8, label %10

8:                                                ; preds = %3
  %9 = call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.1, i64 noundef %4)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %1) #3
  ret i32 0

10:                                               ; preds = %3
  %11 = zext nneg i32 %5 to i64
  %12 = mul i64 %4, %11
  %13 = add nuw nsw i32 %5, 1
  br label %3, !llvm.loop !9
}
; *** IR Dump After InstCombinePass on main ***
; Function Attrs: nounwind uwtable
define dso_local i32 @main() local_unnamed_addr #0 {
  %1 = alloca i32, align 4
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %1) #3
  %2 = call i32 (ptr, ...) @__isoc99_scanf(ptr noundef nonnull @.str, ptr noundef nonnull %1)
  br label %3

3:                                                ; preds = %10, %0
  %4 = phi i64 [ 1, %0 ], [ %12, %10 ]
  %5 = phi i32 [ 1, %0 ], [ %13, %10 ]
  %6 = load i32, ptr %1, align 4, !tbaa !5
  %7 = icmp sgt i32 %5, %6
  br i1 %7, label %8, label %10

8:                                                ; preds = %3
  %9 = call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.1, i64 noundef %4)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %1) #3
  ret i32 0

10:                                               ; preds = %3
  %11 = zext nneg i32 %5 to i64
  %12 = mul i64 %4, %11
  %13 = add nuw nsw i32 %5, 1
  br label %3, !llvm.loop !9
}
; *** IR Dump After AggressiveInstCombinePass on main ***
; Function Attrs: nounwind uwtable
define dso_local i32 @main() local_unnamed_addr #0 {
  %1 = alloca i32, align 4
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %1) #3
  %2 = call i32 (ptr, ...) @__isoc99_scanf(ptr noundef nonnull @.str, ptr noundef nonnull %1)
  br label %3

3:                                                ; preds = %10, %0
  %4 = phi i64 [ 1, %0 ], [ %12, %10 ]
  %5 = phi i32 [ 1, %0 ], [ %13, %10 ]
  %6 = load i32, ptr %1, align 4, !tbaa !5
  %7 = icmp sgt i32 %5, %6
  br i1 %7, label %8, label %10

8:                                                ; preds = %3
  %9 = call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.1, i64 noundef %4)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %1) #3
  ret i32 0

10:                                               ; preds = %3
  %11 = zext nneg i32 %5 to i64
  %12 = mul i64 %4, %11
  %13 = add nuw nsw i32 %5, 1
  br label %3, !llvm.loop !9
}
; *** IR Dump After LibCallsShrinkWrapPass on main ***
; Function Attrs: nounwind uwtable
define dso_local i32 @main() local_unnamed_addr #0 {
  %1 = alloca i32, align 4
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %1) #3
  %2 = call i32 (ptr, ...) @__isoc99_scanf(ptr noundef nonnull @.str, ptr noundef nonnull %1)
  br label %3

3:                                                ; preds = %10, %0
  %4 = phi i64 [ 1, %0 ], [ %12, %10 ]
  %5 = phi i32 [ 1, %0 ], [ %13, %10 ]
  %6 = load i32, ptr %1, align 4, !tbaa !5
  %7 = icmp sgt i32 %5, %6
  br i1 %7, label %8, label %10

8:                                                ; preds = %3
  %9 = call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.1, i64 noundef %4)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %1) #3
  ret i32 0

10:                                               ; preds = %3
  %11 = zext nneg i32 %5 to i64
  %12 = mul i64 %4, %11
  %13 = add nuw nsw i32 %5, 1
  br label %3, !llvm.loop !9
}
; *** IR Dump After TailCallElimPass on main ***
; Function Attrs: nounwind uwtable
define dso_local i32 @main() local_unnamed_addr #0 {
  %1 = alloca i32, align 4
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %1) #3
  %2 = call i32 (ptr, ...) @__isoc99_scanf(ptr noundef nonnull @.str, ptr noundef nonnull %1)
  br label %3

3:                                                ; preds = %10, %0
  %4 = phi i64 [ 1, %0 ], [ %12, %10 ]
  %5 = phi i32 [ 1, %0 ], [ %13, %10 ]
  %6 = load i32, ptr %1, align 4, !tbaa !5
  %7 = icmp sgt i32 %5, %6
  br i1 %7, label %8, label %10

8:                                                ; preds = %3
  %9 = call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.1, i64 noundef %4)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %1) #3
  ret i32 0

10:                                               ; preds = %3
  %11 = zext nneg i32 %5 to i64
  %12 = mul i64 %4, %11
  %13 = add nuw nsw i32 %5, 1
  br label %3, !llvm.loop !9
}
; *** IR Dump After SimplifyCFGPass on main ***
; Function Attrs: nounwind uwtable
define dso_local i32 @main() local_unnamed_addr #0 {
  %1 = alloca i32, align 4
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %1) #3
  %2 = call i32 (ptr, ...) @__isoc99_scanf(ptr noundef nonnull @.str, ptr noundef nonnull %1)
  br label %3

3:                                                ; preds = %10, %0
  %4 = phi i64 [ 1, %0 ], [ %12, %10 ]
  %5 = phi i32 [ 1, %0 ], [ %13, %10 ]
  %6 = load i32, ptr %1, align 4, !tbaa !5
  %7 = icmp sgt i32 %5, %6
  br i1 %7, label %8, label %10

8:                                                ; preds = %3
  %9 = call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.1, i64 noundef %4)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %1) #3
  ret i32 0

10:                                               ; preds = %3
  %11 = zext nneg i32 %5 to i64
  %12 = mul i64 %4, %11
  %13 = add nuw nsw i32 %5, 1
  br label %3, !llvm.loop !9
}
; *** IR Dump After ReassociatePass on main ***
; Function Attrs: nounwind uwtable
define dso_local i32 @main() local_unnamed_addr #0 {
  %1 = alloca i32, align 4
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %1) #3
  %2 = call i32 (ptr, ...) @__isoc99_scanf(ptr noundef nonnull @.str, ptr noundef nonnull %1)
  br label %3

3:                                                ; preds = %10, %0
  %4 = phi i64 [ 1, %0 ], [ %12, %10 ]
  %5 = phi i32 [ 1, %0 ], [ %13, %10 ]
  %6 = load i32, ptr %1, align 4, !tbaa !5
  %7 = icmp sgt i32 %5, %6
  br i1 %7, label %8, label %10

8:                                                ; preds = %3
  %9 = call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.1, i64 noundef %4)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %1) #3
  ret i32 0

10:                                               ; preds = %3
  %11 = zext nneg i32 %5 to i64
  %12 = mul i64 %11, %4
  %13 = add nuw nsw i32 %5, 1
  br label %3, !llvm.loop !9
}
; *** IR Dump After ConstraintEliminationPass on main ***
; Function Attrs: nounwind uwtable
define dso_local i32 @main() local_unnamed_addr #0 {
  %1 = alloca i32, align 4
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %1) #3
  %2 = call i32 (ptr, ...) @__isoc99_scanf(ptr noundef nonnull @.str, ptr noundef nonnull %1)
  br label %3

3:                                                ; preds = %10, %0
  %4 = phi i64 [ 1, %0 ], [ %12, %10 ]
  %5 = phi i32 [ 1, %0 ], [ %13, %10 ]
  %6 = load i32, ptr %1, align 4, !tbaa !5
  %7 = icmp sgt i32 %5, %6
  br i1 %7, label %8, label %10

8:                                                ; preds = %3
  %9 = call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.1, i64 noundef %4)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %1) #3
  ret i32 0

10:                                               ; preds = %3
  %11 = zext nneg i32 %5 to i64
  %12 = mul i64 %11, %4
  %13 = add nuw nsw i32 %5, 1
  br label %3, !llvm.loop !9
}
; *** IR Dump After LoopSimplifyPass on main ***
; Function Attrs: nounwind uwtable
define dso_local i32 @main() local_unnamed_addr #0 {
  %1 = alloca i32, align 4
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %1) #3
  %2 = call i32 (ptr, ...) @__isoc99_scanf(ptr noundef nonnull @.str, ptr noundef nonnull %1)
  br label %3

3:                                                ; preds = %10, %0
  %4 = phi i64 [ 1, %0 ], [ %12, %10 ]
  %5 = phi i32 [ 1, %0 ], [ %13, %10 ]
  %6 = load i32, ptr %1, align 4, !tbaa !5
  %7 = icmp sgt i32 %5, %6
  br i1 %7, label %8, label %10

8:                                                ; preds = %3
  %9 = call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.1, i64 noundef %4)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %1) #3
  ret i32 0

10:                                               ; preds = %3
  %11 = zext nneg i32 %5 to i64
  %12 = mul i64 %11, %4
  %13 = add nuw nsw i32 %5, 1
  br label %3, !llvm.loop !9
}
; *** IR Dump After LCSSAPass on main ***
; Function Attrs: nounwind uwtable
define dso_local i32 @main() local_unnamed_addr #0 {
  %1 = alloca i32, align 4
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %1) #3
  %2 = call i32 (ptr, ...) @__isoc99_scanf(ptr noundef nonnull @.str, ptr noundef nonnull %1)
  br label %3

3:                                                ; preds = %11, %0
  %4 = phi i64 [ 1, %0 ], [ %13, %11 ]
  %5 = phi i32 [ 1, %0 ], [ %14, %11 ]
  %6 = load i32, ptr %1, align 4, !tbaa !5
  %7 = icmp sgt i32 %5, %6
  br i1 %7, label %8, label %11

8:                                                ; preds = %3
  %9 = phi i64 [ %4, %3 ]
  %10 = call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.1, i64 noundef %9)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %1) #3
  ret i32 0

11:                                               ; preds = %3
  %12 = zext nneg i32 %5 to i64
  %13 = mul i64 %12, %4
  %14 = add nuw nsw i32 %5, 1
  br label %3, !llvm.loop !9
}
; *** IR Dump After LoopInstSimplifyPass on <unnamed loop> ***

; Preheader:
  %1 = alloca i32, align 4
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %1) #3
  %2 = call i32 (ptr, ...) @__isoc99_scanf(ptr noundef nonnull @.str, ptr noundef nonnull %1)
  br label %3

; Loop:
3:                                                ; preds = %11, %0
  %4 = phi i64 [ 1, %0 ], [ %13, %11 ]
  %5 = phi i32 [ 1, %0 ], [ %14, %11 ]
  %6 = load i32, ptr %1, align 4, !tbaa !5
  %7 = icmp sgt i32 %5, %6
  br i1 %7, label %8, label %11

11:                                               ; preds = %3
  %12 = zext nneg i32 %5 to i64
  %13 = mul i64 %12, %4
  %14 = add nuw nsw i32 %5, 1
  br label %3, !llvm.loop !9

; Exit blocks
8:                                                ; preds = %3
  %9 = phi i64 [ %4, %3 ]
  %10 = call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.1, i64 noundef %9)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %1) #3
  ret i32 0
; *** IR Dump After LoopSimplifyCFGPass on <unnamed loop> ***

; Preheader:
  %1 = alloca i32, align 4
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %1) #3
  %2 = call i32 (ptr, ...) @__isoc99_scanf(ptr noundef nonnull @.str, ptr noundef nonnull %1)
  br label %3

; Loop:
3:                                                ; preds = %11, %0
  %4 = phi i64 [ 1, %0 ], [ %13, %11 ]
  %5 = phi i32 [ 1, %0 ], [ %14, %11 ]
  %6 = load i32, ptr %1, align 4, !tbaa !5
  %7 = icmp sgt i32 %5, %6
  br i1 %7, label %8, label %11

11:                                               ; preds = %3
  %12 = zext nneg i32 %5 to i64
  %13 = mul i64 %12, %4
  %14 = add nuw nsw i32 %5, 1
  br label %3, !llvm.loop !9

; Exit blocks
8:                                                ; preds = %3
  %9 = phi i64 [ %4, %3 ]
  %10 = call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.1, i64 noundef %9)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %1) #3
  ret i32 0
; *** IR Dump After LICMPass on <unnamed loop> ***

; Preheader:
  %1 = alloca i32, align 4
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %1) #3
  %2 = call i32 (ptr, ...) @__isoc99_scanf(ptr noundef nonnull @.str, ptr noundef nonnull %1)
  %3 = load i32, ptr %1, align 4, !tbaa !5
  br label %4

; Loop:
4:                                                ; preds = %11, %0
  %5 = phi i64 [ 1, %0 ], [ %13, %11 ]
  %6 = phi i32 [ 1, %0 ], [ %14, %11 ]
  %7 = icmp sgt i32 %6, %3
  br i1 %7, label %8, label %11

11:                                               ; preds = %4
  %12 = zext nneg i32 %6 to i64
  %13 = mul i64 %12, %5
  %14 = add nuw nsw i32 %6, 1
  br label %4, !llvm.loop !9

; Exit blocks
8:                                                ; preds = %4
  %9 = phi i64 [ %5, %4 ]
  %10 = call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.1, i64 noundef %9)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %1) #3
  ret i32 0
; *** IR Dump After LoopRotatePass on <unnamed loop> ***

; Preheader:
5:                                                ; preds = %0
  br label %11

; Loop:
11:                                               ; preds = %5, %11
  %12 = phi i32 [ 1, %5 ], [ %16, %11 ]
  %13 = phi i64 [ 1, %5 ], [ %15, %11 ]
  %14 = zext nneg i32 %12 to i64
  %15 = mul i64 %14, %13
  %16 = add nuw nsw i32 %12, 1
  %17 = icmp sgt i32 %16, %3
  br i1 %17, label %6, label %11, !llvm.loop !9

; Exit blocks
6:                                                ; preds = %11
  %7 = phi i64 [ %15, %11 ]
  br label %8
; *** IR Dump After LICMPass on <unnamed loop> ***

; Preheader:
5:                                                ; preds = %0
  br label %11

; Loop:
11:                                               ; preds = %5, %11
  %12 = phi i32 [ 1, %5 ], [ %16, %11 ]
  %13 = phi i64 [ 1, %5 ], [ %15, %11 ]
  %14 = zext nneg i32 %12 to i64
  %15 = mul i64 %14, %13
  %16 = add nuw nsw i32 %12, 1
  %17 = icmp sgt i32 %16, %3
  br i1 %17, label %6, label %11, !llvm.loop !9

; Exit blocks
6:                                                ; preds = %11
  %7 = phi i64 [ %15, %11 ]
  br label %8
; *** IR Dump After SimpleLoopUnswitchPass on <unnamed loop> ***

; Preheader:
5:                                                ; preds = %0
  br label %11

; Loop:
11:                                               ; preds = %5, %11
  %12 = phi i32 [ 1, %5 ], [ %16, %11 ]
  %13 = phi i64 [ 1, %5 ], [ %15, %11 ]
  %14 = zext nneg i32 %12 to i64
  %15 = mul i64 %14, %13
  %16 = add nuw nsw i32 %12, 1
  %17 = icmp sgt i32 %16, %3
  br i1 %17, label %6, label %11, !llvm.loop !9

; Exit blocks
6:                                                ; preds = %11
  %7 = phi i64 [ %15, %11 ]
  br label %8
; *** IR Dump After SimplifyCFGPass on main ***
; Function Attrs: nounwind uwtable
define dso_local i32 @main() local_unnamed_addr #0 {
  %1 = alloca i32, align 4
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %1) #3
  %2 = call i32 (ptr, ...) @__isoc99_scanf(ptr noundef nonnull @.str, ptr noundef nonnull %1)
  %3 = load i32, ptr %1, align 4, !tbaa !5
  %4 = icmp sgt i32 1, %3
  br i1 %4, label %5, label %8

5:                                                ; preds = %8, %0
  %6 = phi i64 [ 1, %0 ], [ %12, %8 ]
  %7 = call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.1, i64 noundef %6)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %1) #3
  ret i32 0

8:                                                ; preds = %0, %8
  %9 = phi i32 [ %13, %8 ], [ 1, %0 ]
  %10 = phi i64 [ %12, %8 ], [ 1, %0 ]
  %11 = zext nneg i32 %9 to i64
  %12 = mul i64 %11, %10
  %13 = add nuw nsw i32 %9, 1
  %14 = icmp sgt i32 %13, %3
  br i1 %14, label %5, label %8, !llvm.loop !9
}
; *** IR Dump After InstCombinePass on main ***
; Function Attrs: nounwind uwtable
define dso_local i32 @main() local_unnamed_addr #0 {
  %1 = alloca i32, align 4
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %1) #3
  %2 = call i32 (ptr, ...) @__isoc99_scanf(ptr noundef nonnull @.str, ptr noundef nonnull %1)
  %3 = load i32, ptr %1, align 4, !tbaa !5
  %4 = icmp slt i32 %3, 1
  br i1 %4, label %5, label %8

5:                                                ; preds = %8, %0
  %6 = phi i64 [ 1, %0 ], [ %12, %8 ]
  %7 = call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.1, i64 noundef %6)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %1) #3
  ret i32 0

8:                                                ; preds = %0, %8
  %9 = phi i32 [ %13, %8 ], [ 1, %0 ]
  %10 = phi i64 [ %12, %8 ], [ 1, %0 ]
  %11 = zext nneg i32 %9 to i64
  %12 = mul i64 %10, %11
  %13 = add nuw nsw i32 %9, 1
  %14 = icmp slt i32 %9, %3
  br i1 %14, label %8, label %5, !llvm.loop !9
}
; *** IR Dump After LoopSimplifyPass on main ***
; Function Attrs: nounwind uwtable
define dso_local i32 @main() local_unnamed_addr #0 {
  %1 = alloca i32, align 4
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %1) #3
  %2 = call i32 (ptr, ...) @__isoc99_scanf(ptr noundef nonnull @.str, ptr noundef nonnull %1)
  %3 = load i32, ptr %1, align 4, !tbaa !5
  %4 = icmp slt i32 %3, 1
  br i1 %4, label %7, label %5

5:                                                ; preds = %0
  br label %10

6:                                                ; preds = %10
  br label %7

7:                                                ; preds = %6, %0
  %8 = phi i64 [ 1, %0 ], [ %14, %6 ]
  %9 = call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.1, i64 noundef %8)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %1) #3
  ret i32 0

10:                                               ; preds = %5, %10
  %11 = phi i32 [ %15, %10 ], [ 1, %5 ]
  %12 = phi i64 [ %14, %10 ], [ 1, %5 ]
  %13 = zext nneg i32 %11 to i64
  %14 = mul i64 %12, %13
  %15 = add nuw nsw i32 %11, 1
  %16 = icmp slt i32 %11, %3
  br i1 %16, label %10, label %6, !llvm.loop !9
}
; *** IR Dump After LCSSAPass on main ***
; Function Attrs: nounwind uwtable
define dso_local i32 @main() local_unnamed_addr #0 {
  %1 = alloca i32, align 4
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %1) #3
  %2 = call i32 (ptr, ...) @__isoc99_scanf(ptr noundef nonnull @.str, ptr noundef nonnull %1)
  %3 = load i32, ptr %1, align 4, !tbaa !5
  %4 = icmp slt i32 %3, 1
  br i1 %4, label %8, label %5

5:                                                ; preds = %0
  br label %11

6:                                                ; preds = %11
  %7 = phi i64 [ %15, %11 ]
  br label %8

8:                                                ; preds = %6, %0
  %9 = phi i64 [ 1, %0 ], [ %7, %6 ]
  %10 = call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.1, i64 noundef %9)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %1) #3
  ret i32 0

11:                                               ; preds = %5, %11
  %12 = phi i32 [ %16, %11 ], [ 1, %5 ]
  %13 = phi i64 [ %15, %11 ], [ 1, %5 ]
  %14 = zext nneg i32 %12 to i64
  %15 = mul i64 %13, %14
  %16 = add nuw nsw i32 %12, 1
  %17 = icmp slt i32 %12, %3
  br i1 %17, label %11, label %6, !llvm.loop !9
}
; *** IR Dump After LoopIdiomRecognizePass on <unnamed loop> ***

; Preheader:
5:                                                ; preds = %0
  br label %11

; Loop:
11:                                               ; preds = %5, %11
  %12 = phi i32 [ %16, %11 ], [ 1, %5 ]
  %13 = phi i64 [ %15, %11 ], [ 1, %5 ]
  %14 = zext nneg i32 %12 to i64
  %15 = mul i64 %13, %14
  %16 = add nuw nsw i32 %12, 1
  %17 = icmp slt i32 %12, %3
  br i1 %17, label %11, label %6, !llvm.loop !9

; Exit blocks
6:                                                ; preds = %11
  %7 = phi i64 [ %15, %11 ]
  br label %8
; *** IR Dump After IndVarSimplifyPass on <unnamed loop> ***

; Preheader:
5:                                                ; preds = %0
  %6 = add i32 %3, 1
  %7 = zext i32 %6 to i64
  br label %13

; Loop:
13:                                               ; preds = %5, %13
  %14 = phi i64 [ 1, %5 ], [ %17, %13 ]
  %15 = phi i64 [ %16, %13 ], [ 1, %5 ]
  %16 = mul i64 %15, %14
  %17 = add nuw nsw i64 %14, 1
  %18 = icmp ne i64 %17, %7
  br i1 %18, label %13, label %8, !llvm.loop !9

; Exit blocks
8:                                                ; preds = %13
  %9 = phi i64 [ %16, %13 ]
  br label %10
; *** IR Dump After LoopDeletionPass on <unnamed loop> ***

; Preheader:
5:                                                ; preds = %0
  %6 = add i32 %3, 1
  %7 = zext i32 %6 to i64
  br label %13

; Loop:
13:                                               ; preds = %5, %13
  %14 = phi i64 [ 1, %5 ], [ %17, %13 ]
  %15 = phi i64 [ %16, %13 ], [ 1, %5 ]
  %16 = mul i64 %15, %14
  %17 = add nuw nsw i64 %14, 1
  %18 = icmp ne i64 %17, %7
  br i1 %18, label %13, label %8, !llvm.loop !9

; Exit blocks
8:                                                ; preds = %13
  %9 = phi i64 [ %16, %13 ]
  br label %10
; *** IR Dump After LoopFullUnrollPass on <unnamed loop> ***

; Preheader:
5:                                                ; preds = %0
  %6 = add i32 %3, 1
  %7 = zext i32 %6 to i64
  br label %13

; Loop:
13:                                               ; preds = %5, %13
  %14 = phi i64 [ 1, %5 ], [ %17, %13 ]
  %15 = phi i64 [ %16, %13 ], [ 1, %5 ]
  %16 = mul i64 %15, %14
  %17 = add nuw nsw i64 %14, 1
  %18 = icmp ne i64 %17, %7
  br i1 %18, label %13, label %8, !llvm.loop !9

; Exit blocks
8:                                                ; preds = %13
  %9 = phi i64 [ %16, %13 ]
  br label %10
; *** IR Dump After SROAPass on main ***
; Function Attrs: nounwind uwtable
define dso_local i32 @main() local_unnamed_addr #0 {
  %1 = alloca i32, align 4
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %1) #3
  %2 = call i32 (ptr, ...) @__isoc99_scanf(ptr noundef nonnull @.str, ptr noundef nonnull %1)
  %3 = load i32, ptr %1, align 4, !tbaa !5
  %4 = icmp slt i32 %3, 1
  br i1 %4, label %10, label %5

5:                                                ; preds = %0
  %6 = add i32 %3, 1
  %7 = zext i32 %6 to i64
  br label %13

8:                                                ; preds = %13
  %9 = phi i64 [ %16, %13 ]
  br label %10

10:                                               ; preds = %8, %0
  %11 = phi i64 [ 1, %0 ], [ %9, %8 ]
  %12 = call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.1, i64 noundef %11)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %1) #3
  ret i32 0

13:                                               ; preds = %5, %13
  %14 = phi i64 [ 1, %5 ], [ %17, %13 ]
  %15 = phi i64 [ %16, %13 ], [ 1, %5 ]
  %16 = mul i64 %15, %14
  %17 = add nuw nsw i64 %14, 1
  %18 = icmp ne i64 %17, %7
  br i1 %18, label %13, label %8, !llvm.loop !9
}
; *** IR Dump After VectorCombinePass on main ***
; Function Attrs: nounwind uwtable
define dso_local i32 @main() local_unnamed_addr #0 {
  %1 = alloca i32, align 4
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %1) #3
  %2 = call i32 (ptr, ...) @__isoc99_scanf(ptr noundef nonnull @.str, ptr noundef nonnull %1)
  %3 = load i32, ptr %1, align 4, !tbaa !5
  %4 = icmp slt i32 %3, 1
  br i1 %4, label %10, label %5

5:                                                ; preds = %0
  %6 = add i32 %3, 1
  %7 = zext i32 %6 to i64
  br label %13

8:                                                ; preds = %13
  %9 = phi i64 [ %16, %13 ]
  br label %10

10:                                               ; preds = %8, %0
  %11 = phi i64 [ 1, %0 ], [ %9, %8 ]
  %12 = call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.1, i64 noundef %11)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %1) #3
  ret i32 0

13:                                               ; preds = %5, %13
  %14 = phi i64 [ 1, %5 ], [ %17, %13 ]
  %15 = phi i64 [ %16, %13 ], [ 1, %5 ]
  %16 = mul i64 %15, %14
  %17 = add nuw nsw i64 %14, 1
  %18 = icmp ne i64 %17, %7
  br i1 %18, label %13, label %8, !llvm.loop !9
}
; *** IR Dump After MergedLoadStoreMotionPass on main ***
; Function Attrs: nounwind uwtable
define dso_local i32 @main() local_unnamed_addr #0 {
  %1 = alloca i32, align 4
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %1) #3
  %2 = call i32 (ptr, ...) @__isoc99_scanf(ptr noundef nonnull @.str, ptr noundef nonnull %1)
  %3 = load i32, ptr %1, align 4, !tbaa !5
  %4 = icmp slt i32 %3, 1
  br i1 %4, label %10, label %5

5:                                                ; preds = %0
  %6 = add i32 %3, 1
  %7 = zext i32 %6 to i64
  br label %13

8:                                                ; preds = %13
  %9 = phi i64 [ %16, %13 ]
  br label %10

10:                                               ; preds = %8, %0
  %11 = phi i64 [ 1, %0 ], [ %9, %8 ]
  %12 = call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.1, i64 noundef %11)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %1) #3
  ret i32 0

13:                                               ; preds = %5, %13
  %14 = phi i64 [ 1, %5 ], [ %17, %13 ]
  %15 = phi i64 [ %16, %13 ], [ 1, %5 ]
  %16 = mul i64 %15, %14
  %17 = add nuw nsw i64 %14, 1
  %18 = icmp ne i64 %17, %7
  br i1 %18, label %13, label %8, !llvm.loop !9
}
; *** IR Dump After GVNPass on main ***
; Function Attrs: nounwind uwtable
define dso_local i32 @main() local_unnamed_addr #0 {
  %1 = alloca i32, align 4
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %1) #3
  %2 = call i32 (ptr, ...) @__isoc99_scanf(ptr noundef nonnull @.str, ptr noundef nonnull %1)
  %3 = load i32, ptr %1, align 4, !tbaa !5
  %4 = icmp slt i32 %3, 1
  br i1 %4, label %9, label %5

5:                                                ; preds = %0
  %6 = add i32 %3, 1
  %7 = zext i32 %6 to i64
  br label %12

8:                                                ; preds = %12
  br label %9

9:                                                ; preds = %8, %0
  %10 = phi i64 [ 1, %0 ], [ %15, %8 ]
  %11 = call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.1, i64 noundef %10)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %1) #3
  ret i32 0

12:                                               ; preds = %5, %12
  %13 = phi i64 [ 1, %5 ], [ %16, %12 ]
  %14 = phi i64 [ %15, %12 ], [ 1, %5 ]
  %15 = mul i64 %14, %13
  %16 = add nuw nsw i64 %13, 1
  %17 = icmp ne i64 %16, %7
  br i1 %17, label %12, label %8, !llvm.loop !9
}
; *** IR Dump After SCCPPass on main ***
; Function Attrs: nounwind uwtable
define dso_local i32 @main() local_unnamed_addr #0 {
  %1 = alloca i32, align 4
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %1) #3
  %2 = call i32 (ptr, ...) @__isoc99_scanf(ptr noundef nonnull @.str, ptr noundef nonnull %1)
  %3 = load i32, ptr %1, align 4, !tbaa !5
  %4 = icmp slt i32 %3, 1
  br i1 %4, label %9, label %5

5:                                                ; preds = %0
  %6 = add i32 %3, 1
  %7 = zext i32 %6 to i64
  br label %12

8:                                                ; preds = %12
  br label %9

9:                                                ; preds = %8, %0
  %10 = phi i64 [ 1, %0 ], [ %15, %8 ]
  %11 = call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.1, i64 noundef %10)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %1) #3
  ret i32 0

12:                                               ; preds = %5, %12
  %13 = phi i64 [ 1, %5 ], [ %16, %12 ]
  %14 = phi i64 [ %15, %12 ], [ 1, %5 ]
  %15 = mul i64 %14, %13
  %16 = add nuw nsw i64 %13, 1
  %17 = icmp ne i64 %16, %7
  br i1 %17, label %12, label %8, !llvm.loop !9
}
; *** IR Dump After BDCEPass on main ***
; Function Attrs: nounwind uwtable
define dso_local i32 @main() local_unnamed_addr #0 {
  %1 = alloca i32, align 4
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %1) #3
  %2 = call i32 (ptr, ...) @__isoc99_scanf(ptr noundef nonnull @.str, ptr noundef nonnull %1)
  %3 = load i32, ptr %1, align 4, !tbaa !5
  %4 = icmp slt i32 %3, 1
  br i1 %4, label %9, label %5

5:                                                ; preds = %0
  %6 = add i32 %3, 1
  %7 = zext i32 %6 to i64
  br label %12

8:                                                ; preds = %12
  br label %9

9:                                                ; preds = %8, %0
  %10 = phi i64 [ 1, %0 ], [ %15, %8 ]
  %11 = call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.1, i64 noundef %10)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %1) #3
  ret i32 0

12:                                               ; preds = %5, %12
  %13 = phi i64 [ 1, %5 ], [ %16, %12 ]
  %14 = phi i64 [ %15, %12 ], [ 1, %5 ]
  %15 = mul i64 %14, %13
  %16 = add nuw nsw i64 %13, 1
  %17 = icmp ne i64 %16, %7
  br i1 %17, label %12, label %8, !llvm.loop !9
}
; *** IR Dump After InstCombinePass on main ***
; Function Attrs: nounwind uwtable
define dso_local i32 @main() local_unnamed_addr #0 {
  %1 = alloca i32, align 4
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %1) #3
  %2 = call i32 (ptr, ...) @__isoc99_scanf(ptr noundef nonnull @.str, ptr noundef nonnull %1)
  %3 = load i32, ptr %1, align 4, !tbaa !5
  %4 = icmp slt i32 %3, 1
  br i1 %4, label %9, label %5

5:                                                ; preds = %0
  %6 = add nuw i32 %3, 1
  %7 = zext i32 %6 to i64
  br label %12

8:                                                ; preds = %12
  br label %9

9:                                                ; preds = %8, %0
  %10 = phi i64 [ 1, %0 ], [ %15, %8 ]
  %11 = call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.1, i64 noundef %10)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %1) #3
  ret i32 0

12:                                               ; preds = %5, %12
  %13 = phi i64 [ 1, %5 ], [ %16, %12 ]
  %14 = phi i64 [ 1, %5 ], [ %15, %12 ]
  %15 = mul i64 %14, %13
  %16 = add nuw nsw i64 %13, 1
  %17 = icmp eq i64 %16, %7
  br i1 %17, label %8, label %12, !llvm.loop !9
}
; *** IR Dump After JumpThreadingPass on main ***
; Function Attrs: nounwind uwtable
define dso_local i32 @main() local_unnamed_addr #0 {
  %1 = alloca i32, align 4
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %1) #3
  %2 = call i32 (ptr, ...) @__isoc99_scanf(ptr noundef nonnull @.str, ptr noundef nonnull %1)
  %3 = load i32, ptr %1, align 4, !tbaa !5
  %4 = icmp slt i32 %3, 1
  br i1 %4, label %8, label %5

5:                                                ; preds = %0
  %6 = add nuw i32 %3, 1
  %7 = zext i32 %6 to i64
  br label %11

8:                                                ; preds = %11, %0
  %9 = phi i64 [ 1, %0 ], [ %14, %11 ]
  %10 = call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.1, i64 noundef %9)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %1) #3
  ret i32 0

11:                                               ; preds = %5, %11
  %12 = phi i64 [ 1, %5 ], [ %15, %11 ]
  %13 = phi i64 [ 1, %5 ], [ %14, %11 ]
  %14 = mul i64 %13, %12
  %15 = add nuw nsw i64 %12, 1
  %16 = icmp eq i64 %15, %7
  br i1 %16, label %8, label %11, !llvm.loop !9
}
; *** IR Dump After CorrelatedValuePropagationPass on main ***
; Function Attrs: nounwind uwtable
define dso_local i32 @main() local_unnamed_addr #0 {
  %1 = alloca i32, align 4
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %1) #3
  %2 = call i32 (ptr, ...) @__isoc99_scanf(ptr noundef nonnull @.str, ptr noundef nonnull %1)
  %3 = load i32, ptr %1, align 4, !tbaa !5
  %4 = icmp slt i32 %3, 1
  br i1 %4, label %8, label %5

5:                                                ; preds = %0
  %6 = add nuw i32 %3, 1
  %7 = zext i32 %6 to i64
  br label %11

8:                                                ; preds = %11, %0
  %9 = phi i64 [ 1, %0 ], [ %14, %11 ]
  %10 = call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.1, i64 noundef %9)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %1) #3
  ret i32 0

11:                                               ; preds = %5, %11
  %12 = phi i64 [ 1, %5 ], [ %15, %11 ]
  %13 = phi i64 [ 1, %5 ], [ %14, %11 ]
  %14 = mul i64 %13, %12
  %15 = add nuw nsw i64 %12, 1
  %16 = icmp eq i64 %15, %7
  br i1 %16, label %8, label %11, !llvm.loop !9
}
; *** IR Dump After ADCEPass on main ***
; Function Attrs: nounwind uwtable
define dso_local i32 @main() local_unnamed_addr #0 {
  %1 = alloca i32, align 4
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %1) #3
  %2 = call i32 (ptr, ...) @__isoc99_scanf(ptr noundef nonnull @.str, ptr noundef nonnull %1)
  %3 = load i32, ptr %1, align 4, !tbaa !5
  %4 = icmp slt i32 %3, 1
  br i1 %4, label %8, label %5

5:                                                ; preds = %0
  %6 = add nuw i32 %3, 1
  %7 = zext i32 %6 to i64
  br label %11

8:                                                ; preds = %11, %0
  %9 = phi i64 [ 1, %0 ], [ %14, %11 ]
  %10 = call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.1, i64 noundef %9)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %1) #3
  ret i32 0

11:                                               ; preds = %5, %11
  %12 = phi i64 [ 1, %5 ], [ %15, %11 ]
  %13 = phi i64 [ 1, %5 ], [ %14, %11 ]
  %14 = mul i64 %13, %12
  %15 = add nuw nsw i64 %12, 1
  %16 = icmp eq i64 %15, %7
  br i1 %16, label %8, label %11, !llvm.loop !9
}
; *** IR Dump After MemCpyOptPass on main ***
; Function Attrs: nounwind uwtable
define dso_local i32 @main() local_unnamed_addr #0 {
  %1 = alloca i32, align 4
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %1) #3
  %2 = call i32 (ptr, ...) @__isoc99_scanf(ptr noundef nonnull @.str, ptr noundef nonnull %1)
  %3 = load i32, ptr %1, align 4, !tbaa !5
  %4 = icmp slt i32 %3, 1
  br i1 %4, label %8, label %5

5:                                                ; preds = %0
  %6 = add nuw i32 %3, 1
  %7 = zext i32 %6 to i64
  br label %11

8:                                                ; preds = %11, %0
  %9 = phi i64 [ 1, %0 ], [ %14, %11 ]
  %10 = call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.1, i64 noundef %9)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %1) #3
  ret i32 0

11:                                               ; preds = %5, %11
  %12 = phi i64 [ 1, %5 ], [ %15, %11 ]
  %13 = phi i64 [ 1, %5 ], [ %14, %11 ]
  %14 = mul i64 %13, %12
  %15 = add nuw nsw i64 %12, 1
  %16 = icmp eq i64 %15, %7
  br i1 %16, label %8, label %11, !llvm.loop !9
}
; *** IR Dump After DSEPass on main ***
; Function Attrs: nounwind uwtable
define dso_local i32 @main() local_unnamed_addr #0 {
  %1 = alloca i32, align 4
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %1) #3
  %2 = call i32 (ptr, ...) @__isoc99_scanf(ptr noundef nonnull @.str, ptr noundef nonnull %1)
  %3 = load i32, ptr %1, align 4, !tbaa !5
  %4 = icmp slt i32 %3, 1
  br i1 %4, label %8, label %5

5:                                                ; preds = %0
  %6 = add nuw i32 %3, 1
  %7 = zext i32 %6 to i64
  br label %11

8:                                                ; preds = %11, %0
  %9 = phi i64 [ 1, %0 ], [ %14, %11 ]
  %10 = call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.1, i64 noundef %9)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %1) #3
  ret i32 0

11:                                               ; preds = %5, %11
  %12 = phi i64 [ 1, %5 ], [ %15, %11 ]
  %13 = phi i64 [ 1, %5 ], [ %14, %11 ]
  %14 = mul i64 %13, %12
  %15 = add nuw nsw i64 %12, 1
  %16 = icmp eq i64 %15, %7
  br i1 %16, label %8, label %11, !llvm.loop !9
}
; *** IR Dump After MoveAutoInitPass on main ***
; Function Attrs: nounwind uwtable
define dso_local i32 @main() local_unnamed_addr #0 {
  %1 = alloca i32, align 4
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %1) #3
  %2 = call i32 (ptr, ...) @__isoc99_scanf(ptr noundef nonnull @.str, ptr noundef nonnull %1)
  %3 = load i32, ptr %1, align 4, !tbaa !5
  %4 = icmp slt i32 %3, 1
  br i1 %4, label %8, label %5

5:                                                ; preds = %0
  %6 = add nuw i32 %3, 1
  %7 = zext i32 %6 to i64
  br label %11

8:                                                ; preds = %11, %0
  %9 = phi i64 [ 1, %0 ], [ %14, %11 ]
  %10 = call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.1, i64 noundef %9)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %1) #3
  ret i32 0

11:                                               ; preds = %5, %11
  %12 = phi i64 [ 1, %5 ], [ %15, %11 ]
  %13 = phi i64 [ 1, %5 ], [ %14, %11 ]
  %14 = mul i64 %13, %12
  %15 = add nuw nsw i64 %12, 1
  %16 = icmp eq i64 %15, %7
  br i1 %16, label %8, label %11, !llvm.loop !9
}
; *** IR Dump After LoopSimplifyPass on main ***
; Function Attrs: nounwind uwtable
define dso_local i32 @main() local_unnamed_addr #0 {
  %1 = alloca i32, align 4
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %1) #3
  %2 = call i32 (ptr, ...) @__isoc99_scanf(ptr noundef nonnull @.str, ptr noundef nonnull %1)
  %3 = load i32, ptr %1, align 4, !tbaa !5
  %4 = icmp slt i32 %3, 1
  br i1 %4, label %9, label %5

5:                                                ; preds = %0
  %6 = add nuw i32 %3, 1
  %7 = zext i32 %6 to i64
  br label %12

8:                                                ; preds = %12
  br label %9

9:                                                ; preds = %8, %0
  %10 = phi i64 [ 1, %0 ], [ %15, %8 ]
  %11 = call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.1, i64 noundef %10)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %1) #3
  ret i32 0

12:                                               ; preds = %5, %12
  %13 = phi i64 [ 1, %5 ], [ %16, %12 ]
  %14 = phi i64 [ 1, %5 ], [ %15, %12 ]
  %15 = mul i64 %14, %13
  %16 = add nuw nsw i64 %13, 1
  %17 = icmp eq i64 %16, %7
  br i1 %17, label %8, label %12, !llvm.loop !9
}
; *** IR Dump After LCSSAPass on main ***
; Function Attrs: nounwind uwtable
define dso_local i32 @main() local_unnamed_addr #0 {
  %1 = alloca i32, align 4
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %1) #3
  %2 = call i32 (ptr, ...) @__isoc99_scanf(ptr noundef nonnull @.str, ptr noundef nonnull %1)
  %3 = load i32, ptr %1, align 4, !tbaa !5
  %4 = icmp slt i32 %3, 1
  br i1 %4, label %10, label %5

5:                                                ; preds = %0
  %6 = add nuw i32 %3, 1
  %7 = zext i32 %6 to i64
  br label %13

8:                                                ; preds = %13
  %9 = phi i64 [ %16, %13 ]
  br label %10

10:                                               ; preds = %8, %0
  %11 = phi i64 [ 1, %0 ], [ %9, %8 ]
  %12 = call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.1, i64 noundef %11)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %1) #3
  ret i32 0

13:                                               ; preds = %5, %13
  %14 = phi i64 [ 1, %5 ], [ %17, %13 ]
  %15 = phi i64 [ 1, %5 ], [ %16, %13 ]
  %16 = mul i64 %15, %14
  %17 = add nuw nsw i64 %14, 1
  %18 = icmp eq i64 %17, %7
  br i1 %18, label %8, label %13, !llvm.loop !9
}
; *** IR Dump After LICMPass on <unnamed loop> ***

; Preheader:
5:                                                ; preds = %0
  %6 = add nuw i32 %3, 1
  %7 = zext i32 %6 to i64
  br label %13

; Loop:
13:                                               ; preds = %5, %13
  %14 = phi i64 [ 1, %5 ], [ %17, %13 ]
  %15 = phi i64 [ 1, %5 ], [ %16, %13 ]
  %16 = mul i64 %15, %14
  %17 = add nuw nsw i64 %14, 1
  %18 = icmp eq i64 %17, %7
  br i1 %18, label %8, label %13, !llvm.loop !9

; Exit blocks
8:                                                ; preds = %13
  %9 = phi i64 [ %16, %13 ]
  br label %10
; *** IR Dump After CoroElidePass on main ***
; Function Attrs: nounwind uwtable
define dso_local i32 @main() local_unnamed_addr #0 {
  %1 = alloca i32, align 4
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %1) #3
  %2 = call i32 (ptr, ...) @__isoc99_scanf(ptr noundef nonnull @.str, ptr noundef nonnull %1)
  %3 = load i32, ptr %1, align 4, !tbaa !5
  %4 = icmp slt i32 %3, 1
  br i1 %4, label %10, label %5

5:                                                ; preds = %0
  %6 = add nuw i32 %3, 1
  %7 = zext i32 %6 to i64
  br label %13

8:                                                ; preds = %13
  %9 = phi i64 [ %16, %13 ]
  br label %10

10:                                               ; preds = %8, %0
  %11 = phi i64 [ 1, %0 ], [ %9, %8 ]
  %12 = call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.1, i64 noundef %11)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %1) #3
  ret i32 0

13:                                               ; preds = %5, %13
  %14 = phi i64 [ 1, %5 ], [ %17, %13 ]
  %15 = phi i64 [ 1, %5 ], [ %16, %13 ]
  %16 = mul i64 %15, %14
  %17 = add nuw nsw i64 %14, 1
  %18 = icmp eq i64 %17, %7
  br i1 %18, label %8, label %13, !llvm.loop !9
}
; *** IR Dump After SimplifyCFGPass on main ***
; Function Attrs: nounwind uwtable
define dso_local i32 @main() local_unnamed_addr #0 {
  %1 = alloca i32, align 4
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %1) #3
  %2 = call i32 (ptr, ...) @__isoc99_scanf(ptr noundef nonnull @.str, ptr noundef nonnull %1)
  %3 = load i32, ptr %1, align 4, !tbaa !5
  %4 = icmp slt i32 %3, 1
  br i1 %4, label %8, label %5

5:                                                ; preds = %0
  %6 = add nuw i32 %3, 1
  %7 = zext i32 %6 to i64
  br label %11

8:                                                ; preds = %11, %0
  %9 = phi i64 [ 1, %0 ], [ %14, %11 ]
  %10 = call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.1, i64 noundef %9)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %1) #3
  ret i32 0

11:                                               ; preds = %5, %11
  %12 = phi i64 [ 1, %5 ], [ %15, %11 ]
  %13 = phi i64 [ 1, %5 ], [ %14, %11 ]
  %14 = mul i64 %13, %12
  %15 = add nuw nsw i64 %12, 1
  %16 = icmp eq i64 %15, %7
  br i1 %16, label %8, label %11, !llvm.loop !9
}
; *** IR Dump After InstCombinePass on main ***
; Function Attrs: nounwind uwtable
define dso_local i32 @main() local_unnamed_addr #0 {
  %1 = alloca i32, align 4
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %1) #3
  %2 = call i32 (ptr, ...) @__isoc99_scanf(ptr noundef nonnull @.str, ptr noundef nonnull %1)
  %3 = load i32, ptr %1, align 4, !tbaa !5
  %4 = icmp slt i32 %3, 1
  br i1 %4, label %8, label %5

5:                                                ; preds = %0
  %6 = add nuw i32 %3, 1
  %7 = zext i32 %6 to i64
  br label %11

8:                                                ; preds = %11, %0
  %9 = phi i64 [ 1, %0 ], [ %14, %11 ]
  %10 = call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.1, i64 noundef %9)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %1) #3
  ret i32 0

11:                                               ; preds = %5, %11
  %12 = phi i64 [ 1, %5 ], [ %15, %11 ]
  %13 = phi i64 [ 1, %5 ], [ %14, %11 ]
  %14 = mul i64 %13, %12
  %15 = add nuw nsw i64 %12, 1
  %16 = icmp eq i64 %15, %7
  br i1 %16, label %8, label %11, !llvm.loop !9
}
; *** IR Dump After PostOrderFunctionAttrsPass on (main) ***
; Function Attrs: nofree nounwind uwtable
define dso_local noundef i32 @main() local_unnamed_addr #0 {
  %1 = alloca i32, align 4
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %1) #3
  %2 = call i32 (ptr, ...) @__isoc99_scanf(ptr noundef nonnull @.str, ptr noundef nonnull %1)
  %3 = load i32, ptr %1, align 4, !tbaa !5
  %4 = icmp slt i32 %3, 1
  br i1 %4, label %8, label %5

5:                                                ; preds = %0
  %6 = add nuw i32 %3, 1
  %7 = zext i32 %6 to i64
  br label %11

8:                                                ; preds = %11, %0
  %9 = phi i64 [ 1, %0 ], [ %14, %11 ]
  %10 = call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.1, i64 noundef %9)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %1) #3
  ret i32 0

11:                                               ; preds = %5, %11
  %12 = phi i64 [ 1, %5 ], [ %15, %11 ]
  %13 = phi i64 [ 1, %5 ], [ %14, %11 ]
  %14 = mul i64 %13, %12
  %15 = add nuw nsw i64 %12, 1
  %16 = icmp eq i64 %15, %7
  br i1 %16, label %8, label %11, !llvm.loop !9
}
; *** IR Dump After RequireAnalysisPass<llvm::ShouldNotRunFunctionPassesAnalysis, llvm::Function, llvm::AnalysisManager<Function>> on main ***
; Function Attrs: nofree nounwind uwtable
define dso_local noundef i32 @main() local_unnamed_addr #0 {
  %1 = alloca i32, align 4
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %1) #3
  %2 = call i32 (ptr, ...) @__isoc99_scanf(ptr noundef nonnull @.str, ptr noundef nonnull %1)
  %3 = load i32, ptr %1, align 4, !tbaa !5
  %4 = icmp slt i32 %3, 1
  br i1 %4, label %8, label %5

5:                                                ; preds = %0
  %6 = add nuw i32 %3, 1
  %7 = zext i32 %6 to i64
  br label %11

8:                                                ; preds = %11, %0
  %9 = phi i64 [ 1, %0 ], [ %14, %11 ]
  %10 = call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.1, i64 noundef %9)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %1) #3
  ret i32 0

11:                                               ; preds = %5, %11
  %12 = phi i64 [ 1, %5 ], [ %15, %11 ]
  %13 = phi i64 [ 1, %5 ], [ %14, %11 ]
  %14 = mul i64 %13, %12
  %15 = add nuw nsw i64 %12, 1
  %16 = icmp eq i64 %15, %7
  br i1 %16, label %8, label %11, !llvm.loop !9
}
; *** IR Dump After CoroSplitPass on (main) ***
; Function Attrs: nofree nounwind uwtable
define dso_local noundef i32 @main() local_unnamed_addr #0 {
  %1 = alloca i32, align 4
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %1) #3
  %2 = call i32 (ptr, ...) @__isoc99_scanf(ptr noundef nonnull @.str, ptr noundef nonnull %1)
  %3 = load i32, ptr %1, align 4, !tbaa !5
  %4 = icmp slt i32 %3, 1
  br i1 %4, label %8, label %5

5:                                                ; preds = %0
  %6 = add nuw i32 %3, 1
  %7 = zext i32 %6 to i64
  br label %11

8:                                                ; preds = %11, %0
  %9 = phi i64 [ 1, %0 ], [ %14, %11 ]
  %10 = call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.1, i64 noundef %9)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %1) #3
  ret i32 0

11:                                               ; preds = %5, %11
  %12 = phi i64 [ 1, %5 ], [ %15, %11 ]
  %13 = phi i64 [ 1, %5 ], [ %14, %11 ]
  %14 = mul i64 %13, %12
  %15 = add nuw nsw i64 %12, 1
  %16 = icmp eq i64 %15, %7
  br i1 %16, label %8, label %11, !llvm.loop !9
}
; *** IR Dump After InvalidateAnalysisPass<llvm::ShouldNotRunFunctionPassesAnalysis> on main ***
; Function Attrs: nofree nounwind uwtable
define dso_local noundef i32 @main() local_unnamed_addr #0 {
  %1 = alloca i32, align 4
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %1) #3
  %2 = call i32 (ptr, ...) @__isoc99_scanf(ptr noundef nonnull @.str, ptr noundef nonnull %1)
  %3 = load i32, ptr %1, align 4, !tbaa !5
  %4 = icmp slt i32 %3, 1
  br i1 %4, label %8, label %5

5:                                                ; preds = %0
  %6 = add nuw i32 %3, 1
  %7 = zext i32 %6 to i64
  br label %11

8:                                                ; preds = %11, %0
  %9 = phi i64 [ 1, %0 ], [ %14, %11 ]
  %10 = call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.1, i64 noundef %9)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %1) #3
  ret i32 0

11:                                               ; preds = %5, %11
  %12 = phi i64 [ 1, %5 ], [ %15, %11 ]
  %13 = phi i64 [ 1, %5 ], [ %14, %11 ]
  %14 = mul i64 %13, %12
  %15 = add nuw nsw i64 %12, 1
  %16 = icmp eq i64 %15, %7
  br i1 %16, label %8, label %11, !llvm.loop !9
}
; *** IR Dump After DeadArgumentEliminationPass on [module] ***
; ModuleID = 'main.c'
source_filename = "main.c"
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128"
target triple = "x86_64-pc-linux-gnu"

@.str = private unnamed_addr constant [3 x i8] c"%d\00", align 1
@.str.1 = private unnamed_addr constant [6 x i8] c"%llu\0A\00", align 1

; Function Attrs: nofree nounwind uwtable
define dso_local noundef i32 @main() local_unnamed_addr #0 {
  %1 = alloca i32, align 4
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %1) #3
  %2 = call i32 (ptr, ...) @__isoc99_scanf(ptr noundef nonnull @.str, ptr noundef nonnull %1)
  %3 = load i32, ptr %1, align 4, !tbaa !5
  %4 = icmp slt i32 %3, 1
  br i1 %4, label %8, label %5

5:                                                ; preds = %0
  %6 = add nuw i32 %3, 1
  %7 = zext i32 %6 to i64
  br label %11

8:                                                ; preds = %11, %0
  %9 = phi i64 [ 1, %0 ], [ %14, %11 ]
  %10 = call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.1, i64 noundef %9)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %1) #3
  ret i32 0

11:                                               ; preds = %5, %11
  %12 = phi i64 [ 1, %5 ], [ %15, %11 ]
  %13 = phi i64 [ 1, %5 ], [ %14, %11 ]
  %14 = mul i64 %13, %12
  %15 = add nuw nsw i64 %12, 1
  %16 = icmp eq i64 %15, %7
  br i1 %16, label %8, label %11, !llvm.loop !9
}

; Function Attrs: mustprogress nocallback nofree nosync nounwind willreturn memory(argmem: readwrite)
declare void @llvm.lifetime.start.p0(i64 immarg, ptr nocapture) #1

; Function Attrs: nofree nounwind
declare noundef i32 @__isoc99_scanf(ptr nocapture noundef readonly, ...) local_unnamed_addr #2

; Function Attrs: mustprogress nocallback nofree nosync nounwind willreturn memory(argmem: readwrite)
declare void @llvm.lifetime.end.p0(i64 immarg, ptr nocapture) #1

; Function Attrs: nofree nounwind
declare noundef i32 @printf(ptr nocapture noundef readonly, ...) local_unnamed_addr #2

attributes #0 = { nofree nounwind uwtable "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #1 = { mustprogress nocallback nofree nosync nounwind willreturn memory(argmem: readwrite) }
attributes #2 = { nofree nounwind "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #3 = { nounwind }

!llvm.module.flags = !{!0, !1, !2, !3}
!llvm.ident = !{!4}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{i32 8, !"PIC Level", i32 2}
!2 = !{i32 7, !"PIE Level", i32 2}
!3 = !{i32 7, !"uwtable", i32 2}
!4 = !{!"Ubuntu clang version 18.1.3 (1ubuntu1)"}
!5 = !{!6, !6, i64 0}
!6 = !{!"int", !7, i64 0}
!7 = !{!"omnipotent char", !8, i64 0}
!8 = !{!"Simple C/C++ TBAA"}
!9 = distinct !{!9, !10}
!10 = !{!"llvm.loop.mustprogress"}
; *** IR Dump After CoroCleanupPass on [module] ***
; ModuleID = 'main.c'
source_filename = "main.c"
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128"
target triple = "x86_64-pc-linux-gnu"

@.str = private unnamed_addr constant [3 x i8] c"%d\00", align 1
@.str.1 = private unnamed_addr constant [6 x i8] c"%llu\0A\00", align 1

; Function Attrs: nofree nounwind uwtable
define dso_local noundef i32 @main() local_unnamed_addr #0 {
  %1 = alloca i32, align 4
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %1) #3
  %2 = call i32 (ptr, ...) @__isoc99_scanf(ptr noundef nonnull @.str, ptr noundef nonnull %1)
  %3 = load i32, ptr %1, align 4, !tbaa !5
  %4 = icmp slt i32 %3, 1
  br i1 %4, label %8, label %5

5:                                                ; preds = %0
  %6 = add nuw i32 %3, 1
  %7 = zext i32 %6 to i64
  br label %11

8:                                                ; preds = %11, %0
  %9 = phi i64 [ 1, %0 ], [ %14, %11 ]
  %10 = call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.1, i64 noundef %9)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %1) #3
  ret i32 0

11:                                               ; preds = %5, %11
  %12 = phi i64 [ 1, %5 ], [ %15, %11 ]
  %13 = phi i64 [ 1, %5 ], [ %14, %11 ]
  %14 = mul i64 %13, %12
  %15 = add nuw nsw i64 %12, 1
  %16 = icmp eq i64 %15, %7
  br i1 %16, label %8, label %11, !llvm.loop !9
}

; Function Attrs: mustprogress nocallback nofree nosync nounwind willreturn memory(argmem: readwrite)
declare void @llvm.lifetime.start.p0(i64 immarg, ptr nocapture) #1

; Function Attrs: nofree nounwind
declare noundef i32 @__isoc99_scanf(ptr nocapture noundef readonly, ...) local_unnamed_addr #2

; Function Attrs: mustprogress nocallback nofree nosync nounwind willreturn memory(argmem: readwrite)
declare void @llvm.lifetime.end.p0(i64 immarg, ptr nocapture) #1

; Function Attrs: nofree nounwind
declare noundef i32 @printf(ptr nocapture noundef readonly, ...) local_unnamed_addr #2

attributes #0 = { nofree nounwind uwtable "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #1 = { mustprogress nocallback nofree nosync nounwind willreturn memory(argmem: readwrite) }
attributes #2 = { nofree nounwind "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #3 = { nounwind }

!llvm.module.flags = !{!0, !1, !2, !3}
!llvm.ident = !{!4}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{i32 8, !"PIC Level", i32 2}
!2 = !{i32 7, !"PIE Level", i32 2}
!3 = !{i32 7, !"uwtable", i32 2}
!4 = !{!"Ubuntu clang version 18.1.3 (1ubuntu1)"}
!5 = !{!6, !6, i64 0}
!6 = !{!"int", !7, i64 0}
!7 = !{!"omnipotent char", !8, i64 0}
!8 = !{!"Simple C/C++ TBAA"}
!9 = distinct !{!9, !10}
!10 = !{!"llvm.loop.mustprogress"}
; *** IR Dump After GlobalOptPass on [module] ***
; ModuleID = 'main.c'
source_filename = "main.c"
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128"
target triple = "x86_64-pc-linux-gnu"

@.str = private unnamed_addr constant [3 x i8] c"%d\00", align 1
@.str.1 = private unnamed_addr constant [6 x i8] c"%llu\0A\00", align 1

; Function Attrs: nofree nounwind uwtable
define dso_local noundef i32 @main() local_unnamed_addr #0 {
  %1 = alloca i32, align 4
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %1) #3
  %2 = call i32 (ptr, ...) @__isoc99_scanf(ptr noundef nonnull @.str, ptr noundef nonnull %1)
  %3 = load i32, ptr %1, align 4, !tbaa !5
  %4 = icmp slt i32 %3, 1
  br i1 %4, label %8, label %5

5:                                                ; preds = %0
  %6 = add nuw i32 %3, 1
  %7 = zext i32 %6 to i64
  br label %11

8:                                                ; preds = %11, %0
  %9 = phi i64 [ 1, %0 ], [ %14, %11 ]
  %10 = call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.1, i64 noundef %9)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %1) #3
  ret i32 0

11:                                               ; preds = %5, %11
  %12 = phi i64 [ 1, %5 ], [ %15, %11 ]
  %13 = phi i64 [ 1, %5 ], [ %14, %11 ]
  %14 = mul i64 %13, %12
  %15 = add nuw nsw i64 %12, 1
  %16 = icmp eq i64 %15, %7
  br i1 %16, label %8, label %11, !llvm.loop !9
}

; Function Attrs: mustprogress nocallback nofree nosync nounwind willreturn memory(argmem: readwrite)
declare void @llvm.lifetime.start.p0(i64 immarg, ptr nocapture) #1

; Function Attrs: nofree nounwind
declare noundef i32 @__isoc99_scanf(ptr nocapture noundef readonly, ...) local_unnamed_addr #2

; Function Attrs: mustprogress nocallback nofree nosync nounwind willreturn memory(argmem: readwrite)
declare void @llvm.lifetime.end.p0(i64 immarg, ptr nocapture) #1

; Function Attrs: nofree nounwind
declare noundef i32 @printf(ptr nocapture noundef readonly, ...) local_unnamed_addr #2

attributes #0 = { nofree nounwind uwtable "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #1 = { mustprogress nocallback nofree nosync nounwind willreturn memory(argmem: readwrite) }
attributes #2 = { nofree nounwind "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #3 = { nounwind }

!llvm.module.flags = !{!0, !1, !2, !3}
!llvm.ident = !{!4}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{i32 8, !"PIC Level", i32 2}
!2 = !{i32 7, !"PIE Level", i32 2}
!3 = !{i32 7, !"uwtable", i32 2}
!4 = !{!"Ubuntu clang version 18.1.3 (1ubuntu1)"}
!5 = !{!6, !6, i64 0}
!6 = !{!"int", !7, i64 0}
!7 = !{!"omnipotent char", !8, i64 0}
!8 = !{!"Simple C/C++ TBAA"}
!9 = distinct !{!9, !10}
!10 = !{!"llvm.loop.mustprogress"}
; *** IR Dump After GlobalDCEPass on [module] ***
; ModuleID = 'main.c'
source_filename = "main.c"
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128"
target triple = "x86_64-pc-linux-gnu"

@.str = private unnamed_addr constant [3 x i8] c"%d\00", align 1
@.str.1 = private unnamed_addr constant [6 x i8] c"%llu\0A\00", align 1

; Function Attrs: nofree nounwind uwtable
define dso_local noundef i32 @main() local_unnamed_addr #0 {
  %1 = alloca i32, align 4
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %1) #3
  %2 = call i32 (ptr, ...) @__isoc99_scanf(ptr noundef nonnull @.str, ptr noundef nonnull %1)
  %3 = load i32, ptr %1, align 4, !tbaa !5
  %4 = icmp slt i32 %3, 1
  br i1 %4, label %8, label %5

5:                                                ; preds = %0
  %6 = add nuw i32 %3, 1
  %7 = zext i32 %6 to i64
  br label %11

8:                                                ; preds = %11, %0
  %9 = phi i64 [ 1, %0 ], [ %14, %11 ]
  %10 = call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.1, i64 noundef %9)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %1) #3
  ret i32 0

11:                                               ; preds = %5, %11
  %12 = phi i64 [ 1, %5 ], [ %15, %11 ]
  %13 = phi i64 [ 1, %5 ], [ %14, %11 ]
  %14 = mul i64 %13, %12
  %15 = add nuw nsw i64 %12, 1
  %16 = icmp eq i64 %15, %7
  br i1 %16, label %8, label %11, !llvm.loop !9
}

; Function Attrs: mustprogress nocallback nofree nosync nounwind willreturn memory(argmem: readwrite)
declare void @llvm.lifetime.start.p0(i64 immarg, ptr nocapture) #1

; Function Attrs: nofree nounwind
declare noundef i32 @__isoc99_scanf(ptr nocapture noundef readonly, ...) local_unnamed_addr #2

; Function Attrs: mustprogress nocallback nofree nosync nounwind willreturn memory(argmem: readwrite)
declare void @llvm.lifetime.end.p0(i64 immarg, ptr nocapture) #1

; Function Attrs: nofree nounwind
declare noundef i32 @printf(ptr nocapture noundef readonly, ...) local_unnamed_addr #2

attributes #0 = { nofree nounwind uwtable "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #1 = { mustprogress nocallback nofree nosync nounwind willreturn memory(argmem: readwrite) }
attributes #2 = { nofree nounwind "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #3 = { nounwind }

!llvm.module.flags = !{!0, !1, !2, !3}
!llvm.ident = !{!4}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{i32 8, !"PIC Level", i32 2}
!2 = !{i32 7, !"PIE Level", i32 2}
!3 = !{i32 7, !"uwtable", i32 2}
!4 = !{!"Ubuntu clang version 18.1.3 (1ubuntu1)"}
!5 = !{!6, !6, i64 0}
!6 = !{!"int", !7, i64 0}
!7 = !{!"omnipotent char", !8, i64 0}
!8 = !{!"Simple C/C++ TBAA"}
!9 = distinct !{!9, !10}
!10 = !{!"llvm.loop.mustprogress"}
; *** IR Dump After EliminateAvailableExternallyPass on [module] ***
; ModuleID = 'main.c'
source_filename = "main.c"
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128"
target triple = "x86_64-pc-linux-gnu"

@.str = private unnamed_addr constant [3 x i8] c"%d\00", align 1
@.str.1 = private unnamed_addr constant [6 x i8] c"%llu\0A\00", align 1

; Function Attrs: nofree nounwind uwtable
define dso_local noundef i32 @main() local_unnamed_addr #0 {
  %1 = alloca i32, align 4
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %1) #3
  %2 = call i32 (ptr, ...) @__isoc99_scanf(ptr noundef nonnull @.str, ptr noundef nonnull %1)
  %3 = load i32, ptr %1, align 4, !tbaa !5
  %4 = icmp slt i32 %3, 1
  br i1 %4, label %8, label %5

5:                                                ; preds = %0
  %6 = add nuw i32 %3, 1
  %7 = zext i32 %6 to i64
  br label %11

8:                                                ; preds = %11, %0
  %9 = phi i64 [ 1, %0 ], [ %14, %11 ]
  %10 = call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.1, i64 noundef %9)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %1) #3
  ret i32 0

11:                                               ; preds = %5, %11
  %12 = phi i64 [ 1, %5 ], [ %15, %11 ]
  %13 = phi i64 [ 1, %5 ], [ %14, %11 ]
  %14 = mul i64 %13, %12
  %15 = add nuw nsw i64 %12, 1
  %16 = icmp eq i64 %15, %7
  br i1 %16, label %8, label %11, !llvm.loop !9
}

; Function Attrs: mustprogress nocallback nofree nosync nounwind willreturn memory(argmem: readwrite)
declare void @llvm.lifetime.start.p0(i64 immarg, ptr nocapture) #1

; Function Attrs: nofree nounwind
declare noundef i32 @__isoc99_scanf(ptr nocapture noundef readonly, ...) local_unnamed_addr #2

; Function Attrs: mustprogress nocallback nofree nosync nounwind willreturn memory(argmem: readwrite)
declare void @llvm.lifetime.end.p0(i64 immarg, ptr nocapture) #1

; Function Attrs: nofree nounwind
declare noundef i32 @printf(ptr nocapture noundef readonly, ...) local_unnamed_addr #2

attributes #0 = { nofree nounwind uwtable "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #1 = { mustprogress nocallback nofree nosync nounwind willreturn memory(argmem: readwrite) }
attributes #2 = { nofree nounwind "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #3 = { nounwind }

!llvm.module.flags = !{!0, !1, !2, !3}
!llvm.ident = !{!4}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{i32 8, !"PIC Level", i32 2}
!2 = !{i32 7, !"PIE Level", i32 2}
!3 = !{i32 7, !"uwtable", i32 2}
!4 = !{!"Ubuntu clang version 18.1.3 (1ubuntu1)"}
!5 = !{!6, !6, i64 0}
!6 = !{!"int", !7, i64 0}
!7 = !{!"omnipotent char", !8, i64 0}
!8 = !{!"Simple C/C++ TBAA"}
!9 = distinct !{!9, !10}
!10 = !{!"llvm.loop.mustprogress"}
; *** IR Dump After ReversePostOrderFunctionAttrsPass on [module] ***
; ModuleID = 'main.c'
source_filename = "main.c"
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128"
target triple = "x86_64-pc-linux-gnu"

@.str = private unnamed_addr constant [3 x i8] c"%d\00", align 1
@.str.1 = private unnamed_addr constant [6 x i8] c"%llu\0A\00", align 1

; Function Attrs: nofree nounwind uwtable
define dso_local noundef i32 @main() local_unnamed_addr #0 {
  %1 = alloca i32, align 4
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %1) #3
  %2 = call i32 (ptr, ...) @__isoc99_scanf(ptr noundef nonnull @.str, ptr noundef nonnull %1)
  %3 = load i32, ptr %1, align 4, !tbaa !5
  %4 = icmp slt i32 %3, 1
  br i1 %4, label %8, label %5

5:                                                ; preds = %0
  %6 = add nuw i32 %3, 1
  %7 = zext i32 %6 to i64
  br label %11

8:                                                ; preds = %11, %0
  %9 = phi i64 [ 1, %0 ], [ %14, %11 ]
  %10 = call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.1, i64 noundef %9)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %1) #3
  ret i32 0

11:                                               ; preds = %5, %11
  %12 = phi i64 [ 1, %5 ], [ %15, %11 ]
  %13 = phi i64 [ 1, %5 ], [ %14, %11 ]
  %14 = mul i64 %13, %12
  %15 = add nuw nsw i64 %12, 1
  %16 = icmp eq i64 %15, %7
  br i1 %16, label %8, label %11, !llvm.loop !9
}

; Function Attrs: mustprogress nocallback nofree nosync nounwind willreturn memory(argmem: readwrite)
declare void @llvm.lifetime.start.p0(i64 immarg, ptr nocapture) #1

; Function Attrs: nofree nounwind
declare noundef i32 @__isoc99_scanf(ptr nocapture noundef readonly, ...) local_unnamed_addr #2

; Function Attrs: mustprogress nocallback nofree nosync nounwind willreturn memory(argmem: readwrite)
declare void @llvm.lifetime.end.p0(i64 immarg, ptr nocapture) #1

; Function Attrs: nofree nounwind
declare noundef i32 @printf(ptr nocapture noundef readonly, ...) local_unnamed_addr #2

attributes #0 = { nofree nounwind uwtable "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #1 = { mustprogress nocallback nofree nosync nounwind willreturn memory(argmem: readwrite) }
attributes #2 = { nofree nounwind "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #3 = { nounwind }

!llvm.module.flags = !{!0, !1, !2, !3}
!llvm.ident = !{!4}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{i32 8, !"PIC Level", i32 2}
!2 = !{i32 7, !"PIE Level", i32 2}
!3 = !{i32 7, !"uwtable", i32 2}
!4 = !{!"Ubuntu clang version 18.1.3 (1ubuntu1)"}
!5 = !{!6, !6, i64 0}
!6 = !{!"int", !7, i64 0}
!7 = !{!"omnipotent char", !8, i64 0}
!8 = !{!"Simple C/C++ TBAA"}
!9 = distinct !{!9, !10}
!10 = !{!"llvm.loop.mustprogress"}
; *** IR Dump After RecomputeGlobalsAAPass on [module] ***
; ModuleID = 'main.c'
source_filename = "main.c"
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128"
target triple = "x86_64-pc-linux-gnu"

@.str = private unnamed_addr constant [3 x i8] c"%d\00", align 1
@.str.1 = private unnamed_addr constant [6 x i8] c"%llu\0A\00", align 1

; Function Attrs: nofree nounwind uwtable
define dso_local noundef i32 @main() local_unnamed_addr #0 {
  %1 = alloca i32, align 4
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %1) #3
  %2 = call i32 (ptr, ...) @__isoc99_scanf(ptr noundef nonnull @.str, ptr noundef nonnull %1)
  %3 = load i32, ptr %1, align 4, !tbaa !5
  %4 = icmp slt i32 %3, 1
  br i1 %4, label %8, label %5

5:                                                ; preds = %0
  %6 = add nuw i32 %3, 1
  %7 = zext i32 %6 to i64
  br label %11

8:                                                ; preds = %11, %0
  %9 = phi i64 [ 1, %0 ], [ %14, %11 ]
  %10 = call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.1, i64 noundef %9)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %1) #3
  ret i32 0

11:                                               ; preds = %5, %11
  %12 = phi i64 [ 1, %5 ], [ %15, %11 ]
  %13 = phi i64 [ 1, %5 ], [ %14, %11 ]
  %14 = mul i64 %13, %12
  %15 = add nuw nsw i64 %12, 1
  %16 = icmp eq i64 %15, %7
  br i1 %16, label %8, label %11, !llvm.loop !9
}

; Function Attrs: mustprogress nocallback nofree nosync nounwind willreturn memory(argmem: readwrite)
declare void @llvm.lifetime.start.p0(i64 immarg, ptr nocapture) #1

; Function Attrs: nofree nounwind
declare noundef i32 @__isoc99_scanf(ptr nocapture noundef readonly, ...) local_unnamed_addr #2

; Function Attrs: mustprogress nocallback nofree nosync nounwind willreturn memory(argmem: readwrite)
declare void @llvm.lifetime.end.p0(i64 immarg, ptr nocapture) #1

; Function Attrs: nofree nounwind
declare noundef i32 @printf(ptr nocapture noundef readonly, ...) local_unnamed_addr #2

attributes #0 = { nofree nounwind uwtable "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #1 = { mustprogress nocallback nofree nosync nounwind willreturn memory(argmem: readwrite) }
attributes #2 = { nofree nounwind "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #3 = { nounwind }

!llvm.module.flags = !{!0, !1, !2, !3}
!llvm.ident = !{!4}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{i32 8, !"PIC Level", i32 2}
!2 = !{i32 7, !"PIE Level", i32 2}
!3 = !{i32 7, !"uwtable", i32 2}
!4 = !{!"Ubuntu clang version 18.1.3 (1ubuntu1)"}
!5 = !{!6, !6, i64 0}
!6 = !{!"int", !7, i64 0}
!7 = !{!"omnipotent char", !8, i64 0}
!8 = !{!"Simple C/C++ TBAA"}
!9 = distinct !{!9, !10}
!10 = !{!"llvm.loop.mustprogress"}
; *** IR Dump After Float2IntPass on main ***
; Function Attrs: nofree nounwind uwtable
define dso_local noundef i32 @main() local_unnamed_addr #0 {
  %1 = alloca i32, align 4
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %1) #3
  %2 = call i32 (ptr, ...) @__isoc99_scanf(ptr noundef nonnull @.str, ptr noundef nonnull %1)
  %3 = load i32, ptr %1, align 4, !tbaa !5
  %4 = icmp slt i32 %3, 1
  br i1 %4, label %8, label %5

5:                                                ; preds = %0
  %6 = add nuw i32 %3, 1
  %7 = zext i32 %6 to i64
  br label %11

8:                                                ; preds = %11, %0
  %9 = phi i64 [ 1, %0 ], [ %14, %11 ]
  %10 = call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.1, i64 noundef %9)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %1) #3
  ret i32 0

11:                                               ; preds = %5, %11
  %12 = phi i64 [ 1, %5 ], [ %15, %11 ]
  %13 = phi i64 [ 1, %5 ], [ %14, %11 ]
  %14 = mul i64 %13, %12
  %15 = add nuw nsw i64 %12, 1
  %16 = icmp eq i64 %15, %7
  br i1 %16, label %8, label %11, !llvm.loop !9
}
; *** IR Dump After LowerConstantIntrinsicsPass on main ***
; Function Attrs: nofree nounwind uwtable
define dso_local noundef i32 @main() local_unnamed_addr #0 {
  %1 = alloca i32, align 4
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %1) #3
  %2 = call i32 (ptr, ...) @__isoc99_scanf(ptr noundef nonnull @.str, ptr noundef nonnull %1)
  %3 = load i32, ptr %1, align 4, !tbaa !5
  %4 = icmp slt i32 %3, 1
  br i1 %4, label %8, label %5

5:                                                ; preds = %0
  %6 = add nuw i32 %3, 1
  %7 = zext i32 %6 to i64
  br label %11

8:                                                ; preds = %11, %0
  %9 = phi i64 [ 1, %0 ], [ %14, %11 ]
  %10 = call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.1, i64 noundef %9)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %1) #3
  ret i32 0

11:                                               ; preds = %5, %11
  %12 = phi i64 [ 1, %5 ], [ %15, %11 ]
  %13 = phi i64 [ 1, %5 ], [ %14, %11 ]
  %14 = mul i64 %13, %12
  %15 = add nuw nsw i64 %12, 1
  %16 = icmp eq i64 %15, %7
  br i1 %16, label %8, label %11, !llvm.loop !9
}
; *** IR Dump After LoopSimplifyPass on main ***
; Function Attrs: nofree nounwind uwtable
define dso_local noundef i32 @main() local_unnamed_addr #0 {
  %1 = alloca i32, align 4
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %1) #3
  %2 = call i32 (ptr, ...) @__isoc99_scanf(ptr noundef nonnull @.str, ptr noundef nonnull %1)
  %3 = load i32, ptr %1, align 4, !tbaa !5
  %4 = icmp slt i32 %3, 1
  br i1 %4, label %9, label %5

5:                                                ; preds = %0
  %6 = add nuw i32 %3, 1
  %7 = zext i32 %6 to i64
  br label %12

8:                                                ; preds = %12
  br label %9

9:                                                ; preds = %8, %0
  %10 = phi i64 [ 1, %0 ], [ %15, %8 ]
  %11 = call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.1, i64 noundef %10)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %1) #3
  ret i32 0

12:                                               ; preds = %5, %12
  %13 = phi i64 [ 1, %5 ], [ %16, %12 ]
  %14 = phi i64 [ 1, %5 ], [ %15, %12 ]
  %15 = mul i64 %14, %13
  %16 = add nuw nsw i64 %13, 1
  %17 = icmp eq i64 %16, %7
  br i1 %17, label %8, label %12, !llvm.loop !9
}
; *** IR Dump After LCSSAPass on main ***
; Function Attrs: nofree nounwind uwtable
define dso_local noundef i32 @main() local_unnamed_addr #0 {
  %1 = alloca i32, align 4
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %1) #3
  %2 = call i32 (ptr, ...) @__isoc99_scanf(ptr noundef nonnull @.str, ptr noundef nonnull %1)
  %3 = load i32, ptr %1, align 4, !tbaa !5
  %4 = icmp slt i32 %3, 1
  br i1 %4, label %10, label %5

5:                                                ; preds = %0
  %6 = add nuw i32 %3, 1
  %7 = zext i32 %6 to i64
  br label %13

8:                                                ; preds = %13
  %9 = phi i64 [ %16, %13 ]
  br label %10

10:                                               ; preds = %8, %0
  %11 = phi i64 [ 1, %0 ], [ %9, %8 ]
  %12 = call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.1, i64 noundef %11)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %1) #3
  ret i32 0

13:                                               ; preds = %5, %13
  %14 = phi i64 [ 1, %5 ], [ %17, %13 ]
  %15 = phi i64 [ 1, %5 ], [ %16, %13 ]
  %16 = mul i64 %15, %14
  %17 = add nuw nsw i64 %14, 1
  %18 = icmp eq i64 %17, %7
  br i1 %18, label %8, label %13, !llvm.loop !9
}
; *** IR Dump After LoopRotatePass on <unnamed loop> ***

; Preheader:
5:                                                ; preds = %0
  %6 = add nuw i32 %3, 1
  %7 = zext i32 %6 to i64
  br label %13

; Loop:
13:                                               ; preds = %5, %13
  %14 = phi i64 [ 1, %5 ], [ %17, %13 ]
  %15 = phi i64 [ 1, %5 ], [ %16, %13 ]
  %16 = mul i64 %15, %14
  %17 = add nuw nsw i64 %14, 1
  %18 = icmp eq i64 %17, %7
  br i1 %18, label %8, label %13, !llvm.loop !9

; Exit blocks
8:                                                ; preds = %13
  %9 = phi i64 [ %16, %13 ]
  br label %10
; *** IR Dump After LoopDeletionPass on <unnamed loop> ***

; Preheader:
5:                                                ; preds = %0
  %6 = add nuw i32 %3, 1
  %7 = zext i32 %6 to i64
  br label %13

; Loop:
13:                                               ; preds = %5, %13
  %14 = phi i64 [ 1, %5 ], [ %17, %13 ]
  %15 = phi i64 [ 1, %5 ], [ %16, %13 ]
  %16 = mul i64 %15, %14
  %17 = add nuw nsw i64 %14, 1
  %18 = icmp eq i64 %17, %7
  br i1 %18, label %8, label %13, !llvm.loop !9

; Exit blocks
8:                                                ; preds = %13
  %9 = phi i64 [ %16, %13 ]
  br label %10
; *** IR Dump After LoopDistributePass on main ***
; Function Attrs: nofree nounwind uwtable
define dso_local noundef i32 @main() local_unnamed_addr #0 {
  %1 = alloca i32, align 4
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %1) #3
  %2 = call i32 (ptr, ...) @__isoc99_scanf(ptr noundef nonnull @.str, ptr noundef nonnull %1)
  %3 = load i32, ptr %1, align 4, !tbaa !5
  %4 = icmp slt i32 %3, 1
  br i1 %4, label %10, label %5

5:                                                ; preds = %0
  %6 = add nuw i32 %3, 1
  %7 = zext i32 %6 to i64
  br label %13

8:                                                ; preds = %13
  %9 = phi i64 [ %16, %13 ]
  br label %10

10:                                               ; preds = %8, %0
  %11 = phi i64 [ 1, %0 ], [ %9, %8 ]
  %12 = call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.1, i64 noundef %11)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %1) #3
  ret i32 0

13:                                               ; preds = %5, %13
  %14 = phi i64 [ 1, %5 ], [ %17, %13 ]
  %15 = phi i64 [ 1, %5 ], [ %16, %13 ]
  %16 = mul i64 %15, %14
  %17 = add nuw nsw i64 %14, 1
  %18 = icmp eq i64 %17, %7
  br i1 %18, label %8, label %13, !llvm.loop !9
}
; *** IR Dump After InjectTLIMappings on main ***
; Function Attrs: nofree nounwind uwtable
define dso_local noundef i32 @main() local_unnamed_addr #0 {
  %1 = alloca i32, align 4
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %1) #3
  %2 = call i32 (ptr, ...) @__isoc99_scanf(ptr noundef nonnull @.str, ptr noundef nonnull %1)
  %3 = load i32, ptr %1, align 4, !tbaa !5
  %4 = icmp slt i32 %3, 1
  br i1 %4, label %10, label %5

5:                                                ; preds = %0
  %6 = add nuw i32 %3, 1
  %7 = zext i32 %6 to i64
  br label %13

8:                                                ; preds = %13
  %9 = phi i64 [ %16, %13 ]
  br label %10

10:                                               ; preds = %8, %0
  %11 = phi i64 [ 1, %0 ], [ %9, %8 ]
  %12 = call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.1, i64 noundef %11)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %1) #3
  ret i32 0

13:                                               ; preds = %5, %13
  %14 = phi i64 [ 1, %5 ], [ %17, %13 ]
  %15 = phi i64 [ 1, %5 ], [ %16, %13 ]
  %16 = mul i64 %15, %14
  %17 = add nuw nsw i64 %14, 1
  %18 = icmp eq i64 %17, %7
  br i1 %18, label %8, label %13, !llvm.loop !9
}
; *** IR Dump After LoopVectorizePass on main ***
; Function Attrs: nofree nounwind uwtable
define dso_local noundef i32 @main() local_unnamed_addr #0 {
  %1 = alloca i32, align 4
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %1) #3
  %2 = call i32 (ptr, ...) @__isoc99_scanf(ptr noundef nonnull @.str, ptr noundef nonnull %1)
  %3 = load i32, ptr %1, align 4, !tbaa !5
  %4 = icmp slt i32 %3, 1
  br i1 %4, label %10, label %5

5:                                                ; preds = %0
  %6 = add nuw i32 %3, 1
  %7 = zext i32 %6 to i64
  br label %13

8:                                                ; preds = %13
  %9 = phi i64 [ %16, %13 ]
  br label %10

10:                                               ; preds = %8, %0
  %11 = phi i64 [ 1, %0 ], [ %9, %8 ]
  %12 = call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.1, i64 noundef %11)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %1) #3
  ret i32 0

13:                                               ; preds = %5, %13
  %14 = phi i64 [ 1, %5 ], [ %17, %13 ]
  %15 = phi i64 [ 1, %5 ], [ %16, %13 ]
  %16 = mul i64 %15, %14
  %17 = add nuw nsw i64 %14, 1
  %18 = icmp eq i64 %17, %7
  br i1 %18, label %8, label %13, !llvm.loop !9
}
; *** IR Dump After InferAlignmentPass on main ***
; Function Attrs: nofree nounwind uwtable
define dso_local noundef i32 @main() local_unnamed_addr #0 {
  %1 = alloca i32, align 4
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %1) #3
  %2 = call i32 (ptr, ...) @__isoc99_scanf(ptr noundef nonnull @.str, ptr noundef nonnull %1)
  %3 = load i32, ptr %1, align 4, !tbaa !5
  %4 = icmp slt i32 %3, 1
  br i1 %4, label %10, label %5

5:                                                ; preds = %0
  %6 = add nuw i32 %3, 1
  %7 = zext i32 %6 to i64
  br label %13

8:                                                ; preds = %13
  %9 = phi i64 [ %16, %13 ]
  br label %10

10:                                               ; preds = %8, %0
  %11 = phi i64 [ 1, %0 ], [ %9, %8 ]
  %12 = call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.1, i64 noundef %11)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %1) #3
  ret i32 0

13:                                               ; preds = %5, %13
  %14 = phi i64 [ 1, %5 ], [ %17, %13 ]
  %15 = phi i64 [ 1, %5 ], [ %16, %13 ]
  %16 = mul i64 %15, %14
  %17 = add nuw nsw i64 %14, 1
  %18 = icmp eq i64 %17, %7
  br i1 %18, label %8, label %13, !llvm.loop !9
}
; *** IR Dump After LoopLoadEliminationPass on main ***
; Function Attrs: nofree nounwind uwtable
define dso_local noundef i32 @main() local_unnamed_addr #0 {
  %1 = alloca i32, align 4
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %1) #3
  %2 = call i32 (ptr, ...) @__isoc99_scanf(ptr noundef nonnull @.str, ptr noundef nonnull %1)
  %3 = load i32, ptr %1, align 4, !tbaa !5
  %4 = icmp slt i32 %3, 1
  br i1 %4, label %10, label %5

5:                                                ; preds = %0
  %6 = add nuw i32 %3, 1
  %7 = zext i32 %6 to i64
  br label %13

8:                                                ; preds = %13
  %9 = phi i64 [ %16, %13 ]
  br label %10

10:                                               ; preds = %8, %0
  %11 = phi i64 [ 1, %0 ], [ %9, %8 ]
  %12 = call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.1, i64 noundef %11)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %1) #3
  ret i32 0

13:                                               ; preds = %5, %13
  %14 = phi i64 [ 1, %5 ], [ %17, %13 ]
  %15 = phi i64 [ 1, %5 ], [ %16, %13 ]
  %16 = mul i64 %15, %14
  %17 = add nuw nsw i64 %14, 1
  %18 = icmp eq i64 %17, %7
  br i1 %18, label %8, label %13, !llvm.loop !9
}
; *** IR Dump After InstCombinePass on main ***
; Function Attrs: nofree nounwind uwtable
define dso_local noundef i32 @main() local_unnamed_addr #0 {
  %1 = alloca i32, align 4
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %1) #3
  %2 = call i32 (ptr, ...) @__isoc99_scanf(ptr noundef nonnull @.str, ptr noundef nonnull %1)
  %3 = load i32, ptr %1, align 4, !tbaa !5
  %4 = icmp slt i32 %3, 1
  br i1 %4, label %9, label %5

5:                                                ; preds = %0
  %6 = add nuw i32 %3, 1
  %7 = zext i32 %6 to i64
  br label %12

8:                                                ; preds = %12
  br label %9

9:                                                ; preds = %8, %0
  %10 = phi i64 [ 1, %0 ], [ %15, %8 ]
  %11 = call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.1, i64 noundef %10)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %1) #3
  ret i32 0

12:                                               ; preds = %5, %12
  %13 = phi i64 [ 1, %5 ], [ %16, %12 ]
  %14 = phi i64 [ 1, %5 ], [ %15, %12 ]
  %15 = mul i64 %14, %13
  %16 = add nuw nsw i64 %13, 1
  %17 = icmp eq i64 %16, %7
  br i1 %17, label %8, label %12, !llvm.loop !9
}
; *** IR Dump After SimplifyCFGPass on main ***
; Function Attrs: nofree nounwind uwtable
define dso_local noundef i32 @main() local_unnamed_addr #0 {
  %1 = alloca i32, align 4
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %1) #3
  %2 = call i32 (ptr, ...) @__isoc99_scanf(ptr noundef nonnull @.str, ptr noundef nonnull %1)
  %3 = load i32, ptr %1, align 4, !tbaa !5
  %4 = icmp slt i32 %3, 1
  br i1 %4, label %8, label %5

5:                                                ; preds = %0
  %6 = add nuw i32 %3, 1
  %7 = zext i32 %6 to i64
  br label %11

8:                                                ; preds = %11, %0
  %9 = phi i64 [ 1, %0 ], [ %14, %11 ]
  %10 = call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.1, i64 noundef %9)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %1) #3
  ret i32 0

11:                                               ; preds = %5, %11
  %12 = phi i64 [ 1, %5 ], [ %15, %11 ]
  %13 = phi i64 [ 1, %5 ], [ %14, %11 ]
  %14 = mul i64 %13, %12
  %15 = add nuw nsw i64 %12, 1
  %16 = icmp eq i64 %15, %7
  br i1 %16, label %8, label %11, !llvm.loop !9
}
; *** IR Dump After SLPVectorizerPass on main ***
; Function Attrs: nofree nounwind uwtable
define dso_local noundef i32 @main() local_unnamed_addr #0 {
  %1 = alloca i32, align 4
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %1) #3
  %2 = call i32 (ptr, ...) @__isoc99_scanf(ptr noundef nonnull @.str, ptr noundef nonnull %1)
  %3 = load i32, ptr %1, align 4, !tbaa !5
  %4 = icmp slt i32 %3, 1
  br i1 %4, label %8, label %5

5:                                                ; preds = %0
  %6 = add nuw i32 %3, 1
  %7 = zext i32 %6 to i64
  br label %11

8:                                                ; preds = %11, %0
  %9 = phi i64 [ 1, %0 ], [ %14, %11 ]
  %10 = call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.1, i64 noundef %9)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %1) #3
  ret i32 0

11:                                               ; preds = %5, %11
  %12 = phi i64 [ 1, %5 ], [ %15, %11 ]
  %13 = phi i64 [ 1, %5 ], [ %14, %11 ]
  %14 = mul i64 %13, %12
  %15 = add nuw nsw i64 %12, 1
  %16 = icmp eq i64 %15, %7
  br i1 %16, label %8, label %11, !llvm.loop !9
}
; *** IR Dump After VectorCombinePass on main ***
; Function Attrs: nofree nounwind uwtable
define dso_local noundef i32 @main() local_unnamed_addr #0 {
  %1 = alloca i32, align 4
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %1) #3
  %2 = call i32 (ptr, ...) @__isoc99_scanf(ptr noundef nonnull @.str, ptr noundef nonnull %1)
  %3 = load i32, ptr %1, align 4, !tbaa !5
  %4 = icmp slt i32 %3, 1
  br i1 %4, label %8, label %5

5:                                                ; preds = %0
  %6 = add nuw i32 %3, 1
  %7 = zext i32 %6 to i64
  br label %11

8:                                                ; preds = %11, %0
  %9 = phi i64 [ 1, %0 ], [ %14, %11 ]
  %10 = call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.1, i64 noundef %9)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %1) #3
  ret i32 0

11:                                               ; preds = %5, %11
  %12 = phi i64 [ 1, %5 ], [ %15, %11 ]
  %13 = phi i64 [ 1, %5 ], [ %14, %11 ]
  %14 = mul i64 %13, %12
  %15 = add nuw nsw i64 %12, 1
  %16 = icmp eq i64 %15, %7
  br i1 %16, label %8, label %11, !llvm.loop !9
}
; *** IR Dump After InstCombinePass on main ***
; Function Attrs: nofree nounwind uwtable
define dso_local noundef i32 @main() local_unnamed_addr #0 {
  %1 = alloca i32, align 4
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %1) #3
  %2 = call i32 (ptr, ...) @__isoc99_scanf(ptr noundef nonnull @.str, ptr noundef nonnull %1)
  %3 = load i32, ptr %1, align 4, !tbaa !5
  %4 = icmp slt i32 %3, 1
  br i1 %4, label %8, label %5

5:                                                ; preds = %0
  %6 = add nuw i32 %3, 1
  %7 = zext i32 %6 to i64
  br label %11

8:                                                ; preds = %11, %0
  %9 = phi i64 [ 1, %0 ], [ %14, %11 ]
  %10 = call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.1, i64 noundef %9)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %1) #3
  ret i32 0

11:                                               ; preds = %5, %11
  %12 = phi i64 [ 1, %5 ], [ %15, %11 ]
  %13 = phi i64 [ 1, %5 ], [ %14, %11 ]
  %14 = mul i64 %13, %12
  %15 = add nuw nsw i64 %12, 1
  %16 = icmp eq i64 %15, %7
  br i1 %16, label %8, label %11, !llvm.loop !9
}
; *** IR Dump After LoopUnrollPass on main ***
; Function Attrs: nofree nounwind uwtable
define dso_local noundef i32 @main() local_unnamed_addr #0 {
  %1 = alloca i32, align 4
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %1) #3
  %2 = call i32 (ptr, ...) @__isoc99_scanf(ptr noundef nonnull @.str, ptr noundef nonnull %1)
  %3 = load i32, ptr %1, align 4, !tbaa !5
  %4 = icmp slt i32 %3, 1
  br i1 %4, label %37, label %5

5:                                                ; preds = %0
  %6 = add nuw i32 %3, 1
  %7 = zext i32 %6 to i64
  %8 = add nsw i64 %7, -1
  %9 = add nsw i64 %7, -2
  %10 = and i64 %8, 7
  %11 = icmp ult i64 %9, 7
  br i1 %11, label %18, label %12

12:                                               ; preds = %5
  %13 = sub i64 %8, %10
  br label %40

14:                                               ; preds = %40
  %15 = phi i64 [ %58, %40 ]
  %16 = phi i64 [ %59, %40 ]
  %17 = phi i64 [ %58, %40 ]
  br label %18

18:                                               ; preds = %14, %5
  %19 = phi i64 [ undef, %5 ], [ %15, %14 ]
  %20 = phi i64 [ 1, %5 ], [ %16, %14 ]
  %21 = phi i64 [ 1, %5 ], [ %17, %14 ]
  %22 = icmp ne i64 %10, 0
  br i1 %22, label %23, label %35

23:                                               ; preds = %18
  br label %24

24:                                               ; preds = %24, %23
  %25 = phi i64 [ %20, %23 ], [ %29, %24 ]
  %26 = phi i64 [ %21, %23 ], [ %28, %24 ]
  %27 = phi i64 [ 0, %23 ], [ %31, %24 ]
  %28 = mul i64 %26, %25
  %29 = add nuw nsw i64 %25, 1
  %30 = icmp eq i64 %29, %7
  %31 = add i64 %27, 1
  %32 = icmp ne i64 %31, %10
  br i1 %32, label %24, label %33, !llvm.loop !9

33:                                               ; preds = %24
  %34 = phi i64 [ %28, %24 ]
  br label %35

35:                                               ; preds = %18, %33
  %36 = phi i64 [ %19, %18 ], [ %34, %33 ]
  br label %37

37:                                               ; preds = %35, %0
  %38 = phi i64 [ 1, %0 ], [ %36, %35 ]
  %39 = call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.1, i64 noundef %38)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %1) #3
  ret i32 0

40:                                               ; preds = %40, %12
  %41 = phi i64 [ 1, %12 ], [ %59, %40 ]
  %42 = phi i64 [ 1, %12 ], [ %58, %40 ]
  %43 = phi i64 [ 0, %12 ], [ %60, %40 ]
  %44 = mul i64 %42, %41
  %45 = add nuw nsw i64 %41, 1
  %46 = mul i64 %44, %45
  %47 = add nuw nsw i64 %41, 2
  %48 = mul i64 %46, %47
  %49 = add nuw nsw i64 %41, 3
  %50 = mul i64 %48, %49
  %51 = add nuw nsw i64 %41, 4
  %52 = mul i64 %50, %51
  %53 = add nuw nsw i64 %41, 5
  %54 = mul i64 %52, %53
  %55 = add nuw nsw i64 %41, 6
  %56 = mul i64 %54, %55
  %57 = add nuw nsw i64 %41, 7
  %58 = mul i64 %56, %57
  %59 = add nuw nsw i64 %41, 8
  %60 = add i64 %43, 8
  %61 = icmp eq i64 %60, %13
  br i1 %61, label %14, label %40, !llvm.loop !11
}
; *** IR Dump After WarnMissedTransformationsPass on main ***
; Function Attrs: nofree nounwind uwtable
define dso_local noundef i32 @main() local_unnamed_addr #0 {
  %1 = alloca i32, align 4
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %1) #3
  %2 = call i32 (ptr, ...) @__isoc99_scanf(ptr noundef nonnull @.str, ptr noundef nonnull %1)
  %3 = load i32, ptr %1, align 4, !tbaa !5
  %4 = icmp slt i32 %3, 1
  br i1 %4, label %37, label %5

5:                                                ; preds = %0
  %6 = add nuw i32 %3, 1
  %7 = zext i32 %6 to i64
  %8 = add nsw i64 %7, -1
  %9 = add nsw i64 %7, -2
  %10 = and i64 %8, 7
  %11 = icmp ult i64 %9, 7
  br i1 %11, label %18, label %12

12:                                               ; preds = %5
  %13 = sub i64 %8, %10
  br label %40

14:                                               ; preds = %40
  %15 = phi i64 [ %58, %40 ]
  %16 = phi i64 [ %59, %40 ]
  %17 = phi i64 [ %58, %40 ]
  br label %18

18:                                               ; preds = %14, %5
  %19 = phi i64 [ undef, %5 ], [ %15, %14 ]
  %20 = phi i64 [ 1, %5 ], [ %16, %14 ]
  %21 = phi i64 [ 1, %5 ], [ %17, %14 ]
  %22 = icmp ne i64 %10, 0
  br i1 %22, label %23, label %35

23:                                               ; preds = %18
  br label %24

24:                                               ; preds = %24, %23
  %25 = phi i64 [ %20, %23 ], [ %29, %24 ]
  %26 = phi i64 [ %21, %23 ], [ %28, %24 ]
  %27 = phi i64 [ 0, %23 ], [ %31, %24 ]
  %28 = mul i64 %26, %25
  %29 = add nuw nsw i64 %25, 1
  %30 = icmp eq i64 %29, %7
  %31 = add i64 %27, 1
  %32 = icmp ne i64 %31, %10
  br i1 %32, label %24, label %33, !llvm.loop !9

33:                                               ; preds = %24
  %34 = phi i64 [ %28, %24 ]
  br label %35

35:                                               ; preds = %18, %33
  %36 = phi i64 [ %19, %18 ], [ %34, %33 ]
  br label %37

37:                                               ; preds = %35, %0
  %38 = phi i64 [ 1, %0 ], [ %36, %35 ]
  %39 = call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.1, i64 noundef %38)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %1) #3
  ret i32 0

40:                                               ; preds = %40, %12
  %41 = phi i64 [ 1, %12 ], [ %59, %40 ]
  %42 = phi i64 [ 1, %12 ], [ %58, %40 ]
  %43 = phi i64 [ 0, %12 ], [ %60, %40 ]
  %44 = mul i64 %42, %41
  %45 = add nuw nsw i64 %41, 1
  %46 = mul i64 %44, %45
  %47 = add nuw nsw i64 %41, 2
  %48 = mul i64 %46, %47
  %49 = add nuw nsw i64 %41, 3
  %50 = mul i64 %48, %49
  %51 = add nuw nsw i64 %41, 4
  %52 = mul i64 %50, %51
  %53 = add nuw nsw i64 %41, 5
  %54 = mul i64 %52, %53
  %55 = add nuw nsw i64 %41, 6
  %56 = mul i64 %54, %55
  %57 = add nuw nsw i64 %41, 7
  %58 = mul i64 %56, %57
  %59 = add nuw nsw i64 %41, 8
  %60 = add i64 %43, 8
  %61 = icmp eq i64 %60, %13
  br i1 %61, label %14, label %40, !llvm.loop !11
}
; *** IR Dump After SROAPass on main ***
; Function Attrs: nofree nounwind uwtable
define dso_local noundef i32 @main() local_unnamed_addr #0 {
  %1 = alloca i32, align 4
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %1) #3
  %2 = call i32 (ptr, ...) @__isoc99_scanf(ptr noundef nonnull @.str, ptr noundef nonnull %1)
  %3 = load i32, ptr %1, align 4, !tbaa !5
  %4 = icmp slt i32 %3, 1
  br i1 %4, label %37, label %5

5:                                                ; preds = %0
  %6 = add nuw i32 %3, 1
  %7 = zext i32 %6 to i64
  %8 = add nsw i64 %7, -1
  %9 = add nsw i64 %7, -2
  %10 = and i64 %8, 7
  %11 = icmp ult i64 %9, 7
  br i1 %11, label %18, label %12

12:                                               ; preds = %5
  %13 = sub i64 %8, %10
  br label %40

14:                                               ; preds = %40
  %15 = phi i64 [ %58, %40 ]
  %16 = phi i64 [ %59, %40 ]
  %17 = phi i64 [ %58, %40 ]
  br label %18

18:                                               ; preds = %14, %5
  %19 = phi i64 [ undef, %5 ], [ %15, %14 ]
  %20 = phi i64 [ 1, %5 ], [ %16, %14 ]
  %21 = phi i64 [ 1, %5 ], [ %17, %14 ]
  %22 = icmp ne i64 %10, 0
  br i1 %22, label %23, label %35

23:                                               ; preds = %18
  br label %24

24:                                               ; preds = %24, %23
  %25 = phi i64 [ %20, %23 ], [ %29, %24 ]
  %26 = phi i64 [ %21, %23 ], [ %28, %24 ]
  %27 = phi i64 [ 0, %23 ], [ %31, %24 ]
  %28 = mul i64 %26, %25
  %29 = add nuw nsw i64 %25, 1
  %30 = icmp eq i64 %29, %7
  %31 = add i64 %27, 1
  %32 = icmp ne i64 %31, %10
  br i1 %32, label %24, label %33, !llvm.loop !9

33:                                               ; preds = %24
  %34 = phi i64 [ %28, %24 ]
  br label %35

35:                                               ; preds = %18, %33
  %36 = phi i64 [ %19, %18 ], [ %34, %33 ]
  br label %37

37:                                               ; preds = %35, %0
  %38 = phi i64 [ 1, %0 ], [ %36, %35 ]
  %39 = call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.1, i64 noundef %38)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %1) #3
  ret i32 0

40:                                               ; preds = %40, %12
  %41 = phi i64 [ 1, %12 ], [ %59, %40 ]
  %42 = phi i64 [ 1, %12 ], [ %58, %40 ]
  %43 = phi i64 [ 0, %12 ], [ %60, %40 ]
  %44 = mul i64 %42, %41
  %45 = add nuw nsw i64 %41, 1
  %46 = mul i64 %44, %45
  %47 = add nuw nsw i64 %41, 2
  %48 = mul i64 %46, %47
  %49 = add nuw nsw i64 %41, 3
  %50 = mul i64 %48, %49
  %51 = add nuw nsw i64 %41, 4
  %52 = mul i64 %50, %51
  %53 = add nuw nsw i64 %41, 5
  %54 = mul i64 %52, %53
  %55 = add nuw nsw i64 %41, 6
  %56 = mul i64 %54, %55
  %57 = add nuw nsw i64 %41, 7
  %58 = mul i64 %56, %57
  %59 = add nuw nsw i64 %41, 8
  %60 = add i64 %43, 8
  %61 = icmp eq i64 %60, %13
  br i1 %61, label %14, label %40, !llvm.loop !11
}
; *** IR Dump After InferAlignmentPass on main ***
; Function Attrs: nofree nounwind uwtable
define dso_local noundef i32 @main() local_unnamed_addr #0 {
  %1 = alloca i32, align 4
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %1) #3
  %2 = call i32 (ptr, ...) @__isoc99_scanf(ptr noundef nonnull @.str, ptr noundef nonnull %1)
  %3 = load i32, ptr %1, align 4, !tbaa !5
  %4 = icmp slt i32 %3, 1
  br i1 %4, label %37, label %5

5:                                                ; preds = %0
  %6 = add nuw i32 %3, 1
  %7 = zext i32 %6 to i64
  %8 = add nsw i64 %7, -1
  %9 = add nsw i64 %7, -2
  %10 = and i64 %8, 7
  %11 = icmp ult i64 %9, 7
  br i1 %11, label %18, label %12

12:                                               ; preds = %5
  %13 = sub i64 %8, %10
  br label %40

14:                                               ; preds = %40
  %15 = phi i64 [ %58, %40 ]
  %16 = phi i64 [ %59, %40 ]
  %17 = phi i64 [ %58, %40 ]
  br label %18

18:                                               ; preds = %14, %5
  %19 = phi i64 [ undef, %5 ], [ %15, %14 ]
  %20 = phi i64 [ 1, %5 ], [ %16, %14 ]
  %21 = phi i64 [ 1, %5 ], [ %17, %14 ]
  %22 = icmp ne i64 %10, 0
  br i1 %22, label %23, label %35

23:                                               ; preds = %18
  br label %24

24:                                               ; preds = %24, %23
  %25 = phi i64 [ %20, %23 ], [ %29, %24 ]
  %26 = phi i64 [ %21, %23 ], [ %28, %24 ]
  %27 = phi i64 [ 0, %23 ], [ %31, %24 ]
  %28 = mul i64 %26, %25
  %29 = add nuw nsw i64 %25, 1
  %30 = icmp eq i64 %29, %7
  %31 = add i64 %27, 1
  %32 = icmp ne i64 %31, %10
  br i1 %32, label %24, label %33, !llvm.loop !9

33:                                               ; preds = %24
  %34 = phi i64 [ %28, %24 ]
  br label %35

35:                                               ; preds = %18, %33
  %36 = phi i64 [ %19, %18 ], [ %34, %33 ]
  br label %37

37:                                               ; preds = %35, %0
  %38 = phi i64 [ 1, %0 ], [ %36, %35 ]
  %39 = call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.1, i64 noundef %38)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %1) #3
  ret i32 0

40:                                               ; preds = %40, %12
  %41 = phi i64 [ 1, %12 ], [ %59, %40 ]
  %42 = phi i64 [ 1, %12 ], [ %58, %40 ]
  %43 = phi i64 [ 0, %12 ], [ %60, %40 ]
  %44 = mul i64 %42, %41
  %45 = add nuw nsw i64 %41, 1
  %46 = mul i64 %44, %45
  %47 = add nuw nsw i64 %41, 2
  %48 = mul i64 %46, %47
  %49 = add nuw nsw i64 %41, 3
  %50 = mul i64 %48, %49
  %51 = add nuw nsw i64 %41, 4
  %52 = mul i64 %50, %51
  %53 = add nuw nsw i64 %41, 5
  %54 = mul i64 %52, %53
  %55 = add nuw nsw i64 %41, 6
  %56 = mul i64 %54, %55
  %57 = add nuw nsw i64 %41, 7
  %58 = mul i64 %56, %57
  %59 = add nuw nsw i64 %41, 8
  %60 = add i64 %43, 8
  %61 = icmp eq i64 %60, %13
  br i1 %61, label %14, label %40, !llvm.loop !11
}
; *** IR Dump After InstCombinePass on main ***
; Function Attrs: nofree nounwind uwtable
define dso_local noundef i32 @main() local_unnamed_addr #0 {
  %1 = alloca i32, align 4
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %1) #3
  %2 = call i32 (ptr, ...) @__isoc99_scanf(ptr noundef nonnull @.str, ptr noundef nonnull %1)
  %3 = load i32, ptr %1, align 4, !tbaa !5
  %4 = icmp slt i32 %3, 1
  br i1 %4, label %32, label %5

5:                                                ; preds = %0
  %6 = add nuw i32 %3, 1
  %7 = zext i32 %6 to i64
  %8 = add nsw i64 %7, -1
  %9 = add nsw i64 %7, -2
  %10 = and i64 %8, 7
  %11 = icmp ult i64 %9, 7
  br i1 %11, label %15, label %12

12:                                               ; preds = %5
  %13 = and i64 %8, -8
  br label %35

14:                                               ; preds = %35
  br label %15

15:                                               ; preds = %14, %5
  %16 = phi i64 [ undef, %5 ], [ %53, %14 ]
  %17 = phi i64 [ 1, %5 ], [ %54, %14 ]
  %18 = phi i64 [ 1, %5 ], [ %53, %14 ]
  %19 = icmp eq i64 %10, 0
  br i1 %19, label %30, label %20

20:                                               ; preds = %15
  br label %21

21:                                               ; preds = %21, %20
  %22 = phi i64 [ %17, %20 ], [ %26, %21 ]
  %23 = phi i64 [ %18, %20 ], [ %25, %21 ]
  %24 = phi i64 [ 0, %20 ], [ %27, %21 ]
  %25 = mul i64 %23, %22
  %26 = add nuw nsw i64 %22, 1
  %27 = add i64 %24, 1
  %28 = icmp eq i64 %27, %10
  br i1 %28, label %29, label %21, !llvm.loop !9

29:                                               ; preds = %21
  br label %30

30:                                               ; preds = %15, %29
  %31 = phi i64 [ %16, %15 ], [ %25, %29 ]
  br label %32

32:                                               ; preds = %30, %0
  %33 = phi i64 [ 1, %0 ], [ %31, %30 ]
  %34 = call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.1, i64 noundef %33)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %1) #3
  ret i32 0

35:                                               ; preds = %35, %12
  %36 = phi i64 [ 1, %12 ], [ %54, %35 ]
  %37 = phi i64 [ 1, %12 ], [ %53, %35 ]
  %38 = phi i64 [ 0, %12 ], [ %55, %35 ]
  %39 = mul i64 %37, %36
  %40 = add nuw nsw i64 %36, 1
  %41 = mul i64 %39, %40
  %42 = add nuw nsw i64 %36, 2
  %43 = mul i64 %41, %42
  %44 = add nuw nsw i64 %36, 3
  %45 = mul i64 %43, %44
  %46 = add nuw nsw i64 %36, 4
  %47 = mul i64 %45, %46
  %48 = add nuw nsw i64 %36, 5
  %49 = mul i64 %47, %48
  %50 = add nuw nsw i64 %36, 6
  %51 = mul i64 %49, %50
  %52 = add nuw nsw i64 %36, 7
  %53 = mul i64 %51, %52
  %54 = add nuw nsw i64 %36, 8
  %55 = add i64 %38, 8
  %56 = icmp eq i64 %55, %13
  br i1 %56, label %14, label %35, !llvm.loop !11
}
; *** IR Dump After LoopSimplifyPass on main ***
; Function Attrs: nofree nounwind uwtable
define dso_local noundef i32 @main() local_unnamed_addr #0 {
  %1 = alloca i32, align 4
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %1) #3
  %2 = call i32 (ptr, ...) @__isoc99_scanf(ptr noundef nonnull @.str, ptr noundef nonnull %1)
  %3 = load i32, ptr %1, align 4, !tbaa !5
  %4 = icmp slt i32 %3, 1
  br i1 %4, label %32, label %5

5:                                                ; preds = %0
  %6 = add nuw i32 %3, 1
  %7 = zext i32 %6 to i64
  %8 = add nsw i64 %7, -1
  %9 = add nsw i64 %7, -2
  %10 = and i64 %8, 7
  %11 = icmp ult i64 %9, 7
  br i1 %11, label %15, label %12

12:                                               ; preds = %5
  %13 = and i64 %8, -8
  br label %35

14:                                               ; preds = %35
  br label %15

15:                                               ; preds = %14, %5
  %16 = phi i64 [ undef, %5 ], [ %53, %14 ]
  %17 = phi i64 [ 1, %5 ], [ %54, %14 ]
  %18 = phi i64 [ 1, %5 ], [ %53, %14 ]
  %19 = icmp eq i64 %10, 0
  br i1 %19, label %30, label %20

20:                                               ; preds = %15
  br label %21

21:                                               ; preds = %21, %20
  %22 = phi i64 [ %17, %20 ], [ %26, %21 ]
  %23 = phi i64 [ %18, %20 ], [ %25, %21 ]
  %24 = phi i64 [ 0, %20 ], [ %27, %21 ]
  %25 = mul i64 %23, %22
  %26 = add nuw nsw i64 %22, 1
  %27 = add i64 %24, 1
  %28 = icmp eq i64 %27, %10
  br i1 %28, label %29, label %21, !llvm.loop !9

29:                                               ; preds = %21
  br label %30

30:                                               ; preds = %15, %29
  %31 = phi i64 [ %16, %15 ], [ %25, %29 ]
  br label %32

32:                                               ; preds = %30, %0
  %33 = phi i64 [ 1, %0 ], [ %31, %30 ]
  %34 = call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.1, i64 noundef %33)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %1) #3
  ret i32 0

35:                                               ; preds = %35, %12
  %36 = phi i64 [ 1, %12 ], [ %54, %35 ]
  %37 = phi i64 [ 1, %12 ], [ %53, %35 ]
  %38 = phi i64 [ 0, %12 ], [ %55, %35 ]
  %39 = mul i64 %37, %36
  %40 = add nuw nsw i64 %36, 1
  %41 = mul i64 %39, %40
  %42 = add nuw nsw i64 %36, 2
  %43 = mul i64 %41, %42
  %44 = add nuw nsw i64 %36, 3
  %45 = mul i64 %43, %44
  %46 = add nuw nsw i64 %36, 4
  %47 = mul i64 %45, %46
  %48 = add nuw nsw i64 %36, 5
  %49 = mul i64 %47, %48
  %50 = add nuw nsw i64 %36, 6
  %51 = mul i64 %49, %50
  %52 = add nuw nsw i64 %36, 7
  %53 = mul i64 %51, %52
  %54 = add nuw nsw i64 %36, 8
  %55 = add i64 %38, 8
  %56 = icmp eq i64 %55, %13
  br i1 %56, label %14, label %35, !llvm.loop !11
}
; *** IR Dump After LCSSAPass on main ***
; Function Attrs: nofree nounwind uwtable
define dso_local noundef i32 @main() local_unnamed_addr #0 {
  %1 = alloca i32, align 4
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %1) #3
  %2 = call i32 (ptr, ...) @__isoc99_scanf(ptr noundef nonnull @.str, ptr noundef nonnull %1)
  %3 = load i32, ptr %1, align 4, !tbaa !5
  %4 = icmp slt i32 %3, 1
  br i1 %4, label %35, label %5

5:                                                ; preds = %0
  %6 = add nuw i32 %3, 1
  %7 = zext i32 %6 to i64
  %8 = add nsw i64 %7, -1
  %9 = add nsw i64 %7, -2
  %10 = and i64 %8, 7
  %11 = icmp ult i64 %9, 7
  br i1 %11, label %17, label %12

12:                                               ; preds = %5
  %13 = and i64 %8, -8
  br label %38

14:                                               ; preds = %38
  %15 = phi i64 [ %56, %38 ]
  %16 = phi i64 [ %57, %38 ]
  br label %17

17:                                               ; preds = %14, %5
  %18 = phi i64 [ undef, %5 ], [ %15, %14 ]
  %19 = phi i64 [ 1, %5 ], [ %16, %14 ]
  %20 = phi i64 [ 1, %5 ], [ %15, %14 ]
  %21 = icmp eq i64 %10, 0
  br i1 %21, label %33, label %22

22:                                               ; preds = %17
  br label %23

23:                                               ; preds = %23, %22
  %24 = phi i64 [ %19, %22 ], [ %28, %23 ]
  %25 = phi i64 [ %20, %22 ], [ %27, %23 ]
  %26 = phi i64 [ 0, %22 ], [ %29, %23 ]
  %27 = mul i64 %25, %24
  %28 = add nuw nsw i64 %24, 1
  %29 = add i64 %26, 1
  %30 = icmp eq i64 %29, %10
  br i1 %30, label %31, label %23, !llvm.loop !9

31:                                               ; preds = %23
  %32 = phi i64 [ %27, %23 ]
  br label %33

33:                                               ; preds = %17, %31
  %34 = phi i64 [ %18, %17 ], [ %32, %31 ]
  br label %35

35:                                               ; preds = %33, %0
  %36 = phi i64 [ 1, %0 ], [ %34, %33 ]
  %37 = call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.1, i64 noundef %36)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %1) #3
  ret i32 0

38:                                               ; preds = %38, %12
  %39 = phi i64 [ 1, %12 ], [ %57, %38 ]
  %40 = phi i64 [ 1, %12 ], [ %56, %38 ]
  %41 = phi i64 [ 0, %12 ], [ %58, %38 ]
  %42 = mul i64 %40, %39
  %43 = add nuw nsw i64 %39, 1
  %44 = mul i64 %42, %43
  %45 = add nuw nsw i64 %39, 2
  %46 = mul i64 %44, %45
  %47 = add nuw nsw i64 %39, 3
  %48 = mul i64 %46, %47
  %49 = add nuw nsw i64 %39, 4
  %50 = mul i64 %48, %49
  %51 = add nuw nsw i64 %39, 5
  %52 = mul i64 %50, %51
  %53 = add nuw nsw i64 %39, 6
  %54 = mul i64 %52, %53
  %55 = add nuw nsw i64 %39, 7
  %56 = mul i64 %54, %55
  %57 = add nuw nsw i64 %39, 8
  %58 = add i64 %41, 8
  %59 = icmp eq i64 %58, %13
  br i1 %59, label %14, label %38, !llvm.loop !11
}
; *** IR Dump After LICMPass on <unnamed loop> ***

; Preheader:
22:                                               ; preds = %17
  br label %23

; Loop:
23:                                               ; preds = %23, %22
  %24 = phi i64 [ %19, %22 ], [ %28, %23 ]
  %25 = phi i64 [ %20, %22 ], [ %27, %23 ]
  %26 = phi i64 [ 0, %22 ], [ %29, %23 ]
  %27 = mul i64 %25, %24
  %28 = add nuw nsw i64 %24, 1
  %29 = add i64 %26, 1
  %30 = icmp eq i64 %29, %10
  br i1 %30, label %31, label %23, !llvm.loop !9

; Exit blocks
31:                                               ; preds = %23
  %32 = phi i64 [ %27, %23 ]
  br label %33
; *** IR Dump After LICMPass on <unnamed loop> ***

; Preheader:
12:                                               ; preds = %5
  %13 = and i64 %8, -8
  br label %38

; Loop:
38:                                               ; preds = %38, %12
  %39 = phi i64 [ 1, %12 ], [ %57, %38 ]
  %40 = phi i64 [ 1, %12 ], [ %56, %38 ]
  %41 = phi i64 [ 0, %12 ], [ %58, %38 ]
  %42 = mul i64 %40, %39
  %43 = add nuw nsw i64 %39, 1
  %44 = mul i64 %42, %43
  %45 = add nuw nsw i64 %39, 2
  %46 = mul i64 %44, %45
  %47 = add nuw nsw i64 %39, 3
  %48 = mul i64 %46, %47
  %49 = add nuw nsw i64 %39, 4
  %50 = mul i64 %48, %49
  %51 = add nuw nsw i64 %39, 5
  %52 = mul i64 %50, %51
  %53 = add nuw nsw i64 %39, 6
  %54 = mul i64 %52, %53
  %55 = add nuw nsw i64 %39, 7
  %56 = mul i64 %54, %55
  %57 = add nuw nsw i64 %39, 8
  %58 = add i64 %41, 8
  %59 = icmp eq i64 %58, %13
  br i1 %59, label %14, label %38, !llvm.loop !11

; Exit blocks
14:                                               ; preds = %38
  %15 = phi i64 [ %56, %38 ]
  %16 = phi i64 [ %57, %38 ]
  br label %17
; *** IR Dump After AlignmentFromAssumptionsPass on main ***
; Function Attrs: nofree nounwind uwtable
define dso_local noundef i32 @main() local_unnamed_addr #0 {
  %1 = alloca i32, align 4
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %1) #3
  %2 = call i32 (ptr, ...) @__isoc99_scanf(ptr noundef nonnull @.str, ptr noundef nonnull %1)
  %3 = load i32, ptr %1, align 4, !tbaa !5
  %4 = icmp slt i32 %3, 1
  br i1 %4, label %35, label %5

5:                                                ; preds = %0
  %6 = add nuw i32 %3, 1
  %7 = zext i32 %6 to i64
  %8 = add nsw i64 %7, -1
  %9 = add nsw i64 %7, -2
  %10 = and i64 %8, 7
  %11 = icmp ult i64 %9, 7
  br i1 %11, label %17, label %12

12:                                               ; preds = %5
  %13 = and i64 %8, -8
  br label %38

14:                                               ; preds = %38
  %15 = phi i64 [ %56, %38 ]
  %16 = phi i64 [ %57, %38 ]
  br label %17

17:                                               ; preds = %14, %5
  %18 = phi i64 [ undef, %5 ], [ %15, %14 ]
  %19 = phi i64 [ 1, %5 ], [ %16, %14 ]
  %20 = phi i64 [ 1, %5 ], [ %15, %14 ]
  %21 = icmp eq i64 %10, 0
  br i1 %21, label %33, label %22

22:                                               ; preds = %17
  br label %23

23:                                               ; preds = %23, %22
  %24 = phi i64 [ %19, %22 ], [ %28, %23 ]
  %25 = phi i64 [ %20, %22 ], [ %27, %23 ]
  %26 = phi i64 [ 0, %22 ], [ %29, %23 ]
  %27 = mul i64 %25, %24
  %28 = add nuw nsw i64 %24, 1
  %29 = add i64 %26, 1
  %30 = icmp eq i64 %29, %10
  br i1 %30, label %31, label %23, !llvm.loop !9

31:                                               ; preds = %23
  %32 = phi i64 [ %27, %23 ]
  br label %33

33:                                               ; preds = %17, %31
  %34 = phi i64 [ %18, %17 ], [ %32, %31 ]
  br label %35

35:                                               ; preds = %33, %0
  %36 = phi i64 [ 1, %0 ], [ %34, %33 ]
  %37 = call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.1, i64 noundef %36)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %1) #3
  ret i32 0

38:                                               ; preds = %38, %12
  %39 = phi i64 [ 1, %12 ], [ %57, %38 ]
  %40 = phi i64 [ 1, %12 ], [ %56, %38 ]
  %41 = phi i64 [ 0, %12 ], [ %58, %38 ]
  %42 = mul i64 %40, %39
  %43 = add nuw nsw i64 %39, 1
  %44 = mul i64 %42, %43
  %45 = add nuw nsw i64 %39, 2
  %46 = mul i64 %44, %45
  %47 = add nuw nsw i64 %39, 3
  %48 = mul i64 %46, %47
  %49 = add nuw nsw i64 %39, 4
  %50 = mul i64 %48, %49
  %51 = add nuw nsw i64 %39, 5
  %52 = mul i64 %50, %51
  %53 = add nuw nsw i64 %39, 6
  %54 = mul i64 %52, %53
  %55 = add nuw nsw i64 %39, 7
  %56 = mul i64 %54, %55
  %57 = add nuw nsw i64 %39, 8
  %58 = add i64 %41, 8
  %59 = icmp eq i64 %58, %13
  br i1 %59, label %14, label %38, !llvm.loop !11
}
; *** IR Dump After LoopSinkPass on main ***
; Function Attrs: nofree nounwind uwtable
define dso_local noundef i32 @main() local_unnamed_addr #0 {
  %1 = alloca i32, align 4
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %1) #3
  %2 = call i32 (ptr, ...) @__isoc99_scanf(ptr noundef nonnull @.str, ptr noundef nonnull %1)
  %3 = load i32, ptr %1, align 4, !tbaa !5
  %4 = icmp slt i32 %3, 1
  br i1 %4, label %35, label %5

5:                                                ; preds = %0
  %6 = add nuw i32 %3, 1
  %7 = zext i32 %6 to i64
  %8 = add nsw i64 %7, -1
  %9 = add nsw i64 %7, -2
  %10 = and i64 %8, 7
  %11 = icmp ult i64 %9, 7
  br i1 %11, label %17, label %12

12:                                               ; preds = %5
  %13 = and i64 %8, -8
  br label %38

14:                                               ; preds = %38
  %15 = phi i64 [ %56, %38 ]
  %16 = phi i64 [ %57, %38 ]
  br label %17

17:                                               ; preds = %14, %5
  %18 = phi i64 [ undef, %5 ], [ %15, %14 ]
  %19 = phi i64 [ 1, %5 ], [ %16, %14 ]
  %20 = phi i64 [ 1, %5 ], [ %15, %14 ]
  %21 = icmp eq i64 %10, 0
  br i1 %21, label %33, label %22

22:                                               ; preds = %17
  br label %23

23:                                               ; preds = %23, %22
  %24 = phi i64 [ %19, %22 ], [ %28, %23 ]
  %25 = phi i64 [ %20, %22 ], [ %27, %23 ]
  %26 = phi i64 [ 0, %22 ], [ %29, %23 ]
  %27 = mul i64 %25, %24
  %28 = add nuw nsw i64 %24, 1
  %29 = add i64 %26, 1
  %30 = icmp eq i64 %29, %10
  br i1 %30, label %31, label %23, !llvm.loop !9

31:                                               ; preds = %23
  %32 = phi i64 [ %27, %23 ]
  br label %33

33:                                               ; preds = %17, %31
  %34 = phi i64 [ %18, %17 ], [ %32, %31 ]
  br label %35

35:                                               ; preds = %33, %0
  %36 = phi i64 [ 1, %0 ], [ %34, %33 ]
  %37 = call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.1, i64 noundef %36)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %1) #3
  ret i32 0

38:                                               ; preds = %38, %12
  %39 = phi i64 [ 1, %12 ], [ %57, %38 ]
  %40 = phi i64 [ 1, %12 ], [ %56, %38 ]
  %41 = phi i64 [ 0, %12 ], [ %58, %38 ]
  %42 = mul i64 %40, %39
  %43 = add nuw nsw i64 %39, 1
  %44 = mul i64 %42, %43
  %45 = add nuw nsw i64 %39, 2
  %46 = mul i64 %44, %45
  %47 = add nuw nsw i64 %39, 3
  %48 = mul i64 %46, %47
  %49 = add nuw nsw i64 %39, 4
  %50 = mul i64 %48, %49
  %51 = add nuw nsw i64 %39, 5
  %52 = mul i64 %50, %51
  %53 = add nuw nsw i64 %39, 6
  %54 = mul i64 %52, %53
  %55 = add nuw nsw i64 %39, 7
  %56 = mul i64 %54, %55
  %57 = add nuw nsw i64 %39, 8
  %58 = add i64 %41, 8
  %59 = icmp eq i64 %58, %13
  br i1 %59, label %14, label %38, !llvm.loop !11
}
; *** IR Dump After InstSimplifyPass on main ***
; Function Attrs: nofree nounwind uwtable
define dso_local noundef i32 @main() local_unnamed_addr #0 {
  %1 = alloca i32, align 4
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %1) #3
  %2 = call i32 (ptr, ...) @__isoc99_scanf(ptr noundef nonnull @.str, ptr noundef nonnull %1)
  %3 = load i32, ptr %1, align 4, !tbaa !5
  %4 = icmp slt i32 %3, 1
  br i1 %4, label %32, label %5

5:                                                ; preds = %0
  %6 = add nuw i32 %3, 1
  %7 = zext i32 %6 to i64
  %8 = add nsw i64 %7, -1
  %9 = add nsw i64 %7, -2
  %10 = and i64 %8, 7
  %11 = icmp ult i64 %9, 7
  br i1 %11, label %15, label %12

12:                                               ; preds = %5
  %13 = and i64 %8, -8
  br label %35

14:                                               ; preds = %35
  br label %15

15:                                               ; preds = %14, %5
  %16 = phi i64 [ undef, %5 ], [ %53, %14 ]
  %17 = phi i64 [ 1, %5 ], [ %54, %14 ]
  %18 = phi i64 [ 1, %5 ], [ %53, %14 ]
  %19 = icmp eq i64 %10, 0
  br i1 %19, label %30, label %20

20:                                               ; preds = %15
  br label %21

21:                                               ; preds = %21, %20
  %22 = phi i64 [ %17, %20 ], [ %26, %21 ]
  %23 = phi i64 [ %18, %20 ], [ %25, %21 ]
  %24 = phi i64 [ 0, %20 ], [ %27, %21 ]
  %25 = mul i64 %23, %22
  %26 = add nuw nsw i64 %22, 1
  %27 = add i64 %24, 1
  %28 = icmp eq i64 %27, %10
  br i1 %28, label %29, label %21, !llvm.loop !9

29:                                               ; preds = %21
  br label %30

30:                                               ; preds = %15, %29
  %31 = phi i64 [ %16, %15 ], [ %25, %29 ]
  br label %32

32:                                               ; preds = %30, %0
  %33 = phi i64 [ 1, %0 ], [ %31, %30 ]
  %34 = call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.1, i64 noundef %33)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %1) #3
  ret i32 0

35:                                               ; preds = %35, %12
  %36 = phi i64 [ 1, %12 ], [ %54, %35 ]
  %37 = phi i64 [ 1, %12 ], [ %53, %35 ]
  %38 = phi i64 [ 0, %12 ], [ %55, %35 ]
  %39 = mul i64 %37, %36
  %40 = add nuw nsw i64 %36, 1
  %41 = mul i64 %39, %40
  %42 = add nuw nsw i64 %36, 2
  %43 = mul i64 %41, %42
  %44 = add nuw nsw i64 %36, 3
  %45 = mul i64 %43, %44
  %46 = add nuw nsw i64 %36, 4
  %47 = mul i64 %45, %46
  %48 = add nuw nsw i64 %36, 5
  %49 = mul i64 %47, %48
  %50 = add nuw nsw i64 %36, 6
  %51 = mul i64 %49, %50
  %52 = add nuw nsw i64 %36, 7
  %53 = mul i64 %51, %52
  %54 = add nuw nsw i64 %36, 8
  %55 = add i64 %38, 8
  %56 = icmp eq i64 %55, %13
  br i1 %56, label %14, label %35, !llvm.loop !11
}
; *** IR Dump After DivRemPairsPass on main ***
; Function Attrs: nofree nounwind uwtable
define dso_local noundef i32 @main() local_unnamed_addr #0 {
  %1 = alloca i32, align 4
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %1) #3
  %2 = call i32 (ptr, ...) @__isoc99_scanf(ptr noundef nonnull @.str, ptr noundef nonnull %1)
  %3 = load i32, ptr %1, align 4, !tbaa !5
  %4 = icmp slt i32 %3, 1
  br i1 %4, label %32, label %5

5:                                                ; preds = %0
  %6 = add nuw i32 %3, 1
  %7 = zext i32 %6 to i64
  %8 = add nsw i64 %7, -1
  %9 = add nsw i64 %7, -2
  %10 = and i64 %8, 7
  %11 = icmp ult i64 %9, 7
  br i1 %11, label %15, label %12

12:                                               ; preds = %5
  %13 = and i64 %8, -8
  br label %35

14:                                               ; preds = %35
  br label %15

15:                                               ; preds = %14, %5
  %16 = phi i64 [ undef, %5 ], [ %53, %14 ]
  %17 = phi i64 [ 1, %5 ], [ %54, %14 ]
  %18 = phi i64 [ 1, %5 ], [ %53, %14 ]
  %19 = icmp eq i64 %10, 0
  br i1 %19, label %30, label %20

20:                                               ; preds = %15
  br label %21

21:                                               ; preds = %21, %20
  %22 = phi i64 [ %17, %20 ], [ %26, %21 ]
  %23 = phi i64 [ %18, %20 ], [ %25, %21 ]
  %24 = phi i64 [ 0, %20 ], [ %27, %21 ]
  %25 = mul i64 %23, %22
  %26 = add nuw nsw i64 %22, 1
  %27 = add i64 %24, 1
  %28 = icmp eq i64 %27, %10
  br i1 %28, label %29, label %21, !llvm.loop !9

29:                                               ; preds = %21
  br label %30

30:                                               ; preds = %15, %29
  %31 = phi i64 [ %16, %15 ], [ %25, %29 ]
  br label %32

32:                                               ; preds = %30, %0
  %33 = phi i64 [ 1, %0 ], [ %31, %30 ]
  %34 = call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.1, i64 noundef %33)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %1) #3
  ret i32 0

35:                                               ; preds = %35, %12
  %36 = phi i64 [ 1, %12 ], [ %54, %35 ]
  %37 = phi i64 [ 1, %12 ], [ %53, %35 ]
  %38 = phi i64 [ 0, %12 ], [ %55, %35 ]
  %39 = mul i64 %37, %36
  %40 = add nuw nsw i64 %36, 1
  %41 = mul i64 %39, %40
  %42 = add nuw nsw i64 %36, 2
  %43 = mul i64 %41, %42
  %44 = add nuw nsw i64 %36, 3
  %45 = mul i64 %43, %44
  %46 = add nuw nsw i64 %36, 4
  %47 = mul i64 %45, %46
  %48 = add nuw nsw i64 %36, 5
  %49 = mul i64 %47, %48
  %50 = add nuw nsw i64 %36, 6
  %51 = mul i64 %49, %50
  %52 = add nuw nsw i64 %36, 7
  %53 = mul i64 %51, %52
  %54 = add nuw nsw i64 %36, 8
  %55 = add i64 %38, 8
  %56 = icmp eq i64 %55, %13
  br i1 %56, label %14, label %35, !llvm.loop !11
}
; *** IR Dump After TailCallElimPass on main ***
; Function Attrs: nofree nounwind uwtable
define dso_local noundef i32 @main() local_unnamed_addr #0 {
  %1 = alloca i32, align 4
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %1) #3
  %2 = call i32 (ptr, ...) @__isoc99_scanf(ptr noundef nonnull @.str, ptr noundef nonnull %1)
  %3 = load i32, ptr %1, align 4, !tbaa !5
  %4 = icmp slt i32 %3, 1
  br i1 %4, label %32, label %5

5:                                                ; preds = %0
  %6 = add nuw i32 %3, 1
  %7 = zext i32 %6 to i64
  %8 = add nsw i64 %7, -1
  %9 = add nsw i64 %7, -2
  %10 = and i64 %8, 7
  %11 = icmp ult i64 %9, 7
  br i1 %11, label %15, label %12

12:                                               ; preds = %5
  %13 = and i64 %8, -8
  br label %35

14:                                               ; preds = %35
  br label %15

15:                                               ; preds = %14, %5
  %16 = phi i64 [ undef, %5 ], [ %53, %14 ]
  %17 = phi i64 [ 1, %5 ], [ %54, %14 ]
  %18 = phi i64 [ 1, %5 ], [ %53, %14 ]
  %19 = icmp eq i64 %10, 0
  br i1 %19, label %30, label %20

20:                                               ; preds = %15
  br label %21

21:                                               ; preds = %21, %20
  %22 = phi i64 [ %17, %20 ], [ %26, %21 ]
  %23 = phi i64 [ %18, %20 ], [ %25, %21 ]
  %24 = phi i64 [ 0, %20 ], [ %27, %21 ]
  %25 = mul i64 %23, %22
  %26 = add nuw nsw i64 %22, 1
  %27 = add i64 %24, 1
  %28 = icmp eq i64 %27, %10
  br i1 %28, label %29, label %21, !llvm.loop !9

29:                                               ; preds = %21
  br label %30

30:                                               ; preds = %15, %29
  %31 = phi i64 [ %16, %15 ], [ %25, %29 ]
  br label %32

32:                                               ; preds = %30, %0
  %33 = phi i64 [ 1, %0 ], [ %31, %30 ]
  %34 = call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.1, i64 noundef %33)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %1) #3
  ret i32 0

35:                                               ; preds = %35, %12
  %36 = phi i64 [ 1, %12 ], [ %54, %35 ]
  %37 = phi i64 [ 1, %12 ], [ %53, %35 ]
  %38 = phi i64 [ 0, %12 ], [ %55, %35 ]
  %39 = mul i64 %37, %36
  %40 = add nuw nsw i64 %36, 1
  %41 = mul i64 %39, %40
  %42 = add nuw nsw i64 %36, 2
  %43 = mul i64 %41, %42
  %44 = add nuw nsw i64 %36, 3
  %45 = mul i64 %43, %44
  %46 = add nuw nsw i64 %36, 4
  %47 = mul i64 %45, %46
  %48 = add nuw nsw i64 %36, 5
  %49 = mul i64 %47, %48
  %50 = add nuw nsw i64 %36, 6
  %51 = mul i64 %49, %50
  %52 = add nuw nsw i64 %36, 7
  %53 = mul i64 %51, %52
  %54 = add nuw nsw i64 %36, 8
  %55 = add i64 %38, 8
  %56 = icmp eq i64 %55, %13
  br i1 %56, label %14, label %35, !llvm.loop !11
}
; *** IR Dump After SimplifyCFGPass on main ***
; Function Attrs: nofree nounwind uwtable
define dso_local noundef i32 @main() local_unnamed_addr #0 {
  %1 = alloca i32, align 4
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %1) #3
  %2 = call i32 (ptr, ...) @__isoc99_scanf(ptr noundef nonnull @.str, ptr noundef nonnull %1)
  %3 = load i32, ptr %1, align 4, !tbaa !5
  %4 = icmp slt i32 %3, 1
  br i1 %4, label %27, label %5

5:                                                ; preds = %0
  %6 = add nuw i32 %3, 1
  %7 = zext i32 %6 to i64
  %8 = add nsw i64 %7, -1
  %9 = add nsw i64 %7, -2
  %10 = and i64 %8, 7
  %11 = icmp ult i64 %9, 7
  br i1 %11, label %14, label %12

12:                                               ; preds = %5
  %13 = and i64 %8, -8
  br label %30

14:                                               ; preds = %30, %5
  %15 = phi i64 [ undef, %5 ], [ %48, %30 ]
  %16 = phi i64 [ 1, %5 ], [ %49, %30 ]
  %17 = phi i64 [ 1, %5 ], [ %48, %30 ]
  %18 = icmp eq i64 %10, 0
  br i1 %18, label %27, label %19

19:                                               ; preds = %14, %19
  %20 = phi i64 [ %24, %19 ], [ %16, %14 ]
  %21 = phi i64 [ %23, %19 ], [ %17, %14 ]
  %22 = phi i64 [ %25, %19 ], [ 0, %14 ]
  %23 = mul i64 %21, %20
  %24 = add nuw nsw i64 %20, 1
  %25 = add i64 %22, 1
  %26 = icmp eq i64 %25, %10
  br i1 %26, label %27, label %19, !llvm.loop !9

27:                                               ; preds = %14, %19, %0
  %28 = phi i64 [ 1, %0 ], [ %15, %14 ], [ %23, %19 ]
  %29 = call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.1, i64 noundef %28)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %1) #3
  ret i32 0

30:                                               ; preds = %30, %12
  %31 = phi i64 [ 1, %12 ], [ %49, %30 ]
  %32 = phi i64 [ 1, %12 ], [ %48, %30 ]
  %33 = phi i64 [ 0, %12 ], [ %50, %30 ]
  %34 = mul i64 %32, %31
  %35 = add nuw nsw i64 %31, 1
  %36 = mul i64 %34, %35
  %37 = add nuw nsw i64 %31, 2
  %38 = mul i64 %36, %37
  %39 = add nuw nsw i64 %31, 3
  %40 = mul i64 %38, %39
  %41 = add nuw nsw i64 %31, 4
  %42 = mul i64 %40, %41
  %43 = add nuw nsw i64 %31, 5
  %44 = mul i64 %42, %43
  %45 = add nuw nsw i64 %31, 6
  %46 = mul i64 %44, %45
  %47 = add nuw nsw i64 %31, 7
  %48 = mul i64 %46, %47
  %49 = add nuw nsw i64 %31, 8
  %50 = add i64 %33, 8
  %51 = icmp eq i64 %50, %13
  br i1 %51, label %14, label %30, !llvm.loop !11
}
; *** IR Dump After GlobalDCEPass on [module] ***
; ModuleID = 'main.c'
source_filename = "main.c"
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128"
target triple = "x86_64-pc-linux-gnu"

@.str = private unnamed_addr constant [3 x i8] c"%d\00", align 1
@.str.1 = private unnamed_addr constant [6 x i8] c"%llu\0A\00", align 1

; Function Attrs: nofree nounwind uwtable
define dso_local noundef i32 @main() local_unnamed_addr #0 {
  %1 = alloca i32, align 4
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %1) #3
  %2 = call i32 (ptr, ...) @__isoc99_scanf(ptr noundef nonnull @.str, ptr noundef nonnull %1)
  %3 = load i32, ptr %1, align 4, !tbaa !5
  %4 = icmp slt i32 %3, 1
  br i1 %4, label %27, label %5

5:                                                ; preds = %0
  %6 = add nuw i32 %3, 1
  %7 = zext i32 %6 to i64
  %8 = add nsw i64 %7, -1
  %9 = add nsw i64 %7, -2
  %10 = and i64 %8, 7
  %11 = icmp ult i64 %9, 7
  br i1 %11, label %14, label %12

12:                                               ; preds = %5
  %13 = and i64 %8, -8
  br label %30

14:                                               ; preds = %30, %5
  %15 = phi i64 [ undef, %5 ], [ %48, %30 ]
  %16 = phi i64 [ 1, %5 ], [ %49, %30 ]
  %17 = phi i64 [ 1, %5 ], [ %48, %30 ]
  %18 = icmp eq i64 %10, 0
  br i1 %18, label %27, label %19

19:                                               ; preds = %14, %19
  %20 = phi i64 [ %24, %19 ], [ %16, %14 ]
  %21 = phi i64 [ %23, %19 ], [ %17, %14 ]
  %22 = phi i64 [ %25, %19 ], [ 0, %14 ]
  %23 = mul i64 %21, %20
  %24 = add nuw nsw i64 %20, 1
  %25 = add i64 %22, 1
  %26 = icmp eq i64 %25, %10
  br i1 %26, label %27, label %19, !llvm.loop !9

27:                                               ; preds = %14, %19, %0
  %28 = phi i64 [ 1, %0 ], [ %15, %14 ], [ %23, %19 ]
  %29 = call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.1, i64 noundef %28)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %1) #3
  ret i32 0

30:                                               ; preds = %30, %12
  %31 = phi i64 [ 1, %12 ], [ %49, %30 ]
  %32 = phi i64 [ 1, %12 ], [ %48, %30 ]
  %33 = phi i64 [ 0, %12 ], [ %50, %30 ]
  %34 = mul i64 %32, %31
  %35 = add nuw nsw i64 %31, 1
  %36 = mul i64 %34, %35
  %37 = add nuw nsw i64 %31, 2
  %38 = mul i64 %36, %37
  %39 = add nuw nsw i64 %31, 3
  %40 = mul i64 %38, %39
  %41 = add nuw nsw i64 %31, 4
  %42 = mul i64 %40, %41
  %43 = add nuw nsw i64 %31, 5
  %44 = mul i64 %42, %43
  %45 = add nuw nsw i64 %31, 6
  %46 = mul i64 %44, %45
  %47 = add nuw nsw i64 %31, 7
  %48 = mul i64 %46, %47
  %49 = add nuw nsw i64 %31, 8
  %50 = add i64 %33, 8
  %51 = icmp eq i64 %50, %13
  br i1 %51, label %14, label %30, !llvm.loop !11
}

; Function Attrs: mustprogress nocallback nofree nosync nounwind willreturn memory(argmem: readwrite)
declare void @llvm.lifetime.start.p0(i64 immarg, ptr nocapture) #1

; Function Attrs: nofree nounwind
declare noundef i32 @__isoc99_scanf(ptr nocapture noundef readonly, ...) local_unnamed_addr #2

; Function Attrs: mustprogress nocallback nofree nosync nounwind willreturn memory(argmem: readwrite)
declare void @llvm.lifetime.end.p0(i64 immarg, ptr nocapture) #1

; Function Attrs: nofree nounwind
declare noundef i32 @printf(ptr nocapture noundef readonly, ...) local_unnamed_addr #2

attributes #0 = { nofree nounwind uwtable "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #1 = { mustprogress nocallback nofree nosync nounwind willreturn memory(argmem: readwrite) }
attributes #2 = { nofree nounwind "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #3 = { nounwind }

!llvm.module.flags = !{!0, !1, !2, !3}
!llvm.ident = !{!4}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{i32 8, !"PIC Level", i32 2}
!2 = !{i32 7, !"PIE Level", i32 2}
!3 = !{i32 7, !"uwtable", i32 2}
!4 = !{!"Ubuntu clang version 18.1.3 (1ubuntu1)"}
!5 = !{!6, !6, i64 0}
!6 = !{!"int", !7, i64 0}
!7 = !{!"omnipotent char", !8, i64 0}
!8 = !{!"Simple C/C++ TBAA"}
!9 = distinct !{!9, !10}
!10 = !{!"llvm.loop.unroll.disable"}
!11 = distinct !{!11, !12}
!12 = !{!"llvm.loop.mustprogress"}
; *** IR Dump After ConstantMergePass on [module] ***
; ModuleID = 'main.c'
source_filename = "main.c"
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128"
target triple = "x86_64-pc-linux-gnu"

@.str = private unnamed_addr constant [3 x i8] c"%d\00", align 1
@.str.1 = private unnamed_addr constant [6 x i8] c"%llu\0A\00", align 1

; Function Attrs: nofree nounwind uwtable
define dso_local noundef i32 @main() local_unnamed_addr #0 {
  %1 = alloca i32, align 4
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %1) #3
  %2 = call i32 (ptr, ...) @__isoc99_scanf(ptr noundef nonnull @.str, ptr noundef nonnull %1)
  %3 = load i32, ptr %1, align 4, !tbaa !5
  %4 = icmp slt i32 %3, 1
  br i1 %4, label %27, label %5

5:                                                ; preds = %0
  %6 = add nuw i32 %3, 1
  %7 = zext i32 %6 to i64
  %8 = add nsw i64 %7, -1
  %9 = add nsw i64 %7, -2
  %10 = and i64 %8, 7
  %11 = icmp ult i64 %9, 7
  br i1 %11, label %14, label %12

12:                                               ; preds = %5
  %13 = and i64 %8, -8
  br label %30

14:                                               ; preds = %30, %5
  %15 = phi i64 [ undef, %5 ], [ %48, %30 ]
  %16 = phi i64 [ 1, %5 ], [ %49, %30 ]
  %17 = phi i64 [ 1, %5 ], [ %48, %30 ]
  %18 = icmp eq i64 %10, 0
  br i1 %18, label %27, label %19

19:                                               ; preds = %14, %19
  %20 = phi i64 [ %24, %19 ], [ %16, %14 ]
  %21 = phi i64 [ %23, %19 ], [ %17, %14 ]
  %22 = phi i64 [ %25, %19 ], [ 0, %14 ]
  %23 = mul i64 %21, %20
  %24 = add nuw nsw i64 %20, 1
  %25 = add i64 %22, 1
  %26 = icmp eq i64 %25, %10
  br i1 %26, label %27, label %19, !llvm.loop !9

27:                                               ; preds = %14, %19, %0
  %28 = phi i64 [ 1, %0 ], [ %15, %14 ], [ %23, %19 ]
  %29 = call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.1, i64 noundef %28)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %1) #3
  ret i32 0

30:                                               ; preds = %30, %12
  %31 = phi i64 [ 1, %12 ], [ %49, %30 ]
  %32 = phi i64 [ 1, %12 ], [ %48, %30 ]
  %33 = phi i64 [ 0, %12 ], [ %50, %30 ]
  %34 = mul i64 %32, %31
  %35 = add nuw nsw i64 %31, 1
  %36 = mul i64 %34, %35
  %37 = add nuw nsw i64 %31, 2
  %38 = mul i64 %36, %37
  %39 = add nuw nsw i64 %31, 3
  %40 = mul i64 %38, %39
  %41 = add nuw nsw i64 %31, 4
  %42 = mul i64 %40, %41
  %43 = add nuw nsw i64 %31, 5
  %44 = mul i64 %42, %43
  %45 = add nuw nsw i64 %31, 6
  %46 = mul i64 %44, %45
  %47 = add nuw nsw i64 %31, 7
  %48 = mul i64 %46, %47
  %49 = add nuw nsw i64 %31, 8
  %50 = add i64 %33, 8
  %51 = icmp eq i64 %50, %13
  br i1 %51, label %14, label %30, !llvm.loop !11
}

; Function Attrs: mustprogress nocallback nofree nosync nounwind willreturn memory(argmem: readwrite)
declare void @llvm.lifetime.start.p0(i64 immarg, ptr nocapture) #1

; Function Attrs: nofree nounwind
declare noundef i32 @__isoc99_scanf(ptr nocapture noundef readonly, ...) local_unnamed_addr #2

; Function Attrs: mustprogress nocallback nofree nosync nounwind willreturn memory(argmem: readwrite)
declare void @llvm.lifetime.end.p0(i64 immarg, ptr nocapture) #1

; Function Attrs: nofree nounwind
declare noundef i32 @printf(ptr nocapture noundef readonly, ...) local_unnamed_addr #2

attributes #0 = { nofree nounwind uwtable "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #1 = { mustprogress nocallback nofree nosync nounwind willreturn memory(argmem: readwrite) }
attributes #2 = { nofree nounwind "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #3 = { nounwind }

!llvm.module.flags = !{!0, !1, !2, !3}
!llvm.ident = !{!4}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{i32 8, !"PIC Level", i32 2}
!2 = !{i32 7, !"PIE Level", i32 2}
!3 = !{i32 7, !"uwtable", i32 2}
!4 = !{!"Ubuntu clang version 18.1.3 (1ubuntu1)"}
!5 = !{!6, !6, i64 0}
!6 = !{!"int", !7, i64 0}
!7 = !{!"omnipotent char", !8, i64 0}
!8 = !{!"Simple C/C++ TBAA"}
!9 = distinct !{!9, !10}
!10 = !{!"llvm.loop.unroll.disable"}
!11 = distinct !{!11, !12}
!12 = !{!"llvm.loop.mustprogress"}
; *** IR Dump After CGProfilePass on [module] ***
; ModuleID = 'main.c'
source_filename = "main.c"
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128"
target triple = "x86_64-pc-linux-gnu"

@.str = private unnamed_addr constant [3 x i8] c"%d\00", align 1
@.str.1 = private unnamed_addr constant [6 x i8] c"%llu\0A\00", align 1

; Function Attrs: nofree nounwind uwtable
define dso_local noundef i32 @main() local_unnamed_addr #0 {
  %1 = alloca i32, align 4
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %1) #3
  %2 = call i32 (ptr, ...) @__isoc99_scanf(ptr noundef nonnull @.str, ptr noundef nonnull %1)
  %3 = load i32, ptr %1, align 4, !tbaa !5
  %4 = icmp slt i32 %3, 1
  br i1 %4, label %27, label %5

5:                                                ; preds = %0
  %6 = add nuw i32 %3, 1
  %7 = zext i32 %6 to i64
  %8 = add nsw i64 %7, -1
  %9 = add nsw i64 %7, -2
  %10 = and i64 %8, 7
  %11 = icmp ult i64 %9, 7
  br i1 %11, label %14, label %12

12:                                               ; preds = %5
  %13 = and i64 %8, -8
  br label %30

14:                                               ; preds = %30, %5
  %15 = phi i64 [ undef, %5 ], [ %48, %30 ]
  %16 = phi i64 [ 1, %5 ], [ %49, %30 ]
  %17 = phi i64 [ 1, %5 ], [ %48, %30 ]
  %18 = icmp eq i64 %10, 0
  br i1 %18, label %27, label %19

19:                                               ; preds = %14, %19
  %20 = phi i64 [ %24, %19 ], [ %16, %14 ]
  %21 = phi i64 [ %23, %19 ], [ %17, %14 ]
  %22 = phi i64 [ %25, %19 ], [ 0, %14 ]
  %23 = mul i64 %21, %20
  %24 = add nuw nsw i64 %20, 1
  %25 = add i64 %22, 1
  %26 = icmp eq i64 %25, %10
  br i1 %26, label %27, label %19, !llvm.loop !9

27:                                               ; preds = %14, %19, %0
  %28 = phi i64 [ 1, %0 ], [ %15, %14 ], [ %23, %19 ]
  %29 = call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.1, i64 noundef %28)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %1) #3
  ret i32 0

30:                                               ; preds = %30, %12
  %31 = phi i64 [ 1, %12 ], [ %49, %30 ]
  %32 = phi i64 [ 1, %12 ], [ %48, %30 ]
  %33 = phi i64 [ 0, %12 ], [ %50, %30 ]
  %34 = mul i64 %32, %31
  %35 = add nuw nsw i64 %31, 1
  %36 = mul i64 %34, %35
  %37 = add nuw nsw i64 %31, 2
  %38 = mul i64 %36, %37
  %39 = add nuw nsw i64 %31, 3
  %40 = mul i64 %38, %39
  %41 = add nuw nsw i64 %31, 4
  %42 = mul i64 %40, %41
  %43 = add nuw nsw i64 %31, 5
  %44 = mul i64 %42, %43
  %45 = add nuw nsw i64 %31, 6
  %46 = mul i64 %44, %45
  %47 = add nuw nsw i64 %31, 7
  %48 = mul i64 %46, %47
  %49 = add nuw nsw i64 %31, 8
  %50 = add i64 %33, 8
  %51 = icmp eq i64 %50, %13
  br i1 %51, label %14, label %30, !llvm.loop !11
}

; Function Attrs: mustprogress nocallback nofree nosync nounwind willreturn memory(argmem: readwrite)
declare void @llvm.lifetime.start.p0(i64 immarg, ptr nocapture) #1

; Function Attrs: nofree nounwind
declare noundef i32 @__isoc99_scanf(ptr nocapture noundef readonly, ...) local_unnamed_addr #2

; Function Attrs: mustprogress nocallback nofree nosync nounwind willreturn memory(argmem: readwrite)
declare void @llvm.lifetime.end.p0(i64 immarg, ptr nocapture) #1

; Function Attrs: nofree nounwind
declare noundef i32 @printf(ptr nocapture noundef readonly, ...) local_unnamed_addr #2

attributes #0 = { nofree nounwind uwtable "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #1 = { mustprogress nocallback nofree nosync nounwind willreturn memory(argmem: readwrite) }
attributes #2 = { nofree nounwind "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #3 = { nounwind }

!llvm.module.flags = !{!0, !1, !2, !3}
!llvm.ident = !{!4}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{i32 8, !"PIC Level", i32 2}
!2 = !{i32 7, !"PIE Level", i32 2}
!3 = !{i32 7, !"uwtable", i32 2}
!4 = !{!"Ubuntu clang version 18.1.3 (1ubuntu1)"}
!5 = !{!6, !6, i64 0}
!6 = !{!"int", !7, i64 0}
!7 = !{!"omnipotent char", !8, i64 0}
!8 = !{!"Simple C/C++ TBAA"}
!9 = distinct !{!9, !10}
!10 = !{!"llvm.loop.unroll.disable"}
!11 = distinct !{!11, !12}
!12 = !{!"llvm.loop.mustprogress"}
; *** IR Dump After RelLookupTableConverterPass on [module] ***
; ModuleID = 'main.c'
source_filename = "main.c"
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128"
target triple = "x86_64-pc-linux-gnu"

@.str = private unnamed_addr constant [3 x i8] c"%d\00", align 1
@.str.1 = private unnamed_addr constant [6 x i8] c"%llu\0A\00", align 1

; Function Attrs: nofree nounwind uwtable
define dso_local noundef i32 @main() local_unnamed_addr #0 {
  %1 = alloca i32, align 4
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %1) #3
  %2 = call i32 (ptr, ...) @__isoc99_scanf(ptr noundef nonnull @.str, ptr noundef nonnull %1)
  %3 = load i32, ptr %1, align 4, !tbaa !5
  %4 = icmp slt i32 %3, 1
  br i1 %4, label %27, label %5

5:                                                ; preds = %0
  %6 = add nuw i32 %3, 1
  %7 = zext i32 %6 to i64
  %8 = add nsw i64 %7, -1
  %9 = add nsw i64 %7, -2
  %10 = and i64 %8, 7
  %11 = icmp ult i64 %9, 7
  br i1 %11, label %14, label %12

12:                                               ; preds = %5
  %13 = and i64 %8, -8
  br label %30

14:                                               ; preds = %30, %5
  %15 = phi i64 [ undef, %5 ], [ %48, %30 ]
  %16 = phi i64 [ 1, %5 ], [ %49, %30 ]
  %17 = phi i64 [ 1, %5 ], [ %48, %30 ]
  %18 = icmp eq i64 %10, 0
  br i1 %18, label %27, label %19

19:                                               ; preds = %14, %19
  %20 = phi i64 [ %24, %19 ], [ %16, %14 ]
  %21 = phi i64 [ %23, %19 ], [ %17, %14 ]
  %22 = phi i64 [ %25, %19 ], [ 0, %14 ]
  %23 = mul i64 %21, %20
  %24 = add nuw nsw i64 %20, 1
  %25 = add i64 %22, 1
  %26 = icmp eq i64 %25, %10
  br i1 %26, label %27, label %19, !llvm.loop !9

27:                                               ; preds = %14, %19, %0
  %28 = phi i64 [ 1, %0 ], [ %15, %14 ], [ %23, %19 ]
  %29 = call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.1, i64 noundef %28)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %1) #3
  ret i32 0

30:                                               ; preds = %30, %12
  %31 = phi i64 [ 1, %12 ], [ %49, %30 ]
  %32 = phi i64 [ 1, %12 ], [ %48, %30 ]
  %33 = phi i64 [ 0, %12 ], [ %50, %30 ]
  %34 = mul i64 %32, %31
  %35 = add nuw nsw i64 %31, 1
  %36 = mul i64 %34, %35
  %37 = add nuw nsw i64 %31, 2
  %38 = mul i64 %36, %37
  %39 = add nuw nsw i64 %31, 3
  %40 = mul i64 %38, %39
  %41 = add nuw nsw i64 %31, 4
  %42 = mul i64 %40, %41
  %43 = add nuw nsw i64 %31, 5
  %44 = mul i64 %42, %43
  %45 = add nuw nsw i64 %31, 6
  %46 = mul i64 %44, %45
  %47 = add nuw nsw i64 %31, 7
  %48 = mul i64 %46, %47
  %49 = add nuw nsw i64 %31, 8
  %50 = add i64 %33, 8
  %51 = icmp eq i64 %50, %13
  br i1 %51, label %14, label %30, !llvm.loop !11
}

; Function Attrs: mustprogress nocallback nofree nosync nounwind willreturn memory(argmem: readwrite)
declare void @llvm.lifetime.start.p0(i64 immarg, ptr nocapture) #1

; Function Attrs: nofree nounwind
declare noundef i32 @__isoc99_scanf(ptr nocapture noundef readonly, ...) local_unnamed_addr #2

; Function Attrs: mustprogress nocallback nofree nosync nounwind willreturn memory(argmem: readwrite)
declare void @llvm.lifetime.end.p0(i64 immarg, ptr nocapture) #1

; Function Attrs: nofree nounwind
declare noundef i32 @printf(ptr nocapture noundef readonly, ...) local_unnamed_addr #2

attributes #0 = { nofree nounwind uwtable "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #1 = { mustprogress nocallback nofree nosync nounwind willreturn memory(argmem: readwrite) }
attributes #2 = { nofree nounwind "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #3 = { nounwind }

!llvm.module.flags = !{!0, !1, !2, !3}
!llvm.ident = !{!4}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{i32 8, !"PIC Level", i32 2}
!2 = !{i32 7, !"PIE Level", i32 2}
!3 = !{i32 7, !"uwtable", i32 2}
!4 = !{!"Ubuntu clang version 18.1.3 (1ubuntu1)"}
!5 = !{!6, !6, i64 0}
!6 = !{!"int", !7, i64 0}
!7 = !{!"omnipotent char", !8, i64 0}
!8 = !{!"Simple C/C++ TBAA"}
!9 = distinct !{!9, !10}
!10 = !{!"llvm.loop.unroll.disable"}
!11 = distinct !{!11, !12}
!12 = !{!"llvm.loop.mustprogress"}
; *** IR Dump After AnnotationRemarksPass on main ***
; Function Attrs: nofree nounwind uwtable
define dso_local noundef i32 @main() local_unnamed_addr #0 {
  %1 = alloca i32, align 4
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %1) #3
  %2 = call i32 (ptr, ...) @__isoc99_scanf(ptr noundef nonnull @.str, ptr noundef nonnull %1)
  %3 = load i32, ptr %1, align 4, !tbaa !5
  %4 = icmp slt i32 %3, 1
  br i1 %4, label %27, label %5

5:                                                ; preds = %0
  %6 = add nuw i32 %3, 1
  %7 = zext i32 %6 to i64
  %8 = add nsw i64 %7, -1
  %9 = add nsw i64 %7, -2
  %10 = and i64 %8, 7
  %11 = icmp ult i64 %9, 7
  br i1 %11, label %14, label %12

12:                                               ; preds = %5
  %13 = and i64 %8, -8
  br label %30

14:                                               ; preds = %30, %5
  %15 = phi i64 [ undef, %5 ], [ %48, %30 ]
  %16 = phi i64 [ 1, %5 ], [ %49, %30 ]
  %17 = phi i64 [ 1, %5 ], [ %48, %30 ]
  %18 = icmp eq i64 %10, 0
  br i1 %18, label %27, label %19

19:                                               ; preds = %14, %19
  %20 = phi i64 [ %24, %19 ], [ %16, %14 ]
  %21 = phi i64 [ %23, %19 ], [ %17, %14 ]
  %22 = phi i64 [ %25, %19 ], [ 0, %14 ]
  %23 = mul i64 %21, %20
  %24 = add nuw nsw i64 %20, 1
  %25 = add i64 %22, 1
  %26 = icmp eq i64 %25, %10
  br i1 %26, label %27, label %19, !llvm.loop !9

27:                                               ; preds = %14, %19, %0
  %28 = phi i64 [ 1, %0 ], [ %15, %14 ], [ %23, %19 ]
  %29 = call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.1, i64 noundef %28)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %1) #3
  ret i32 0

30:                                               ; preds = %30, %12
  %31 = phi i64 [ 1, %12 ], [ %49, %30 ]
  %32 = phi i64 [ 1, %12 ], [ %48, %30 ]
  %33 = phi i64 [ 0, %12 ], [ %50, %30 ]
  %34 = mul i64 %32, %31
  %35 = add nuw nsw i64 %31, 1
  %36 = mul i64 %34, %35
  %37 = add nuw nsw i64 %31, 2
  %38 = mul i64 %36, %37
  %39 = add nuw nsw i64 %31, 3
  %40 = mul i64 %38, %39
  %41 = add nuw nsw i64 %31, 4
  %42 = mul i64 %40, %41
  %43 = add nuw nsw i64 %31, 5
  %44 = mul i64 %42, %43
  %45 = add nuw nsw i64 %31, 6
  %46 = mul i64 %44, %45
  %47 = add nuw nsw i64 %31, 7
  %48 = mul i64 %46, %47
  %49 = add nuw nsw i64 %31, 8
  %50 = add i64 %33, 8
  %51 = icmp eq i64 %50, %13
  br i1 %51, label %14, label %30, !llvm.loop !11
}
*** IR Dump After ObjC ARC contraction (objc-arc-contract) ***
; Function Attrs: nofree nounwind uwtable
define dso_local noundef i32 @main() local_unnamed_addr #0 {
  %1 = alloca i32, align 4
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %1) #3
  %2 = call i32 (ptr, ...) @__isoc99_scanf(ptr noundef nonnull @.str, ptr noundef nonnull %1)
  %3 = load i32, ptr %1, align 4, !tbaa !5
  %4 = icmp slt i32 %3, 1
  br i1 %4, label %27, label %5

5:                                                ; preds = %0
  %6 = add nuw i32 %3, 1
  %7 = zext i32 %6 to i64
  %8 = add nsw i64 %7, -1
  %9 = add nsw i64 %7, -2
  %10 = and i64 %8, 7
  %11 = icmp ult i64 %9, 7
  br i1 %11, label %14, label %12

12:                                               ; preds = %5
  %13 = and i64 %8, -8
  br label %30

14:                                               ; preds = %30, %5
  %15 = phi i64 [ undef, %5 ], [ %48, %30 ]
  %16 = phi i64 [ 1, %5 ], [ %49, %30 ]
  %17 = phi i64 [ 1, %5 ], [ %48, %30 ]
  %18 = icmp eq i64 %10, 0
  br i1 %18, label %27, label %19

19:                                               ; preds = %14, %19
  %20 = phi i64 [ %24, %19 ], [ %16, %14 ]
  %21 = phi i64 [ %23, %19 ], [ %17, %14 ]
  %22 = phi i64 [ %25, %19 ], [ 0, %14 ]
  %23 = mul i64 %21, %20
  %24 = add nuw nsw i64 %20, 1
  %25 = add i64 %22, 1
  %26 = icmp eq i64 %25, %10
  br i1 %26, label %27, label %19, !llvm.loop !9

27:                                               ; preds = %14, %19, %0
  %28 = phi i64 [ 1, %0 ], [ %15, %14 ], [ %23, %19 ]
  %29 = call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.1, i64 noundef %28)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %1) #3
  ret i32 0

30:                                               ; preds = %30, %12
  %31 = phi i64 [ 1, %12 ], [ %49, %30 ]
  %32 = phi i64 [ 1, %12 ], [ %48, %30 ]
  %33 = phi i64 [ 0, %12 ], [ %50, %30 ]
  %34 = mul i64 %32, %31
  %35 = add nuw nsw i64 %31, 1
  %36 = mul i64 %34, %35
  %37 = add nuw nsw i64 %31, 2
  %38 = mul i64 %36, %37
  %39 = add nuw nsw i64 %31, 3
  %40 = mul i64 %38, %39
  %41 = add nuw nsw i64 %31, 4
  %42 = mul i64 %40, %41
  %43 = add nuw nsw i64 %31, 5
  %44 = mul i64 %42, %43
  %45 = add nuw nsw i64 %31, 6
  %46 = mul i64 %44, %45
  %47 = add nuw nsw i64 %31, 7
  %48 = mul i64 %46, %47
  %49 = add nuw nsw i64 %31, 8
  %50 = add i64 %33, 8
  %51 = icmp eq i64 %50, %13
  br i1 %51, label %14, label %30, !llvm.loop !11
}
*** IR Dump After Pre-ISel Intrinsic Lowering (pre-isel-intrinsic-lowering) ***
; ModuleID = 'main.c'
source_filename = "main.c"
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128"
target triple = "x86_64-pc-linux-gnu"

@.str = private unnamed_addr constant [3 x i8] c"%d\00", align 1
@.str.1 = private unnamed_addr constant [6 x i8] c"%llu\0A\00", align 1

; Function Attrs: nofree nounwind uwtable
define dso_local noundef i32 @main() local_unnamed_addr #0 {
  %1 = alloca i32, align 4
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %1) #3
  %2 = call i32 (ptr, ...) @__isoc99_scanf(ptr noundef nonnull @.str, ptr noundef nonnull %1)
  %3 = load i32, ptr %1, align 4, !tbaa !5
  %4 = icmp slt i32 %3, 1
  br i1 %4, label %27, label %5

5:                                                ; preds = %0
  %6 = add nuw i32 %3, 1
  %7 = zext i32 %6 to i64
  %8 = add nsw i64 %7, -1
  %9 = add nsw i64 %7, -2
  %10 = and i64 %8, 7
  %11 = icmp ult i64 %9, 7
  br i1 %11, label %14, label %12

12:                                               ; preds = %5
  %13 = and i64 %8, -8
  br label %30

14:                                               ; preds = %30, %5
  %15 = phi i64 [ undef, %5 ], [ %48, %30 ]
  %16 = phi i64 [ 1, %5 ], [ %49, %30 ]
  %17 = phi i64 [ 1, %5 ], [ %48, %30 ]
  %18 = icmp eq i64 %10, 0
  br i1 %18, label %27, label %19

19:                                               ; preds = %14, %19
  %20 = phi i64 [ %24, %19 ], [ %16, %14 ]
  %21 = phi i64 [ %23, %19 ], [ %17, %14 ]
  %22 = phi i64 [ %25, %19 ], [ 0, %14 ]
  %23 = mul i64 %21, %20
  %24 = add nuw nsw i64 %20, 1
  %25 = add i64 %22, 1
  %26 = icmp eq i64 %25, %10
  br i1 %26, label %27, label %19, !llvm.loop !9

27:                                               ; preds = %14, %19, %0
  %28 = phi i64 [ 1, %0 ], [ %15, %14 ], [ %23, %19 ]
  %29 = call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.1, i64 noundef %28)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %1) #3
  ret i32 0

30:                                               ; preds = %30, %12
  %31 = phi i64 [ 1, %12 ], [ %49, %30 ]
  %32 = phi i64 [ 1, %12 ], [ %48, %30 ]
  %33 = phi i64 [ 0, %12 ], [ %50, %30 ]
  %34 = mul i64 %32, %31
  %35 = add nuw nsw i64 %31, 1
  %36 = mul i64 %34, %35
  %37 = add nuw nsw i64 %31, 2
  %38 = mul i64 %36, %37
  %39 = add nuw nsw i64 %31, 3
  %40 = mul i64 %38, %39
  %41 = add nuw nsw i64 %31, 4
  %42 = mul i64 %40, %41
  %43 = add nuw nsw i64 %31, 5
  %44 = mul i64 %42, %43
  %45 = add nuw nsw i64 %31, 6
  %46 = mul i64 %44, %45
  %47 = add nuw nsw i64 %31, 7
  %48 = mul i64 %46, %47
  %49 = add nuw nsw i64 %31, 8
  %50 = add i64 %33, 8
  %51 = icmp eq i64 %50, %13
  br i1 %51, label %14, label %30, !llvm.loop !11
}

; Function Attrs: mustprogress nocallback nofree nosync nounwind willreturn memory(argmem: readwrite)
declare void @llvm.lifetime.start.p0(i64 immarg, ptr nocapture) #1

; Function Attrs: nofree nounwind
declare noundef i32 @__isoc99_scanf(ptr nocapture noundef readonly, ...) local_unnamed_addr #2

; Function Attrs: mustprogress nocallback nofree nosync nounwind willreturn memory(argmem: readwrite)
declare void @llvm.lifetime.end.p0(i64 immarg, ptr nocapture) #1

; Function Attrs: nofree nounwind
declare noundef i32 @printf(ptr nocapture noundef readonly, ...) local_unnamed_addr #2

attributes #0 = { nofree nounwind uwtable "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #1 = { mustprogress nocallback nofree nosync nounwind willreturn memory(argmem: readwrite) }
attributes #2 = { nofree nounwind "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #3 = { nounwind }

!llvm.module.flags = !{!0, !1, !2, !3}
!llvm.ident = !{!4}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{i32 8, !"PIC Level", i32 2}
!2 = !{i32 7, !"PIE Level", i32 2}
!3 = !{i32 7, !"uwtable", i32 2}
!4 = !{!"Ubuntu clang version 18.1.3 (1ubuntu1)"}
!5 = !{!6, !6, i64 0}
!6 = !{!"int", !7, i64 0}
!7 = !{!"omnipotent char", !8, i64 0}
!8 = !{!"Simple C/C++ TBAA"}
!9 = distinct !{!9, !10}
!10 = !{!"llvm.loop.unroll.disable"}
!11 = distinct !{!11, !12}
!12 = !{!"llvm.loop.mustprogress"}
*** IR Dump After Expand large div/rem (expand-large-div-rem) ***
; Function Attrs: nofree nounwind uwtable
define dso_local noundef i32 @main() local_unnamed_addr #0 {
  %1 = alloca i32, align 4
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %1) #3
  %2 = call i32 (ptr, ...) @__isoc99_scanf(ptr noundef nonnull @.str, ptr noundef nonnull %1)
  %3 = load i32, ptr %1, align 4, !tbaa !5
  %4 = icmp slt i32 %3, 1
  br i1 %4, label %27, label %5

5:                                                ; preds = %0
  %6 = add nuw i32 %3, 1
  %7 = zext i32 %6 to i64
  %8 = add nsw i64 %7, -1
  %9 = add nsw i64 %7, -2
  %10 = and i64 %8, 7
  %11 = icmp ult i64 %9, 7
  br i1 %11, label %14, label %12

12:                                               ; preds = %5
  %13 = and i64 %8, -8
  br label %30

14:                                               ; preds = %30, %5
  %15 = phi i64 [ undef, %5 ], [ %48, %30 ]
  %16 = phi i64 [ 1, %5 ], [ %49, %30 ]
  %17 = phi i64 [ 1, %5 ], [ %48, %30 ]
  %18 = icmp eq i64 %10, 0
  br i1 %18, label %27, label %19

19:                                               ; preds = %14, %19
  %20 = phi i64 [ %24, %19 ], [ %16, %14 ]
  %21 = phi i64 [ %23, %19 ], [ %17, %14 ]
  %22 = phi i64 [ %25, %19 ], [ 0, %14 ]
  %23 = mul i64 %21, %20
  %24 = add nuw nsw i64 %20, 1
  %25 = add i64 %22, 1
  %26 = icmp eq i64 %25, %10
  br i1 %26, label %27, label %19, !llvm.loop !9

27:                                               ; preds = %14, %19, %0
  %28 = phi i64 [ 1, %0 ], [ %15, %14 ], [ %23, %19 ]
  %29 = call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.1, i64 noundef %28)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %1) #3
  ret i32 0

30:                                               ; preds = %30, %12
  %31 = phi i64 [ 1, %12 ], [ %49, %30 ]
  %32 = phi i64 [ 1, %12 ], [ %48, %30 ]
  %33 = phi i64 [ 0, %12 ], [ %50, %30 ]
  %34 = mul i64 %32, %31
  %35 = add nuw nsw i64 %31, 1
  %36 = mul i64 %34, %35
  %37 = add nuw nsw i64 %31, 2
  %38 = mul i64 %36, %37
  %39 = add nuw nsw i64 %31, 3
  %40 = mul i64 %38, %39
  %41 = add nuw nsw i64 %31, 4
  %42 = mul i64 %40, %41
  %43 = add nuw nsw i64 %31, 5
  %44 = mul i64 %42, %43
  %45 = add nuw nsw i64 %31, 6
  %46 = mul i64 %44, %45
  %47 = add nuw nsw i64 %31, 7
  %48 = mul i64 %46, %47
  %49 = add nuw nsw i64 %31, 8
  %50 = add i64 %33, 8
  %51 = icmp eq i64 %50, %13
  br i1 %51, label %14, label %30, !llvm.loop !11
}
*** IR Dump After Expand large fp convert (expand-large-fp-convert) ***
; Function Attrs: nofree nounwind uwtable
define dso_local noundef i32 @main() local_unnamed_addr #0 {
  %1 = alloca i32, align 4
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %1) #3
  %2 = call i32 (ptr, ...) @__isoc99_scanf(ptr noundef nonnull @.str, ptr noundef nonnull %1)
  %3 = load i32, ptr %1, align 4, !tbaa !5
  %4 = icmp slt i32 %3, 1
  br i1 %4, label %27, label %5

5:                                                ; preds = %0
  %6 = add nuw i32 %3, 1
  %7 = zext i32 %6 to i64
  %8 = add nsw i64 %7, -1
  %9 = add nsw i64 %7, -2
  %10 = and i64 %8, 7
  %11 = icmp ult i64 %9, 7
  br i1 %11, label %14, label %12

12:                                               ; preds = %5
  %13 = and i64 %8, -8
  br label %30

14:                                               ; preds = %30, %5
  %15 = phi i64 [ undef, %5 ], [ %48, %30 ]
  %16 = phi i64 [ 1, %5 ], [ %49, %30 ]
  %17 = phi i64 [ 1, %5 ], [ %48, %30 ]
  %18 = icmp eq i64 %10, 0
  br i1 %18, label %27, label %19

19:                                               ; preds = %14, %19
  %20 = phi i64 [ %24, %19 ], [ %16, %14 ]
  %21 = phi i64 [ %23, %19 ], [ %17, %14 ]
  %22 = phi i64 [ %25, %19 ], [ 0, %14 ]
  %23 = mul i64 %21, %20
  %24 = add nuw nsw i64 %20, 1
  %25 = add i64 %22, 1
  %26 = icmp eq i64 %25, %10
  br i1 %26, label %27, label %19, !llvm.loop !9

27:                                               ; preds = %14, %19, %0
  %28 = phi i64 [ 1, %0 ], [ %15, %14 ], [ %23, %19 ]
  %29 = call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.1, i64 noundef %28)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %1) #3
  ret i32 0

30:                                               ; preds = %30, %12
  %31 = phi i64 [ 1, %12 ], [ %49, %30 ]
  %32 = phi i64 [ 1, %12 ], [ %48, %30 ]
  %33 = phi i64 [ 0, %12 ], [ %50, %30 ]
  %34 = mul i64 %32, %31
  %35 = add nuw nsw i64 %31, 1
  %36 = mul i64 %34, %35
  %37 = add nuw nsw i64 %31, 2
  %38 = mul i64 %36, %37
  %39 = add nuw nsw i64 %31, 3
  %40 = mul i64 %38, %39
  %41 = add nuw nsw i64 %31, 4
  %42 = mul i64 %40, %41
  %43 = add nuw nsw i64 %31, 5
  %44 = mul i64 %42, %43
  %45 = add nuw nsw i64 %31, 6
  %46 = mul i64 %44, %45
  %47 = add nuw nsw i64 %31, 7
  %48 = mul i64 %46, %47
  %49 = add nuw nsw i64 %31, 8
  %50 = add i64 %33, 8
  %51 = icmp eq i64 %50, %13
  br i1 %51, label %14, label %30, !llvm.loop !11
}
*** IR Dump After Expand Atomic instructions (atomic-expand) ***
; Function Attrs: nofree nounwind uwtable
define dso_local noundef i32 @main() local_unnamed_addr #0 {
  %1 = alloca i32, align 4
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %1) #3
  %2 = call i32 (ptr, ...) @__isoc99_scanf(ptr noundef nonnull @.str, ptr noundef nonnull %1)
  %3 = load i32, ptr %1, align 4, !tbaa !5
  %4 = icmp slt i32 %3, 1
  br i1 %4, label %27, label %5

5:                                                ; preds = %0
  %6 = add nuw i32 %3, 1
  %7 = zext i32 %6 to i64
  %8 = add nsw i64 %7, -1
  %9 = add nsw i64 %7, -2
  %10 = and i64 %8, 7
  %11 = icmp ult i64 %9, 7
  br i1 %11, label %14, label %12

12:                                               ; preds = %5
  %13 = and i64 %8, -8
  br label %30

14:                                               ; preds = %30, %5
  %15 = phi i64 [ undef, %5 ], [ %48, %30 ]
  %16 = phi i64 [ 1, %5 ], [ %49, %30 ]
  %17 = phi i64 [ 1, %5 ], [ %48, %30 ]
  %18 = icmp eq i64 %10, 0
  br i1 %18, label %27, label %19

19:                                               ; preds = %14, %19
  %20 = phi i64 [ %24, %19 ], [ %16, %14 ]
  %21 = phi i64 [ %23, %19 ], [ %17, %14 ]
  %22 = phi i64 [ %25, %19 ], [ 0, %14 ]
  %23 = mul i64 %21, %20
  %24 = add nuw nsw i64 %20, 1
  %25 = add i64 %22, 1
  %26 = icmp eq i64 %25, %10
  br i1 %26, label %27, label %19, !llvm.loop !9

27:                                               ; preds = %14, %19, %0
  %28 = phi i64 [ 1, %0 ], [ %15, %14 ], [ %23, %19 ]
  %29 = call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.1, i64 noundef %28)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %1) #3
  ret i32 0

30:                                               ; preds = %30, %12
  %31 = phi i64 [ 1, %12 ], [ %49, %30 ]
  %32 = phi i64 [ 1, %12 ], [ %48, %30 ]
  %33 = phi i64 [ 0, %12 ], [ %50, %30 ]
  %34 = mul i64 %32, %31
  %35 = add nuw nsw i64 %31, 1
  %36 = mul i64 %34, %35
  %37 = add nuw nsw i64 %31, 2
  %38 = mul i64 %36, %37
  %39 = add nuw nsw i64 %31, 3
  %40 = mul i64 %38, %39
  %41 = add nuw nsw i64 %31, 4
  %42 = mul i64 %40, %41
  %43 = add nuw nsw i64 %31, 5
  %44 = mul i64 %42, %43
  %45 = add nuw nsw i64 %31, 6
  %46 = mul i64 %44, %45
  %47 = add nuw nsw i64 %31, 7
  %48 = mul i64 %46, %47
  %49 = add nuw nsw i64 %31, 8
  %50 = add i64 %33, 8
  %51 = icmp eq i64 %50, %13
  br i1 %51, label %14, label %30, !llvm.loop !11
}
*** IR Dump After Lower AMX intrinsics (lower-amx-intrinsics) ***
; Function Attrs: nofree nounwind uwtable
define dso_local noundef i32 @main() local_unnamed_addr #0 {
  %1 = alloca i32, align 4
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %1) #3
  %2 = call i32 (ptr, ...) @__isoc99_scanf(ptr noundef nonnull @.str, ptr noundef nonnull %1)
  %3 = load i32, ptr %1, align 4, !tbaa !5
  %4 = icmp slt i32 %3, 1
  br i1 %4, label %27, label %5

5:                                                ; preds = %0
  %6 = add nuw i32 %3, 1
  %7 = zext i32 %6 to i64
  %8 = add nsw i64 %7, -1
  %9 = add nsw i64 %7, -2
  %10 = and i64 %8, 7
  %11 = icmp ult i64 %9, 7
  br i1 %11, label %14, label %12

12:                                               ; preds = %5
  %13 = and i64 %8, -8
  br label %30

14:                                               ; preds = %30, %5
  %15 = phi i64 [ undef, %5 ], [ %48, %30 ]
  %16 = phi i64 [ 1, %5 ], [ %49, %30 ]
  %17 = phi i64 [ 1, %5 ], [ %48, %30 ]
  %18 = icmp eq i64 %10, 0
  br i1 %18, label %27, label %19

19:                                               ; preds = %14, %19
  %20 = phi i64 [ %24, %19 ], [ %16, %14 ]
  %21 = phi i64 [ %23, %19 ], [ %17, %14 ]
  %22 = phi i64 [ %25, %19 ], [ 0, %14 ]
  %23 = mul i64 %21, %20
  %24 = add nuw nsw i64 %20, 1
  %25 = add i64 %22, 1
  %26 = icmp eq i64 %25, %10
  br i1 %26, label %27, label %19, !llvm.loop !9

27:                                               ; preds = %14, %19, %0
  %28 = phi i64 [ 1, %0 ], [ %15, %14 ], [ %23, %19 ]
  %29 = call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.1, i64 noundef %28)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %1) #3
  ret i32 0

30:                                               ; preds = %30, %12
  %31 = phi i64 [ 1, %12 ], [ %49, %30 ]
  %32 = phi i64 [ 1, %12 ], [ %48, %30 ]
  %33 = phi i64 [ 0, %12 ], [ %50, %30 ]
  %34 = mul i64 %32, %31
  %35 = add nuw nsw i64 %31, 1
  %36 = mul i64 %34, %35
  %37 = add nuw nsw i64 %31, 2
  %38 = mul i64 %36, %37
  %39 = add nuw nsw i64 %31, 3
  %40 = mul i64 %38, %39
  %41 = add nuw nsw i64 %31, 4
  %42 = mul i64 %40, %41
  %43 = add nuw nsw i64 %31, 5
  %44 = mul i64 %42, %43
  %45 = add nuw nsw i64 %31, 6
  %46 = mul i64 %44, %45
  %47 = add nuw nsw i64 %31, 7
  %48 = mul i64 %46, %47
  %49 = add nuw nsw i64 %31, 8
  %50 = add i64 %33, 8
  %51 = icmp eq i64 %50, %13
  br i1 %51, label %14, label %30, !llvm.loop !11
}
*** IR Dump After Lower AMX type for load/store (lower-amx-type) ***
; Function Attrs: nofree nounwind uwtable
define dso_local noundef i32 @main() local_unnamed_addr #0 {
  %1 = alloca i32, align 4
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %1) #3
  %2 = call i32 (ptr, ...) @__isoc99_scanf(ptr noundef nonnull @.str, ptr noundef nonnull %1)
  %3 = load i32, ptr %1, align 4, !tbaa !5
  %4 = icmp slt i32 %3, 1
  br i1 %4, label %27, label %5

5:                                                ; preds = %0
  %6 = add nuw i32 %3, 1
  %7 = zext i32 %6 to i64
  %8 = add nsw i64 %7, -1
  %9 = add nsw i64 %7, -2
  %10 = and i64 %8, 7
  %11 = icmp ult i64 %9, 7
  br i1 %11, label %14, label %12

12:                                               ; preds = %5
  %13 = and i64 %8, -8
  br label %30

14:                                               ; preds = %30, %5
  %15 = phi i64 [ undef, %5 ], [ %48, %30 ]
  %16 = phi i64 [ 1, %5 ], [ %49, %30 ]
  %17 = phi i64 [ 1, %5 ], [ %48, %30 ]
  %18 = icmp eq i64 %10, 0
  br i1 %18, label %27, label %19

19:                                               ; preds = %14, %19
  %20 = phi i64 [ %24, %19 ], [ %16, %14 ]
  %21 = phi i64 [ %23, %19 ], [ %17, %14 ]
  %22 = phi i64 [ %25, %19 ], [ 0, %14 ]
  %23 = mul i64 %21, %20
  %24 = add nuw nsw i64 %20, 1
  %25 = add i64 %22, 1
  %26 = icmp eq i64 %25, %10
  br i1 %26, label %27, label %19, !llvm.loop !9

27:                                               ; preds = %14, %19, %0
  %28 = phi i64 [ 1, %0 ], [ %15, %14 ], [ %23, %19 ]
  %29 = call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.1, i64 noundef %28)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %1) #3
  ret i32 0

30:                                               ; preds = %30, %12
  %31 = phi i64 [ 1, %12 ], [ %49, %30 ]
  %32 = phi i64 [ 1, %12 ], [ %48, %30 ]
  %33 = phi i64 [ 0, %12 ], [ %50, %30 ]
  %34 = mul i64 %32, %31
  %35 = add nuw nsw i64 %31, 1
  %36 = mul i64 %34, %35
  %37 = add nuw nsw i64 %31, 2
  %38 = mul i64 %36, %37
  %39 = add nuw nsw i64 %31, 3
  %40 = mul i64 %38, %39
  %41 = add nuw nsw i64 %31, 4
  %42 = mul i64 %40, %41
  %43 = add nuw nsw i64 %31, 5
  %44 = mul i64 %42, %43
  %45 = add nuw nsw i64 %31, 6
  %46 = mul i64 %44, %45
  %47 = add nuw nsw i64 %31, 7
  %48 = mul i64 %46, %47
  %49 = add nuw nsw i64 %31, 8
  %50 = add i64 %33, 8
  %51 = icmp eq i64 %50, %13
  br i1 %51, label %14, label %30, !llvm.loop !11
}
*** IR Dump After Canonicalize natural loops (loop-simplify) ***
; Function Attrs: nofree nounwind uwtable
define dso_local noundef i32 @main() local_unnamed_addr #0 {
  %1 = alloca i32, align 4
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %1) #3
  %2 = call i32 (ptr, ...) @__isoc99_scanf(ptr noundef nonnull @.str, ptr noundef nonnull %1)
  %3 = load i32, ptr %1, align 4, !tbaa !5
  %4 = icmp slt i32 %3, 1
  br i1 %4, label %30, label %5

5:                                                ; preds = %0
  %6 = add nuw i32 %3, 1
  %7 = zext i32 %6 to i64
  %8 = add nsw i64 %7, -1
  %9 = add nsw i64 %7, -2
  %10 = and i64 %8, 7
  %11 = icmp ult i64 %9, 7
  br i1 %11, label %15, label %12

12:                                               ; preds = %5
  %13 = and i64 %8, -8
  br label %33

14:                                               ; preds = %33
  br label %15

15:                                               ; preds = %14, %5
  %16 = phi i64 [ undef, %5 ], [ %51, %14 ]
  %17 = phi i64 [ 1, %5 ], [ %52, %14 ]
  %18 = phi i64 [ 1, %5 ], [ %51, %14 ]
  %19 = icmp eq i64 %10, 0
  br i1 %19, label %30, label %20

20:                                               ; preds = %15
  br label %21

21:                                               ; preds = %20, %21
  %22 = phi i64 [ %26, %21 ], [ %17, %20 ]
  %23 = phi i64 [ %25, %21 ], [ %18, %20 ]
  %24 = phi i64 [ %27, %21 ], [ 0, %20 ]
  %25 = mul i64 %23, %22
  %26 = add nuw nsw i64 %22, 1
  %27 = add i64 %24, 1
  %28 = icmp eq i64 %27, %10
  br i1 %28, label %29, label %21, !llvm.loop !9

29:                                               ; preds = %21
  br label %30

30:                                               ; preds = %29, %15, %0
  %31 = phi i64 [ 1, %0 ], [ %16, %15 ], [ %25, %29 ]
  %32 = call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.1, i64 noundef %31)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %1) #3
  ret i32 0

33:                                               ; preds = %33, %12
  %34 = phi i64 [ 1, %12 ], [ %52, %33 ]
  %35 = phi i64 [ 1, %12 ], [ %51, %33 ]
  %36 = phi i64 [ 0, %12 ], [ %53, %33 ]
  %37 = mul i64 %35, %34
  %38 = add nuw nsw i64 %34, 1
  %39 = mul i64 %37, %38
  %40 = add nuw nsw i64 %34, 2
  %41 = mul i64 %39, %40
  %42 = add nuw nsw i64 %34, 3
  %43 = mul i64 %41, %42
  %44 = add nuw nsw i64 %34, 4
  %45 = mul i64 %43, %44
  %46 = add nuw nsw i64 %34, 5
  %47 = mul i64 %45, %46
  %48 = add nuw nsw i64 %34, 6
  %49 = mul i64 %47, %48
  %50 = add nuw nsw i64 %34, 7
  %51 = mul i64 %49, %50
  %52 = add nuw nsw i64 %34, 8
  %53 = add i64 %36, 8
  %54 = icmp eq i64 %53, %13
  br i1 %54, label %14, label %33, !llvm.loop !11
}
*** IR Dump After Canonicalize Freeze Instructions in Loops (canon-freeze) ***
; Preheader:
20:                                               ; preds = %15
  br label %21

; Loop:
21:                                               ; preds = %20, %21
  %22 = phi i64 [ %26, %21 ], [ %17, %20 ]
  %23 = phi i64 [ %25, %21 ], [ %18, %20 ]
  %24 = phi i64 [ %27, %21 ], [ 0, %20 ]
  %25 = mul i64 %23, %22
  %26 = add nuw nsw i64 %22, 1
  %27 = add i64 %24, 1
  %28 = icmp eq i64 %27, %10
  br i1 %28, label %29, label %21, !llvm.loop !9

; Exit blocks
29:                                               ; preds = %21
  br label %30
*** IR Dump After Loop Strength Reduction (loop-reduce) ***
; Preheader:
20:                                               ; preds = %15
  br label %21

; Loop:
21:                                               ; preds = %20, %21
  %22 = phi i64 [ %10, %20 ], [ %27, %21 ]
  %23 = phi i64 [ %26, %21 ], [ %17, %20 ]
  %24 = phi i64 [ %25, %21 ], [ %18, %20 ]
  %25 = mul i64 %24, %23
  %26 = add nuw nsw i64 %23, 1
  %27 = add nsw i64 %22, -1
  %28 = icmp eq i64 %27, 0
  br i1 %28, label %29, label %21, !llvm.loop !9

; Exit blocks
29:                                               ; preds = %21
  br label %30
*** IR Dump After Canonicalize Freeze Instructions in Loops (canon-freeze) ***
; Preheader:
12:                                               ; preds = %5
  %13 = and i64 %8, -8
  br label %33

; Loop:
33:                                               ; preds = %33, %12
  %34 = phi i64 [ 1, %12 ], [ %52, %33 ]
  %35 = phi i64 [ 1, %12 ], [ %51, %33 ]
  %36 = phi i64 [ 0, %12 ], [ %53, %33 ]
  %37 = mul i64 %35, %34
  %38 = add nuw nsw i64 %34, 1
  %39 = mul i64 %37, %38
  %40 = add nuw nsw i64 %34, 2
  %41 = mul i64 %39, %40
  %42 = add nuw nsw i64 %34, 3
  %43 = mul i64 %41, %42
  %44 = add nuw nsw i64 %34, 4
  %45 = mul i64 %43, %44
  %46 = add nuw nsw i64 %34, 5
  %47 = mul i64 %45, %46
  %48 = add nuw nsw i64 %34, 6
  %49 = mul i64 %47, %48
  %50 = add nuw nsw i64 %34, 7
  %51 = mul i64 %49, %50
  %52 = add nuw nsw i64 %34, 8
  %53 = add i64 %36, 8
  %54 = icmp eq i64 %53, %13
  br i1 %54, label %14, label %33, !llvm.loop !11

; Exit blocks
14:                                               ; preds = %33
  br label %15
*** IR Dump After Loop Strength Reduction (loop-reduce) ***
; Preheader:
12:                                               ; preds = %5
  %13 = lshr i64 %8, 3
  %14 = mul i64 %13, -8
  br label %35

; Loop:
35:                                               ; preds = %35, %12
  %36 = phi i64 [ %53, %35 ], [ 8, %12 ]
  %37 = phi i64 [ 1, %12 ], [ %52, %35 ]
  %38 = add i64 %36, -7
  %39 = mul i64 %37, %38
  %40 = add i64 %36, -6
  %41 = mul i64 %39, %40
  %42 = add i64 %36, -5
  %43 = mul i64 %41, %42
  %44 = add i64 %36, -4
  %45 = mul i64 %43, %44
  %46 = add i64 %36, -3
  %47 = mul i64 %45, %46
  %48 = add i64 %36, -2
  %49 = mul i64 %47, %48
  %50 = add i64 %36, -1
  %51 = mul i64 %49, %50
  %52 = mul i64 %51, %36
  %53 = add i64 %36, 8
  %54 = add i64 %14, %53
  %55 = icmp eq i64 %54, 8
  br i1 %55, label %15, label %35, !llvm.loop !11

; Exit blocks
15:                                               ; preds = %35
  %16 = add i64 %53, -7
  br label %17
*** IR Dump After Merge contiguous icmps into a memcmp (mergeicmps) ***
; Function Attrs: nofree nounwind uwtable
define dso_local noundef i32 @main() local_unnamed_addr #0 {
  %1 = alloca i32, align 4
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %1) #3
  %2 = call i32 (ptr, ...) @__isoc99_scanf(ptr noundef nonnull @.str, ptr noundef nonnull %1)
  %3 = load i32, ptr %1, align 4, !tbaa !5
  %4 = icmp slt i32 %3, 1
  br i1 %4, label %32, label %5

5:                                                ; preds = %0
  %6 = add nuw i32 %3, 1
  %7 = zext i32 %6 to i64
  %8 = add nsw i64 %7, -1
  %9 = add nsw i64 %7, -2
  %10 = and i64 %8, 7
  %11 = icmp ult i64 %9, 7
  br i1 %11, label %17, label %12

12:                                               ; preds = %5
  %13 = lshr i64 %8, 3
  %14 = mul i64 %13, -8
  br label %35

15:                                               ; preds = %35
  %16 = add i64 %53, -7
  br label %17

17:                                               ; preds = %15, %5
  %18 = phi i64 [ undef, %5 ], [ %52, %15 ]
  %19 = phi i64 [ 1, %5 ], [ %16, %15 ]
  %20 = phi i64 [ 1, %5 ], [ %52, %15 ]
  %21 = icmp eq i64 %10, 0
  br i1 %21, label %32, label %22

22:                                               ; preds = %17
  br label %23

23:                                               ; preds = %22, %23
  %24 = phi i64 [ %10, %22 ], [ %29, %23 ]
  %25 = phi i64 [ %28, %23 ], [ %19, %22 ]
  %26 = phi i64 [ %27, %23 ], [ %20, %22 ]
  %27 = mul i64 %26, %25
  %28 = add nuw nsw i64 %25, 1
  %29 = add nsw i64 %24, -1
  %30 = icmp eq i64 %29, 0
  br i1 %30, label %31, label %23, !llvm.loop !9

31:                                               ; preds = %23
  br label %32

32:                                               ; preds = %31, %17, %0
  %33 = phi i64 [ 1, %0 ], [ %18, %17 ], [ %27, %31 ]
  %34 = call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.1, i64 noundef %33)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %1) #3
  ret i32 0

35:                                               ; preds = %35, %12
  %36 = phi i64 [ %53, %35 ], [ 8, %12 ]
  %37 = phi i64 [ 1, %12 ], [ %52, %35 ]
  %38 = add i64 %36, -7
  %39 = mul i64 %37, %38
  %40 = add i64 %36, -6
  %41 = mul i64 %39, %40
  %42 = add i64 %36, -5
  %43 = mul i64 %41, %42
  %44 = add i64 %36, -4
  %45 = mul i64 %43, %44
  %46 = add i64 %36, -3
  %47 = mul i64 %45, %46
  %48 = add i64 %36, -2
  %49 = mul i64 %47, %48
  %50 = add i64 %36, -1
  %51 = mul i64 %49, %50
  %52 = mul i64 %51, %36
  %53 = add i64 %36, 8
  %54 = add i64 %14, %53
  %55 = icmp eq i64 %54, 8
  br i1 %55, label %15, label %35, !llvm.loop !11
}
*** IR Dump After Expand memcmp() to load/stores (expand-memcmp) ***
; Function Attrs: nofree nounwind uwtable
define dso_local noundef i32 @main() local_unnamed_addr #0 {
  %1 = alloca i32, align 4
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %1) #3
  %2 = call i32 (ptr, ...) @__isoc99_scanf(ptr noundef nonnull @.str, ptr noundef nonnull %1)
  %3 = load i32, ptr %1, align 4, !tbaa !5
  %4 = icmp slt i32 %3, 1
  br i1 %4, label %32, label %5

5:                                                ; preds = %0
  %6 = add nuw i32 %3, 1
  %7 = zext i32 %6 to i64
  %8 = add nsw i64 %7, -1
  %9 = add nsw i64 %7, -2
  %10 = and i64 %8, 7
  %11 = icmp ult i64 %9, 7
  br i1 %11, label %17, label %12

12:                                               ; preds = %5
  %13 = lshr i64 %8, 3
  %14 = mul i64 %13, -8
  br label %35

15:                                               ; preds = %35
  %16 = add i64 %53, -7
  br label %17

17:                                               ; preds = %15, %5
  %18 = phi i64 [ undef, %5 ], [ %52, %15 ]
  %19 = phi i64 [ 1, %5 ], [ %16, %15 ]
  %20 = phi i64 [ 1, %5 ], [ %52, %15 ]
  %21 = icmp eq i64 %10, 0
  br i1 %21, label %32, label %22

22:                                               ; preds = %17
  br label %23

23:                                               ; preds = %22, %23
  %24 = phi i64 [ %10, %22 ], [ %29, %23 ]
  %25 = phi i64 [ %28, %23 ], [ %19, %22 ]
  %26 = phi i64 [ %27, %23 ], [ %20, %22 ]
  %27 = mul i64 %26, %25
  %28 = add nuw nsw i64 %25, 1
  %29 = add nsw i64 %24, -1
  %30 = icmp eq i64 %29, 0
  br i1 %30, label %31, label %23, !llvm.loop !9

31:                                               ; preds = %23
  br label %32

32:                                               ; preds = %31, %17, %0
  %33 = phi i64 [ 1, %0 ], [ %18, %17 ], [ %27, %31 ]
  %34 = call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.1, i64 noundef %33)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %1) #3
  ret i32 0

35:                                               ; preds = %35, %12
  %36 = phi i64 [ %53, %35 ], [ 8, %12 ]
  %37 = phi i64 [ 1, %12 ], [ %52, %35 ]
  %38 = add i64 %36, -7
  %39 = mul i64 %37, %38
  %40 = add i64 %36, -6
  %41 = mul i64 %39, %40
  %42 = add i64 %36, -5
  %43 = mul i64 %41, %42
  %44 = add i64 %36, -4
  %45 = mul i64 %43, %44
  %46 = add i64 %36, -3
  %47 = mul i64 %45, %46
  %48 = add i64 %36, -2
  %49 = mul i64 %47, %48
  %50 = add i64 %36, -1
  %51 = mul i64 %49, %50
  %52 = mul i64 %51, %36
  %53 = add i64 %36, 8
  %54 = add i64 %14, %53
  %55 = icmp eq i64 %54, 8
  br i1 %55, label %15, label %35, !llvm.loop !11
}
*** IR Dump After Lower Garbage Collection Instructions (gc-lowering) ***
; Function Attrs: nofree nounwind uwtable
define dso_local noundef i32 @main() local_unnamed_addr #0 {
  %1 = alloca i32, align 4
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %1) #3
  %2 = call i32 (ptr, ...) @__isoc99_scanf(ptr noundef nonnull @.str, ptr noundef nonnull %1)
  %3 = load i32, ptr %1, align 4, !tbaa !5
  %4 = icmp slt i32 %3, 1
  br i1 %4, label %32, label %5

5:                                                ; preds = %0
  %6 = add nuw i32 %3, 1
  %7 = zext i32 %6 to i64
  %8 = add nsw i64 %7, -1
  %9 = add nsw i64 %7, -2
  %10 = and i64 %8, 7
  %11 = icmp ult i64 %9, 7
  br i1 %11, label %17, label %12

12:                                               ; preds = %5
  %13 = lshr i64 %8, 3
  %14 = mul i64 %13, -8
  br label %35

15:                                               ; preds = %35
  %16 = add i64 %53, -7
  br label %17

17:                                               ; preds = %15, %5
  %18 = phi i64 [ undef, %5 ], [ %52, %15 ]
  %19 = phi i64 [ 1, %5 ], [ %16, %15 ]
  %20 = phi i64 [ 1, %5 ], [ %52, %15 ]
  %21 = icmp eq i64 %10, 0
  br i1 %21, label %32, label %22

22:                                               ; preds = %17
  br label %23

23:                                               ; preds = %22, %23
  %24 = phi i64 [ %10, %22 ], [ %29, %23 ]
  %25 = phi i64 [ %28, %23 ], [ %19, %22 ]
  %26 = phi i64 [ %27, %23 ], [ %20, %22 ]
  %27 = mul i64 %26, %25
  %28 = add nuw nsw i64 %25, 1
  %29 = add nsw i64 %24, -1
  %30 = icmp eq i64 %29, 0
  br i1 %30, label %31, label %23, !llvm.loop !9

31:                                               ; preds = %23
  br label %32

32:                                               ; preds = %31, %17, %0
  %33 = phi i64 [ 1, %0 ], [ %18, %17 ], [ %27, %31 ]
  %34 = call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.1, i64 noundef %33)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %1) #3
  ret i32 0

35:                                               ; preds = %35, %12
  %36 = phi i64 [ %53, %35 ], [ 8, %12 ]
  %37 = phi i64 [ 1, %12 ], [ %52, %35 ]
  %38 = add i64 %36, -7
  %39 = mul i64 %37, %38
  %40 = add i64 %36, -6
  %41 = mul i64 %39, %40
  %42 = add i64 %36, -5
  %43 = mul i64 %41, %42
  %44 = add i64 %36, -4
  %45 = mul i64 %43, %44
  %46 = add i64 %36, -3
  %47 = mul i64 %45, %46
  %48 = add i64 %36, -2
  %49 = mul i64 %47, %48
  %50 = add i64 %36, -1
  %51 = mul i64 %49, %50
  %52 = mul i64 %51, %36
  %53 = add i64 %36, 8
  %54 = add i64 %14, %53
  %55 = icmp eq i64 %54, 8
  br i1 %55, label %15, label %35, !llvm.loop !11
}
*** IR Dump After Shadow Stack GC Lowering (shadow-stack-gc-lowering) ***
; Function Attrs: nofree nounwind uwtable
define dso_local noundef i32 @main() local_unnamed_addr #0 {
  %1 = alloca i32, align 4
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %1) #3
  %2 = call i32 (ptr, ...) @__isoc99_scanf(ptr noundef nonnull @.str, ptr noundef nonnull %1)
  %3 = load i32, ptr %1, align 4, !tbaa !5
  %4 = icmp slt i32 %3, 1
  br i1 %4, label %32, label %5

5:                                                ; preds = %0
  %6 = add nuw i32 %3, 1
  %7 = zext i32 %6 to i64
  %8 = add nsw i64 %7, -1
  %9 = add nsw i64 %7, -2
  %10 = and i64 %8, 7
  %11 = icmp ult i64 %9, 7
  br i1 %11, label %17, label %12

12:                                               ; preds = %5
  %13 = lshr i64 %8, 3
  %14 = mul i64 %13, -8
  br label %35

15:                                               ; preds = %35
  %16 = add i64 %53, -7
  br label %17

17:                                               ; preds = %15, %5
  %18 = phi i64 [ undef, %5 ], [ %52, %15 ]
  %19 = phi i64 [ 1, %5 ], [ %16, %15 ]
  %20 = phi i64 [ 1, %5 ], [ %52, %15 ]
  %21 = icmp eq i64 %10, 0
  br i1 %21, label %32, label %22

22:                                               ; preds = %17
  br label %23

23:                                               ; preds = %22, %23
  %24 = phi i64 [ %10, %22 ], [ %29, %23 ]
  %25 = phi i64 [ %28, %23 ], [ %19, %22 ]
  %26 = phi i64 [ %27, %23 ], [ %20, %22 ]
  %27 = mul i64 %26, %25
  %28 = add nuw nsw i64 %25, 1
  %29 = add nsw i64 %24, -1
  %30 = icmp eq i64 %29, 0
  br i1 %30, label %31, label %23, !llvm.loop !9

31:                                               ; preds = %23
  br label %32

32:                                               ; preds = %31, %17, %0
  %33 = phi i64 [ 1, %0 ], [ %18, %17 ], [ %27, %31 ]
  %34 = call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.1, i64 noundef %33)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %1) #3
  ret i32 0

35:                                               ; preds = %35, %12
  %36 = phi i64 [ %53, %35 ], [ 8, %12 ]
  %37 = phi i64 [ 1, %12 ], [ %52, %35 ]
  %38 = add i64 %36, -7
  %39 = mul i64 %37, %38
  %40 = add i64 %36, -6
  %41 = mul i64 %39, %40
  %42 = add i64 %36, -5
  %43 = mul i64 %41, %42
  %44 = add i64 %36, -4
  %45 = mul i64 %43, %44
  %46 = add i64 %36, -3
  %47 = mul i64 %45, %46
  %48 = add i64 %36, -2
  %49 = mul i64 %47, %48
  %50 = add i64 %36, -1
  %51 = mul i64 %49, %50
  %52 = mul i64 %51, %36
  %53 = add i64 %36, 8
  %54 = add i64 %14, %53
  %55 = icmp eq i64 %54, 8
  br i1 %55, label %15, label %35, !llvm.loop !11
}
*** IR Dump After Lower constant intrinsics (lower-constant-intrinsics) ***
; Function Attrs: nofree nounwind uwtable
define dso_local noundef i32 @main() local_unnamed_addr #0 {
  %1 = alloca i32, align 4
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %1) #3
  %2 = call i32 (ptr, ...) @__isoc99_scanf(ptr noundef nonnull @.str, ptr noundef nonnull %1)
  %3 = load i32, ptr %1, align 4, !tbaa !5
  %4 = icmp slt i32 %3, 1
  br i1 %4, label %32, label %5

5:                                                ; preds = %0
  %6 = add nuw i32 %3, 1
  %7 = zext i32 %6 to i64
  %8 = add nsw i64 %7, -1
  %9 = add nsw i64 %7, -2
  %10 = and i64 %8, 7
  %11 = icmp ult i64 %9, 7
  br i1 %11, label %17, label %12

12:                                               ; preds = %5
  %13 = lshr i64 %8, 3
  %14 = mul i64 %13, -8
  br label %35

15:                                               ; preds = %35
  %16 = add i64 %53, -7
  br label %17

17:                                               ; preds = %15, %5
  %18 = phi i64 [ undef, %5 ], [ %52, %15 ]
  %19 = phi i64 [ 1, %5 ], [ %16, %15 ]
  %20 = phi i64 [ 1, %5 ], [ %52, %15 ]
  %21 = icmp eq i64 %10, 0
  br i1 %21, label %32, label %22

22:                                               ; preds = %17
  br label %23

23:                                               ; preds = %22, %23
  %24 = phi i64 [ %10, %22 ], [ %29, %23 ]
  %25 = phi i64 [ %28, %23 ], [ %19, %22 ]
  %26 = phi i64 [ %27, %23 ], [ %20, %22 ]
  %27 = mul i64 %26, %25
  %28 = add nuw nsw i64 %25, 1
  %29 = add nsw i64 %24, -1
  %30 = icmp eq i64 %29, 0
  br i1 %30, label %31, label %23, !llvm.loop !9

31:                                               ; preds = %23
  br label %32

32:                                               ; preds = %31, %17, %0
  %33 = phi i64 [ 1, %0 ], [ %18, %17 ], [ %27, %31 ]
  %34 = call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.1, i64 noundef %33)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %1) #3
  ret i32 0

35:                                               ; preds = %35, %12
  %36 = phi i64 [ %53, %35 ], [ 8, %12 ]
  %37 = phi i64 [ 1, %12 ], [ %52, %35 ]
  %38 = add i64 %36, -7
  %39 = mul i64 %37, %38
  %40 = add i64 %36, -6
  %41 = mul i64 %39, %40
  %42 = add i64 %36, -5
  %43 = mul i64 %41, %42
  %44 = add i64 %36, -4
  %45 = mul i64 %43, %44
  %46 = add i64 %36, -3
  %47 = mul i64 %45, %46
  %48 = add i64 %36, -2
  %49 = mul i64 %47, %48
  %50 = add i64 %36, -1
  %51 = mul i64 %49, %50
  %52 = mul i64 %51, %36
  %53 = add i64 %36, 8
  %54 = add i64 %14, %53
  %55 = icmp eq i64 %54, 8
  br i1 %55, label %15, label %35, !llvm.loop !11
}
*** IR Dump After Remove unreachable blocks from the CFG (unreachableblockelim) ***
; Function Attrs: nofree nounwind uwtable
define dso_local noundef i32 @main() local_unnamed_addr #0 {
  %1 = alloca i32, align 4
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %1) #3
  %2 = call i32 (ptr, ...) @__isoc99_scanf(ptr noundef nonnull @.str, ptr noundef nonnull %1)
  %3 = load i32, ptr %1, align 4, !tbaa !5
  %4 = icmp slt i32 %3, 1
  br i1 %4, label %32, label %5

5:                                                ; preds = %0
  %6 = add nuw i32 %3, 1
  %7 = zext i32 %6 to i64
  %8 = add nsw i64 %7, -1
  %9 = add nsw i64 %7, -2
  %10 = and i64 %8, 7
  %11 = icmp ult i64 %9, 7
  br i1 %11, label %17, label %12

12:                                               ; preds = %5
  %13 = lshr i64 %8, 3
  %14 = mul i64 %13, -8
  br label %35

15:                                               ; preds = %35
  %16 = add i64 %53, -7
  br label %17

17:                                               ; preds = %15, %5
  %18 = phi i64 [ undef, %5 ], [ %52, %15 ]
  %19 = phi i64 [ 1, %5 ], [ %16, %15 ]
  %20 = phi i64 [ 1, %5 ], [ %52, %15 ]
  %21 = icmp eq i64 %10, 0
  br i1 %21, label %32, label %22

22:                                               ; preds = %17
  br label %23

23:                                               ; preds = %22, %23
  %24 = phi i64 [ %10, %22 ], [ %29, %23 ]
  %25 = phi i64 [ %28, %23 ], [ %19, %22 ]
  %26 = phi i64 [ %27, %23 ], [ %20, %22 ]
  %27 = mul i64 %26, %25
  %28 = add nuw nsw i64 %25, 1
  %29 = add nsw i64 %24, -1
  %30 = icmp eq i64 %29, 0
  br i1 %30, label %31, label %23, !llvm.loop !9

31:                                               ; preds = %23
  br label %32

32:                                               ; preds = %31, %17, %0
  %33 = phi i64 [ 1, %0 ], [ %18, %17 ], [ %27, %31 ]
  %34 = call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.1, i64 noundef %33)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %1) #3
  ret i32 0

35:                                               ; preds = %35, %12
  %36 = phi i64 [ %53, %35 ], [ 8, %12 ]
  %37 = phi i64 [ 1, %12 ], [ %52, %35 ]
  %38 = add i64 %36, -7
  %39 = mul i64 %37, %38
  %40 = add i64 %36, -6
  %41 = mul i64 %39, %40
  %42 = add i64 %36, -5
  %43 = mul i64 %41, %42
  %44 = add i64 %36, -4
  %45 = mul i64 %43, %44
  %46 = add i64 %36, -3
  %47 = mul i64 %45, %46
  %48 = add i64 %36, -2
  %49 = mul i64 %47, %48
  %50 = add i64 %36, -1
  %51 = mul i64 %49, %50
  %52 = mul i64 %51, %36
  %53 = add i64 %36, 8
  %54 = add i64 %14, %53
  %55 = icmp eq i64 %54, 8
  br i1 %55, label %15, label %35, !llvm.loop !11
}
*** IR Dump After Constant Hoisting (consthoist) ***
; Function Attrs: nofree nounwind uwtable
define dso_local noundef i32 @main() local_unnamed_addr #0 {
  %1 = alloca i32, align 4
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %1) #3
  %2 = call i32 (ptr, ...) @__isoc99_scanf(ptr noundef nonnull @.str, ptr noundef nonnull %1)
  %3 = load i32, ptr %1, align 4, !tbaa !5
  %4 = icmp slt i32 %3, 1
  br i1 %4, label %32, label %5

5:                                                ; preds = %0
  %6 = add nuw i32 %3, 1
  %7 = zext i32 %6 to i64
  %8 = add nsw i64 %7, -1
  %9 = add nsw i64 %7, -2
  %10 = and i64 %8, 7
  %11 = icmp ult i64 %9, 7
  br i1 %11, label %17, label %12

12:                                               ; preds = %5
  %13 = lshr i64 %8, 3
  %14 = mul i64 %13, -8
  br label %35

15:                                               ; preds = %35
  %16 = add i64 %53, -7
  br label %17

17:                                               ; preds = %15, %5
  %18 = phi i64 [ undef, %5 ], [ %52, %15 ]
  %19 = phi i64 [ 1, %5 ], [ %16, %15 ]
  %20 = phi i64 [ 1, %5 ], [ %52, %15 ]
  %21 = icmp eq i64 %10, 0
  br i1 %21, label %32, label %22

22:                                               ; preds = %17
  br label %23

23:                                               ; preds = %22, %23
  %24 = phi i64 [ %10, %22 ], [ %29, %23 ]
  %25 = phi i64 [ %28, %23 ], [ %19, %22 ]
  %26 = phi i64 [ %27, %23 ], [ %20, %22 ]
  %27 = mul i64 %26, %25
  %28 = add nuw nsw i64 %25, 1
  %29 = add nsw i64 %24, -1
  %30 = icmp eq i64 %29, 0
  br i1 %30, label %31, label %23, !llvm.loop !9

31:                                               ; preds = %23
  br label %32

32:                                               ; preds = %31, %17, %0
  %33 = phi i64 [ 1, %0 ], [ %18, %17 ], [ %27, %31 ]
  %34 = call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.1, i64 noundef %33)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %1) #3
  ret i32 0

35:                                               ; preds = %35, %12
  %36 = phi i64 [ %53, %35 ], [ 8, %12 ]
  %37 = phi i64 [ 1, %12 ], [ %52, %35 ]
  %38 = add i64 %36, -7
  %39 = mul i64 %37, %38
  %40 = add i64 %36, -6
  %41 = mul i64 %39, %40
  %42 = add i64 %36, -5
  %43 = mul i64 %41, %42
  %44 = add i64 %36, -4
  %45 = mul i64 %43, %44
  %46 = add i64 %36, -3
  %47 = mul i64 %45, %46
  %48 = add i64 %36, -2
  %49 = mul i64 %47, %48
  %50 = add i64 %36, -1
  %51 = mul i64 %49, %50
  %52 = mul i64 %51, %36
  %53 = add i64 %36, 8
  %54 = add i64 %14, %53
  %55 = icmp eq i64 %54, 8
  br i1 %55, label %15, label %35, !llvm.loop !11
}
*** IR Dump After Replace intrinsics with calls to vector library (replace-with-veclib) ***
; Function Attrs: nofree nounwind uwtable
define dso_local noundef i32 @main() local_unnamed_addr #0 {
  %1 = alloca i32, align 4
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %1) #3
  %2 = call i32 (ptr, ...) @__isoc99_scanf(ptr noundef nonnull @.str, ptr noundef nonnull %1)
  %3 = load i32, ptr %1, align 4, !tbaa !5
  %4 = icmp slt i32 %3, 1
  br i1 %4, label %32, label %5

5:                                                ; preds = %0
  %6 = add nuw i32 %3, 1
  %7 = zext i32 %6 to i64
  %8 = add nsw i64 %7, -1
  %9 = add nsw i64 %7, -2
  %10 = and i64 %8, 7
  %11 = icmp ult i64 %9, 7
  br i1 %11, label %17, label %12

12:                                               ; preds = %5
  %13 = lshr i64 %8, 3
  %14 = mul i64 %13, -8
  br label %35

15:                                               ; preds = %35
  %16 = add i64 %53, -7
  br label %17

17:                                               ; preds = %15, %5
  %18 = phi i64 [ undef, %5 ], [ %52, %15 ]
  %19 = phi i64 [ 1, %5 ], [ %16, %15 ]
  %20 = phi i64 [ 1, %5 ], [ %52, %15 ]
  %21 = icmp eq i64 %10, 0
  br i1 %21, label %32, label %22

22:                                               ; preds = %17
  br label %23

23:                                               ; preds = %22, %23
  %24 = phi i64 [ %10, %22 ], [ %29, %23 ]
  %25 = phi i64 [ %28, %23 ], [ %19, %22 ]
  %26 = phi i64 [ %27, %23 ], [ %20, %22 ]
  %27 = mul i64 %26, %25
  %28 = add nuw nsw i64 %25, 1
  %29 = add nsw i64 %24, -1
  %30 = icmp eq i64 %29, 0
  br i1 %30, label %31, label %23, !llvm.loop !9

31:                                               ; preds = %23
  br label %32

32:                                               ; preds = %31, %17, %0
  %33 = phi i64 [ 1, %0 ], [ %18, %17 ], [ %27, %31 ]
  %34 = call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.1, i64 noundef %33)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %1) #3
  ret i32 0

35:                                               ; preds = %35, %12
  %36 = phi i64 [ %53, %35 ], [ 8, %12 ]
  %37 = phi i64 [ 1, %12 ], [ %52, %35 ]
  %38 = add i64 %36, -7
  %39 = mul i64 %37, %38
  %40 = add i64 %36, -6
  %41 = mul i64 %39, %40
  %42 = add i64 %36, -5
  %43 = mul i64 %41, %42
  %44 = add i64 %36, -4
  %45 = mul i64 %43, %44
  %46 = add i64 %36, -3
  %47 = mul i64 %45, %46
  %48 = add i64 %36, -2
  %49 = mul i64 %47, %48
  %50 = add i64 %36, -1
  %51 = mul i64 %49, %50
  %52 = mul i64 %51, %36
  %53 = add i64 %36, 8
  %54 = add i64 %14, %53
  %55 = icmp eq i64 %54, 8
  br i1 %55, label %15, label %35, !llvm.loop !11
}
*** IR Dump After Partially inline calls to library functions (partially-inline-libcalls) ***
; Function Attrs: nofree nounwind uwtable
define dso_local noundef i32 @main() local_unnamed_addr #0 {
  %1 = alloca i32, align 4
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %1) #3
  %2 = call i32 (ptr, ...) @__isoc99_scanf(ptr noundef nonnull @.str, ptr noundef nonnull %1)
  %3 = load i32, ptr %1, align 4, !tbaa !5
  %4 = icmp slt i32 %3, 1
  br i1 %4, label %32, label %5

5:                                                ; preds = %0
  %6 = add nuw i32 %3, 1
  %7 = zext i32 %6 to i64
  %8 = add nsw i64 %7, -1
  %9 = add nsw i64 %7, -2
  %10 = and i64 %8, 7
  %11 = icmp ult i64 %9, 7
  br i1 %11, label %17, label %12

12:                                               ; preds = %5
  %13 = lshr i64 %8, 3
  %14 = mul i64 %13, -8
  br label %35

15:                                               ; preds = %35
  %16 = add i64 %53, -7
  br label %17

17:                                               ; preds = %15, %5
  %18 = phi i64 [ undef, %5 ], [ %52, %15 ]
  %19 = phi i64 [ 1, %5 ], [ %16, %15 ]
  %20 = phi i64 [ 1, %5 ], [ %52, %15 ]
  %21 = icmp eq i64 %10, 0
  br i1 %21, label %32, label %22

22:                                               ; preds = %17
  br label %23

23:                                               ; preds = %22, %23
  %24 = phi i64 [ %10, %22 ], [ %29, %23 ]
  %25 = phi i64 [ %28, %23 ], [ %19, %22 ]
  %26 = phi i64 [ %27, %23 ], [ %20, %22 ]
  %27 = mul i64 %26, %25
  %28 = add nuw nsw i64 %25, 1
  %29 = add nsw i64 %24, -1
  %30 = icmp eq i64 %29, 0
  br i1 %30, label %31, label %23, !llvm.loop !9

31:                                               ; preds = %23
  br label %32

32:                                               ; preds = %31, %17, %0
  %33 = phi i64 [ 1, %0 ], [ %18, %17 ], [ %27, %31 ]
  %34 = call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.1, i64 noundef %33)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %1) #3
  ret i32 0

35:                                               ; preds = %35, %12
  %36 = phi i64 [ %53, %35 ], [ 8, %12 ]
  %37 = phi i64 [ 1, %12 ], [ %52, %35 ]
  %38 = add i64 %36, -7
  %39 = mul i64 %37, %38
  %40 = add i64 %36, -6
  %41 = mul i64 %39, %40
  %42 = add i64 %36, -5
  %43 = mul i64 %41, %42
  %44 = add i64 %36, -4
  %45 = mul i64 %43, %44
  %46 = add i64 %36, -3
  %47 = mul i64 %45, %46
  %48 = add i64 %36, -2
  %49 = mul i64 %47, %48
  %50 = add i64 %36, -1
  %51 = mul i64 %49, %50
  %52 = mul i64 %51, %36
  %53 = add i64 %36, 8
  %54 = add i64 %14, %53
  %55 = icmp eq i64 %54, 8
  br i1 %55, label %15, label %35, !llvm.loop !11
}
*** IR Dump After Expand vector predication intrinsics (expandvp) ***
; Function Attrs: nofree nounwind uwtable
define dso_local noundef i32 @main() local_unnamed_addr #0 {
  %1 = alloca i32, align 4
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %1) #3
  %2 = call i32 (ptr, ...) @__isoc99_scanf(ptr noundef nonnull @.str, ptr noundef nonnull %1)
  %3 = load i32, ptr %1, align 4, !tbaa !5
  %4 = icmp slt i32 %3, 1
  br i1 %4, label %32, label %5

5:                                                ; preds = %0
  %6 = add nuw i32 %3, 1
  %7 = zext i32 %6 to i64
  %8 = add nsw i64 %7, -1
  %9 = add nsw i64 %7, -2
  %10 = and i64 %8, 7
  %11 = icmp ult i64 %9, 7
  br i1 %11, label %17, label %12

12:                                               ; preds = %5
  %13 = lshr i64 %8, 3
  %14 = mul i64 %13, -8
  br label %35

15:                                               ; preds = %35
  %16 = add i64 %53, -7
  br label %17

17:                                               ; preds = %15, %5
  %18 = phi i64 [ undef, %5 ], [ %52, %15 ]
  %19 = phi i64 [ 1, %5 ], [ %16, %15 ]
  %20 = phi i64 [ 1, %5 ], [ %52, %15 ]
  %21 = icmp eq i64 %10, 0
  br i1 %21, label %32, label %22

22:                                               ; preds = %17
  br label %23

23:                                               ; preds = %22, %23
  %24 = phi i64 [ %10, %22 ], [ %29, %23 ]
  %25 = phi i64 [ %28, %23 ], [ %19, %22 ]
  %26 = phi i64 [ %27, %23 ], [ %20, %22 ]
  %27 = mul i64 %26, %25
  %28 = add nuw nsw i64 %25, 1
  %29 = add nsw i64 %24, -1
  %30 = icmp eq i64 %29, 0
  br i1 %30, label %31, label %23, !llvm.loop !9

31:                                               ; preds = %23
  br label %32

32:                                               ; preds = %31, %17, %0
  %33 = phi i64 [ 1, %0 ], [ %18, %17 ], [ %27, %31 ]
  %34 = call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.1, i64 noundef %33)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %1) #3
  ret i32 0

35:                                               ; preds = %35, %12
  %36 = phi i64 [ %53, %35 ], [ 8, %12 ]
  %37 = phi i64 [ 1, %12 ], [ %52, %35 ]
  %38 = add i64 %36, -7
  %39 = mul i64 %37, %38
  %40 = add i64 %36, -6
  %41 = mul i64 %39, %40
  %42 = add i64 %36, -5
  %43 = mul i64 %41, %42
  %44 = add i64 %36, -4
  %45 = mul i64 %43, %44
  %46 = add i64 %36, -3
  %47 = mul i64 %45, %46
  %48 = add i64 %36, -2
  %49 = mul i64 %47, %48
  %50 = add i64 %36, -1
  %51 = mul i64 %49, %50
  %52 = mul i64 %51, %36
  %53 = add i64 %36, 8
  %54 = add i64 %14, %53
  %55 = icmp eq i64 %54, 8
  br i1 %55, label %15, label %35, !llvm.loop !11
}
*** IR Dump After Scalarize Masked Memory Intrinsics (scalarize-masked-mem-intrin) ***
; Function Attrs: nofree nounwind uwtable
define dso_local noundef i32 @main() local_unnamed_addr #0 {
  %1 = alloca i32, align 4
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %1) #3
  %2 = call i32 (ptr, ...) @__isoc99_scanf(ptr noundef nonnull @.str, ptr noundef nonnull %1)
  %3 = load i32, ptr %1, align 4, !tbaa !5
  %4 = icmp slt i32 %3, 1
  br i1 %4, label %32, label %5

5:                                                ; preds = %0
  %6 = add nuw i32 %3, 1
  %7 = zext i32 %6 to i64
  %8 = add nsw i64 %7, -1
  %9 = add nsw i64 %7, -2
  %10 = and i64 %8, 7
  %11 = icmp ult i64 %9, 7
  br i1 %11, label %17, label %12

12:                                               ; preds = %5
  %13 = lshr i64 %8, 3
  %14 = mul i64 %13, -8
  br label %35

15:                                               ; preds = %35
  %16 = add i64 %53, -7
  br label %17

17:                                               ; preds = %15, %5
  %18 = phi i64 [ undef, %5 ], [ %52, %15 ]
  %19 = phi i64 [ 1, %5 ], [ %16, %15 ]
  %20 = phi i64 [ 1, %5 ], [ %52, %15 ]
  %21 = icmp eq i64 %10, 0
  br i1 %21, label %32, label %22

22:                                               ; preds = %17
  br label %23

23:                                               ; preds = %22, %23
  %24 = phi i64 [ %10, %22 ], [ %29, %23 ]
  %25 = phi i64 [ %28, %23 ], [ %19, %22 ]
  %26 = phi i64 [ %27, %23 ], [ %20, %22 ]
  %27 = mul i64 %26, %25
  %28 = add nuw nsw i64 %25, 1
  %29 = add nsw i64 %24, -1
  %30 = icmp eq i64 %29, 0
  br i1 %30, label %31, label %23, !llvm.loop !9

31:                                               ; preds = %23
  br label %32

32:                                               ; preds = %31, %17, %0
  %33 = phi i64 [ 1, %0 ], [ %18, %17 ], [ %27, %31 ]
  %34 = call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.1, i64 noundef %33)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %1) #3
  ret i32 0

35:                                               ; preds = %35, %12
  %36 = phi i64 [ %53, %35 ], [ 8, %12 ]
  %37 = phi i64 [ 1, %12 ], [ %52, %35 ]
  %38 = add i64 %36, -7
  %39 = mul i64 %37, %38
  %40 = add i64 %36, -6
  %41 = mul i64 %39, %40
  %42 = add i64 %36, -5
  %43 = mul i64 %41, %42
  %44 = add i64 %36, -4
  %45 = mul i64 %43, %44
  %46 = add i64 %36, -3
  %47 = mul i64 %45, %46
  %48 = add i64 %36, -2
  %49 = mul i64 %47, %48
  %50 = add i64 %36, -1
  %51 = mul i64 %49, %50
  %52 = mul i64 %51, %36
  %53 = add i64 %36, 8
  %54 = add i64 %14, %53
  %55 = icmp eq i64 %54, 8
  br i1 %55, label %15, label %35, !llvm.loop !11
}
*** IR Dump After Expand reduction intrinsics (expand-reductions) ***
; Function Attrs: nofree nounwind uwtable
define dso_local noundef i32 @main() local_unnamed_addr #0 {
  %1 = alloca i32, align 4
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %1) #3
  %2 = call i32 (ptr, ...) @__isoc99_scanf(ptr noundef nonnull @.str, ptr noundef nonnull %1)
  %3 = load i32, ptr %1, align 4, !tbaa !5
  %4 = icmp slt i32 %3, 1
  br i1 %4, label %32, label %5

5:                                                ; preds = %0
  %6 = add nuw i32 %3, 1
  %7 = zext i32 %6 to i64
  %8 = add nsw i64 %7, -1
  %9 = add nsw i64 %7, -2
  %10 = and i64 %8, 7
  %11 = icmp ult i64 %9, 7
  br i1 %11, label %17, label %12

12:                                               ; preds = %5
  %13 = lshr i64 %8, 3
  %14 = mul i64 %13, -8
  br label %35

15:                                               ; preds = %35
  %16 = add i64 %53, -7
  br label %17

17:                                               ; preds = %15, %5
  %18 = phi i64 [ undef, %5 ], [ %52, %15 ]
  %19 = phi i64 [ 1, %5 ], [ %16, %15 ]
  %20 = phi i64 [ 1, %5 ], [ %52, %15 ]
  %21 = icmp eq i64 %10, 0
  br i1 %21, label %32, label %22

22:                                               ; preds = %17
  br label %23

23:                                               ; preds = %22, %23
  %24 = phi i64 [ %10, %22 ], [ %29, %23 ]
  %25 = phi i64 [ %28, %23 ], [ %19, %22 ]
  %26 = phi i64 [ %27, %23 ], [ %20, %22 ]
  %27 = mul i64 %26, %25
  %28 = add nuw nsw i64 %25, 1
  %29 = add nsw i64 %24, -1
  %30 = icmp eq i64 %29, 0
  br i1 %30, label %31, label %23, !llvm.loop !9

31:                                               ; preds = %23
  br label %32

32:                                               ; preds = %31, %17, %0
  %33 = phi i64 [ 1, %0 ], [ %18, %17 ], [ %27, %31 ]
  %34 = call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.1, i64 noundef %33)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %1) #3
  ret i32 0

35:                                               ; preds = %35, %12
  %36 = phi i64 [ %53, %35 ], [ 8, %12 ]
  %37 = phi i64 [ 1, %12 ], [ %52, %35 ]
  %38 = add i64 %36, -7
  %39 = mul i64 %37, %38
  %40 = add i64 %36, -6
  %41 = mul i64 %39, %40
  %42 = add i64 %36, -5
  %43 = mul i64 %41, %42
  %44 = add i64 %36, -4
  %45 = mul i64 %43, %44
  %46 = add i64 %36, -3
  %47 = mul i64 %45, %46
  %48 = add i64 %36, -2
  %49 = mul i64 %47, %48
  %50 = add i64 %36, -1
  %51 = mul i64 %49, %50
  %52 = mul i64 %51, %36
  %53 = add i64 %36, 8
  %54 = add i64 %14, %53
  %55 = icmp eq i64 %54, 8
  br i1 %55, label %15, label %35, !llvm.loop !11
}
*** IR Dump After TLS Variable Hoist (tlshoist) ***
; Function Attrs: nofree nounwind uwtable
define dso_local noundef i32 @main() local_unnamed_addr #0 {
  %1 = alloca i32, align 4
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %1) #3
  %2 = call i32 (ptr, ...) @__isoc99_scanf(ptr noundef nonnull @.str, ptr noundef nonnull %1)
  %3 = load i32, ptr %1, align 4, !tbaa !5
  %4 = icmp slt i32 %3, 1
  br i1 %4, label %32, label %5

5:                                                ; preds = %0
  %6 = add nuw i32 %3, 1
  %7 = zext i32 %6 to i64
  %8 = add nsw i64 %7, -1
  %9 = add nsw i64 %7, -2
  %10 = and i64 %8, 7
  %11 = icmp ult i64 %9, 7
  br i1 %11, label %17, label %12

12:                                               ; preds = %5
  %13 = lshr i64 %8, 3
  %14 = mul i64 %13, -8
  br label %35

15:                                               ; preds = %35
  %16 = add i64 %53, -7
  br label %17

17:                                               ; preds = %15, %5
  %18 = phi i64 [ undef, %5 ], [ %52, %15 ]
  %19 = phi i64 [ 1, %5 ], [ %16, %15 ]
  %20 = phi i64 [ 1, %5 ], [ %52, %15 ]
  %21 = icmp eq i64 %10, 0
  br i1 %21, label %32, label %22

22:                                               ; preds = %17
  br label %23

23:                                               ; preds = %22, %23
  %24 = phi i64 [ %10, %22 ], [ %29, %23 ]
  %25 = phi i64 [ %28, %23 ], [ %19, %22 ]
  %26 = phi i64 [ %27, %23 ], [ %20, %22 ]
  %27 = mul i64 %26, %25
  %28 = add nuw nsw i64 %25, 1
  %29 = add nsw i64 %24, -1
  %30 = icmp eq i64 %29, 0
  br i1 %30, label %31, label %23, !llvm.loop !9

31:                                               ; preds = %23
  br label %32

32:                                               ; preds = %31, %17, %0
  %33 = phi i64 [ 1, %0 ], [ %18, %17 ], [ %27, %31 ]
  %34 = call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.1, i64 noundef %33)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %1) #3
  ret i32 0

35:                                               ; preds = %35, %12
  %36 = phi i64 [ %53, %35 ], [ 8, %12 ]
  %37 = phi i64 [ 1, %12 ], [ %52, %35 ]
  %38 = add i64 %36, -7
  %39 = mul i64 %37, %38
  %40 = add i64 %36, -6
  %41 = mul i64 %39, %40
  %42 = add i64 %36, -5
  %43 = mul i64 %41, %42
  %44 = add i64 %36, -4
  %45 = mul i64 %43, %44
  %46 = add i64 %36, -3
  %47 = mul i64 %45, %46
  %48 = add i64 %36, -2
  %49 = mul i64 %47, %48
  %50 = add i64 %36, -1
  %51 = mul i64 %49, %50
  %52 = mul i64 %51, %36
  %53 = add i64 %36, 8
  %54 = add i64 %14, %53
  %55 = icmp eq i64 %54, 8
  br i1 %55, label %15, label %35, !llvm.loop !11
}
*** IR Dump After Interleaved Access Pass (interleaved-access) ***
; Function Attrs: nofree nounwind uwtable
define dso_local noundef i32 @main() local_unnamed_addr #0 {
  %1 = alloca i32, align 4
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %1) #3
  %2 = call i32 (ptr, ...) @__isoc99_scanf(ptr noundef nonnull @.str, ptr noundef nonnull %1)
  %3 = load i32, ptr %1, align 4, !tbaa !5
  %4 = icmp slt i32 %3, 1
  br i1 %4, label %32, label %5

5:                                                ; preds = %0
  %6 = add nuw i32 %3, 1
  %7 = zext i32 %6 to i64
  %8 = add nsw i64 %7, -1
  %9 = add nsw i64 %7, -2
  %10 = and i64 %8, 7
  %11 = icmp ult i64 %9, 7
  br i1 %11, label %17, label %12

12:                                               ; preds = %5
  %13 = lshr i64 %8, 3
  %14 = mul i64 %13, -8
  br label %35

15:                                               ; preds = %35
  %16 = add i64 %53, -7
  br label %17

17:                                               ; preds = %15, %5
  %18 = phi i64 [ undef, %5 ], [ %52, %15 ]
  %19 = phi i64 [ 1, %5 ], [ %16, %15 ]
  %20 = phi i64 [ 1, %5 ], [ %52, %15 ]
  %21 = icmp eq i64 %10, 0
  br i1 %21, label %32, label %22

22:                                               ; preds = %17
  br label %23

23:                                               ; preds = %22, %23
  %24 = phi i64 [ %10, %22 ], [ %29, %23 ]
  %25 = phi i64 [ %28, %23 ], [ %19, %22 ]
  %26 = phi i64 [ %27, %23 ], [ %20, %22 ]
  %27 = mul i64 %26, %25
  %28 = add nuw nsw i64 %25, 1
  %29 = add nsw i64 %24, -1
  %30 = icmp eq i64 %29, 0
  br i1 %30, label %31, label %23, !llvm.loop !9

31:                                               ; preds = %23
  br label %32

32:                                               ; preds = %31, %17, %0
  %33 = phi i64 [ 1, %0 ], [ %18, %17 ], [ %27, %31 ]
  %34 = call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.1, i64 noundef %33)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %1) #3
  ret i32 0

35:                                               ; preds = %35, %12
  %36 = phi i64 [ %53, %35 ], [ 8, %12 ]
  %37 = phi i64 [ 1, %12 ], [ %52, %35 ]
  %38 = add i64 %36, -7
  %39 = mul i64 %37, %38
  %40 = add i64 %36, -6
  %41 = mul i64 %39, %40
  %42 = add i64 %36, -5
  %43 = mul i64 %41, %42
  %44 = add i64 %36, -4
  %45 = mul i64 %43, %44
  %46 = add i64 %36, -3
  %47 = mul i64 %45, %46
  %48 = add i64 %36, -2
  %49 = mul i64 %47, %48
  %50 = add i64 %36, -1
  %51 = mul i64 %49, %50
  %52 = mul i64 %51, %36
  %53 = add i64 %36, 8
  %54 = add i64 %14, %53
  %55 = icmp eq i64 %54, 8
  br i1 %55, label %15, label %35, !llvm.loop !11
}
*** IR Dump After X86 Partial Reduction (x86-partial-reduction) ***
; Function Attrs: nofree nounwind uwtable
define dso_local noundef i32 @main() local_unnamed_addr #0 {
  %1 = alloca i32, align 4
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %1) #3
  %2 = call i32 (ptr, ...) @__isoc99_scanf(ptr noundef nonnull @.str, ptr noundef nonnull %1)
  %3 = load i32, ptr %1, align 4, !tbaa !5
  %4 = icmp slt i32 %3, 1
  br i1 %4, label %32, label %5

5:                                                ; preds = %0
  %6 = add nuw i32 %3, 1
  %7 = zext i32 %6 to i64
  %8 = add nsw i64 %7, -1
  %9 = add nsw i64 %7, -2
  %10 = and i64 %8, 7
  %11 = icmp ult i64 %9, 7
  br i1 %11, label %17, label %12

12:                                               ; preds = %5
  %13 = lshr i64 %8, 3
  %14 = mul i64 %13, -8
  br label %35

15:                                               ; preds = %35
  %16 = add i64 %53, -7
  br label %17

17:                                               ; preds = %15, %5
  %18 = phi i64 [ undef, %5 ], [ %52, %15 ]
  %19 = phi i64 [ 1, %5 ], [ %16, %15 ]
  %20 = phi i64 [ 1, %5 ], [ %52, %15 ]
  %21 = icmp eq i64 %10, 0
  br i1 %21, label %32, label %22

22:                                               ; preds = %17
  br label %23

23:                                               ; preds = %22, %23
  %24 = phi i64 [ %10, %22 ], [ %29, %23 ]
  %25 = phi i64 [ %28, %23 ], [ %19, %22 ]
  %26 = phi i64 [ %27, %23 ], [ %20, %22 ]
  %27 = mul i64 %26, %25
  %28 = add nuw nsw i64 %25, 1
  %29 = add nsw i64 %24, -1
  %30 = icmp eq i64 %29, 0
  br i1 %30, label %31, label %23, !llvm.loop !9

31:                                               ; preds = %23
  br label %32

32:                                               ; preds = %31, %17, %0
  %33 = phi i64 [ 1, %0 ], [ %18, %17 ], [ %27, %31 ]
  %34 = call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.1, i64 noundef %33)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %1) #3
  ret i32 0

35:                                               ; preds = %35, %12
  %36 = phi i64 [ %53, %35 ], [ 8, %12 ]
  %37 = phi i64 [ 1, %12 ], [ %52, %35 ]
  %38 = add i64 %36, -7
  %39 = mul i64 %37, %38
  %40 = add i64 %36, -6
  %41 = mul i64 %39, %40
  %42 = add i64 %36, -5
  %43 = mul i64 %41, %42
  %44 = add i64 %36, -4
  %45 = mul i64 %43, %44
  %46 = add i64 %36, -3
  %47 = mul i64 %45, %46
  %48 = add i64 %36, -2
  %49 = mul i64 %47, %48
  %50 = add i64 %36, -1
  %51 = mul i64 %49, %50
  %52 = mul i64 %51, %36
  %53 = add i64 %36, 8
  %54 = add i64 %14, %53
  %55 = icmp eq i64 %54, 8
  br i1 %55, label %15, label %35, !llvm.loop !11
}
*** IR Dump After Expand indirectbr instructions (indirectbr-expand) ***
; Function Attrs: nofree nounwind uwtable
define dso_local noundef i32 @main() local_unnamed_addr #0 {
  %1 = alloca i32, align 4
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %1) #3
  %2 = call i32 (ptr, ...) @__isoc99_scanf(ptr noundef nonnull @.str, ptr noundef nonnull %1)
  %3 = load i32, ptr %1, align 4, !tbaa !5
  %4 = icmp slt i32 %3, 1
  br i1 %4, label %32, label %5

5:                                                ; preds = %0
  %6 = add nuw i32 %3, 1
  %7 = zext i32 %6 to i64
  %8 = add nsw i64 %7, -1
  %9 = add nsw i64 %7, -2
  %10 = and i64 %8, 7
  %11 = icmp ult i64 %9, 7
  br i1 %11, label %17, label %12

12:                                               ; preds = %5
  %13 = lshr i64 %8, 3
  %14 = mul i64 %13, -8
  br label %35

15:                                               ; preds = %35
  %16 = add i64 %53, -7
  br label %17

17:                                               ; preds = %15, %5
  %18 = phi i64 [ undef, %5 ], [ %52, %15 ]
  %19 = phi i64 [ 1, %5 ], [ %16, %15 ]
  %20 = phi i64 [ 1, %5 ], [ %52, %15 ]
  %21 = icmp eq i64 %10, 0
  br i1 %21, label %32, label %22

22:                                               ; preds = %17
  br label %23

23:                                               ; preds = %22, %23
  %24 = phi i64 [ %10, %22 ], [ %29, %23 ]
  %25 = phi i64 [ %28, %23 ], [ %19, %22 ]
  %26 = phi i64 [ %27, %23 ], [ %20, %22 ]
  %27 = mul i64 %26, %25
  %28 = add nuw nsw i64 %25, 1
  %29 = add nsw i64 %24, -1
  %30 = icmp eq i64 %29, 0
  br i1 %30, label %31, label %23, !llvm.loop !9

31:                                               ; preds = %23
  br label %32

32:                                               ; preds = %31, %17, %0
  %33 = phi i64 [ 1, %0 ], [ %18, %17 ], [ %27, %31 ]
  %34 = call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.1, i64 noundef %33)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %1) #3
  ret i32 0

35:                                               ; preds = %35, %12
  %36 = phi i64 [ %53, %35 ], [ 8, %12 ]
  %37 = phi i64 [ 1, %12 ], [ %52, %35 ]
  %38 = add i64 %36, -7
  %39 = mul i64 %37, %38
  %40 = add i64 %36, -6
  %41 = mul i64 %39, %40
  %42 = add i64 %36, -5
  %43 = mul i64 %41, %42
  %44 = add i64 %36, -4
  %45 = mul i64 %43, %44
  %46 = add i64 %36, -3
  %47 = mul i64 %45, %46
  %48 = add i64 %36, -2
  %49 = mul i64 %47, %48
  %50 = add i64 %36, -1
  %51 = mul i64 %49, %50
  %52 = mul i64 %51, %36
  %53 = add i64 %36, 8
  %54 = add i64 %14, %53
  %55 = icmp eq i64 %54, 8
  br i1 %55, label %15, label %35, !llvm.loop !11
}
*** IR Dump After CodeGen Prepare (codegenprepare) ***
; Function Attrs: nofree nounwind uwtable
define dso_local noundef i32 @main() local_unnamed_addr #0 {
  %1 = alloca i32, align 4
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %1) #3
  %2 = call i32 (ptr, ...) @__isoc99_scanf(ptr noundef nonnull @.str, ptr noundef nonnull %1)
  %3 = load i32, ptr %1, align 4, !tbaa !5
  %4 = zext i32 %3 to i64
  %5 = icmp slt i32 %3, 1
  br i1 %5, label %31, label %6

6:                                                ; preds = %0
  %7 = add nuw i64 %4, 1
  %8 = add nsw i64 %7, -1
  %9 = add nsw i64 %7, -2
  %10 = and i64 %8, 7
  %11 = icmp ult i64 %9, 7
  br i1 %11, label %17, label %12

12:                                               ; preds = %6
  %13 = lshr i64 %8, 3
  %14 = mul i64 %13, -8
  br label %34

15:                                               ; preds = %34
  %16 = add i64 %52, -7
  br label %17

17:                                               ; preds = %15, %6
  %18 = phi i64 [ undef, %6 ], [ %51, %15 ]
  %19 = phi i64 [ 1, %6 ], [ %16, %15 ]
  %20 = phi i64 [ 1, %6 ], [ %51, %15 ]
  %21 = icmp eq i64 %10, 0
  br i1 %21, label %31, label %22

22:                                               ; preds = %17
  br label %23

23:                                               ; preds = %22, %23
  %24 = phi i64 [ %10, %22 ], [ %29, %23 ]
  %25 = phi i64 [ %28, %23 ], [ %19, %22 ]
  %26 = phi i64 [ %27, %23 ], [ %20, %22 ]
  %27 = mul i64 %26, %25
  %28 = add nuw nsw i64 %25, 1
  %29 = add nsw i64 %24, -1
  %30 = icmp eq i64 %29, 0
  br i1 %30, label %31, label %23, !llvm.loop !9

31:                                               ; preds = %23, %17, %0
  %32 = phi i64 [ 1, %0 ], [ %18, %17 ], [ %27, %23 ]
  %33 = call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.1, i64 noundef %32)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %1) #3
  ret i32 0

34:                                               ; preds = %34, %12
  %35 = phi i64 [ %52, %34 ], [ 8, %12 ]
  %36 = phi i64 [ 1, %12 ], [ %51, %34 ]
  %37 = add i64 %35, -7
  %38 = mul i64 %36, %37
  %39 = add i64 %35, -6
  %40 = mul i64 %38, %39
  %41 = add i64 %35, -5
  %42 = mul i64 %40, %41
  %43 = add i64 %35, -4
  %44 = mul i64 %42, %43
  %45 = add i64 %35, -3
  %46 = mul i64 %44, %45
  %47 = add i64 %35, -2
  %48 = mul i64 %46, %47
  %49 = add i64 %35, -1
  %50 = mul i64 %48, %49
  %51 = mul i64 %50, %35
  %52 = add i64 %35, 8
  %53 = add i64 %14, %52
  %54 = icmp eq i64 %53, 8
  br i1 %54, label %15, label %34, !llvm.loop !11
}
*** IR Dump After Exception handling preparation (dwarf-eh-prepare) ***
; Function Attrs: nofree nounwind uwtable
define dso_local noundef i32 @main() local_unnamed_addr #0 {
  %1 = alloca i32, align 4
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %1) #3
  %2 = call i32 (ptr, ...) @__isoc99_scanf(ptr noundef nonnull @.str, ptr noundef nonnull %1)
  %3 = load i32, ptr %1, align 4, !tbaa !5
  %4 = zext i32 %3 to i64
  %5 = icmp slt i32 %3, 1
  br i1 %5, label %31, label %6

6:                                                ; preds = %0
  %7 = add nuw i64 %4, 1
  %8 = add nsw i64 %7, -1
  %9 = add nsw i64 %7, -2
  %10 = and i64 %8, 7
  %11 = icmp ult i64 %9, 7
  br i1 %11, label %17, label %12

12:                                               ; preds = %6
  %13 = lshr i64 %8, 3
  %14 = mul i64 %13, -8
  br label %34

15:                                               ; preds = %34
  %16 = add i64 %52, -7
  br label %17

17:                                               ; preds = %15, %6
  %18 = phi i64 [ undef, %6 ], [ %51, %15 ]
  %19 = phi i64 [ 1, %6 ], [ %16, %15 ]
  %20 = phi i64 [ 1, %6 ], [ %51, %15 ]
  %21 = icmp eq i64 %10, 0
  br i1 %21, label %31, label %22

22:                                               ; preds = %17
  br label %23

23:                                               ; preds = %22, %23
  %24 = phi i64 [ %10, %22 ], [ %29, %23 ]
  %25 = phi i64 [ %28, %23 ], [ %19, %22 ]
  %26 = phi i64 [ %27, %23 ], [ %20, %22 ]
  %27 = mul i64 %26, %25
  %28 = add nuw nsw i64 %25, 1
  %29 = add nsw i64 %24, -1
  %30 = icmp eq i64 %29, 0
  br i1 %30, label %31, label %23, !llvm.loop !9

31:                                               ; preds = %23, %17, %0
  %32 = phi i64 [ 1, %0 ], [ %18, %17 ], [ %27, %23 ]
  %33 = call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.1, i64 noundef %32)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %1) #3
  ret i32 0

34:                                               ; preds = %34, %12
  %35 = phi i64 [ %52, %34 ], [ 8, %12 ]
  %36 = phi i64 [ 1, %12 ], [ %51, %34 ]
  %37 = add i64 %35, -7
  %38 = mul i64 %36, %37
  %39 = add i64 %35, -6
  %40 = mul i64 %38, %39
  %41 = add i64 %35, -5
  %42 = mul i64 %40, %41
  %43 = add i64 %35, -4
  %44 = mul i64 %42, %43
  %45 = add i64 %35, -3
  %46 = mul i64 %44, %45
  %47 = add i64 %35, -2
  %48 = mul i64 %46, %47
  %49 = add i64 %35, -1
  %50 = mul i64 %48, %49
  %51 = mul i64 %50, %35
  %52 = add i64 %35, 8
  %53 = add i64 %14, %52
  %54 = icmp eq i64 %53, 8
  br i1 %54, label %15, label %34, !llvm.loop !11
}
*** IR Dump After Prepare callbr (callbrprepare) ***
; Function Attrs: nofree nounwind uwtable
define dso_local noundef i32 @main() local_unnamed_addr #0 {
  %1 = alloca i32, align 4
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %1) #3
  %2 = call i32 (ptr, ...) @__isoc99_scanf(ptr noundef nonnull @.str, ptr noundef nonnull %1)
  %3 = load i32, ptr %1, align 4, !tbaa !5
  %4 = zext i32 %3 to i64
  %5 = icmp slt i32 %3, 1
  br i1 %5, label %31, label %6

6:                                                ; preds = %0
  %7 = add nuw i64 %4, 1
  %8 = add nsw i64 %7, -1
  %9 = add nsw i64 %7, -2
  %10 = and i64 %8, 7
  %11 = icmp ult i64 %9, 7
  br i1 %11, label %17, label %12

12:                                               ; preds = %6
  %13 = lshr i64 %8, 3
  %14 = mul i64 %13, -8
  br label %34

15:                                               ; preds = %34
  %16 = add i64 %52, -7
  br label %17

17:                                               ; preds = %15, %6
  %18 = phi i64 [ undef, %6 ], [ %51, %15 ]
  %19 = phi i64 [ 1, %6 ], [ %16, %15 ]
  %20 = phi i64 [ 1, %6 ], [ %51, %15 ]
  %21 = icmp eq i64 %10, 0
  br i1 %21, label %31, label %22

22:                                               ; preds = %17
  br label %23

23:                                               ; preds = %22, %23
  %24 = phi i64 [ %10, %22 ], [ %29, %23 ]
  %25 = phi i64 [ %28, %23 ], [ %19, %22 ]
  %26 = phi i64 [ %27, %23 ], [ %20, %22 ]
  %27 = mul i64 %26, %25
  %28 = add nuw nsw i64 %25, 1
  %29 = add nsw i64 %24, -1
  %30 = icmp eq i64 %29, 0
  br i1 %30, label %31, label %23, !llvm.loop !9

31:                                               ; preds = %23, %17, %0
  %32 = phi i64 [ 1, %0 ], [ %18, %17 ], [ %27, %23 ]
  %33 = call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.1, i64 noundef %32)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %1) #3
  ret i32 0

34:                                               ; preds = %34, %12
  %35 = phi i64 [ %52, %34 ], [ 8, %12 ]
  %36 = phi i64 [ 1, %12 ], [ %51, %34 ]
  %37 = add i64 %35, -7
  %38 = mul i64 %36, %37
  %39 = add i64 %35, -6
  %40 = mul i64 %38, %39
  %41 = add i64 %35, -5
  %42 = mul i64 %40, %41
  %43 = add i64 %35, -4
  %44 = mul i64 %42, %43
  %45 = add i64 %35, -3
  %46 = mul i64 %44, %45
  %47 = add i64 %35, -2
  %48 = mul i64 %46, %47
  %49 = add i64 %35, -1
  %50 = mul i64 %48, %49
  %51 = mul i64 %50, %35
  %52 = add i64 %35, 8
  %53 = add i64 %14, %52
  %54 = icmp eq i64 %53, 8
  br i1 %54, label %15, label %34, !llvm.loop !11
}
*** IR Dump After Safe Stack instrumentation pass (safe-stack) ***
; Function Attrs: nofree nounwind uwtable
define dso_local noundef i32 @main() local_unnamed_addr #0 {
  %1 = alloca i32, align 4
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %1) #3
  %2 = call i32 (ptr, ...) @__isoc99_scanf(ptr noundef nonnull @.str, ptr noundef nonnull %1)
  %3 = load i32, ptr %1, align 4, !tbaa !5
  %4 = zext i32 %3 to i64
  %5 = icmp slt i32 %3, 1
  br i1 %5, label %31, label %6

6:                                                ; preds = %0
  %7 = add nuw i64 %4, 1
  %8 = add nsw i64 %7, -1
  %9 = add nsw i64 %7, -2
  %10 = and i64 %8, 7
  %11 = icmp ult i64 %9, 7
  br i1 %11, label %17, label %12

12:                                               ; preds = %6
  %13 = lshr i64 %8, 3
  %14 = mul i64 %13, -8
  br label %34

15:                                               ; preds = %34
  %16 = add i64 %52, -7
  br label %17

17:                                               ; preds = %15, %6
  %18 = phi i64 [ undef, %6 ], [ %51, %15 ]
  %19 = phi i64 [ 1, %6 ], [ %16, %15 ]
  %20 = phi i64 [ 1, %6 ], [ %51, %15 ]
  %21 = icmp eq i64 %10, 0
  br i1 %21, label %31, label %22

22:                                               ; preds = %17
  br label %23

23:                                               ; preds = %22, %23
  %24 = phi i64 [ %10, %22 ], [ %29, %23 ]
  %25 = phi i64 [ %28, %23 ], [ %19, %22 ]
  %26 = phi i64 [ %27, %23 ], [ %20, %22 ]
  %27 = mul i64 %26, %25
  %28 = add nuw nsw i64 %25, 1
  %29 = add nsw i64 %24, -1
  %30 = icmp eq i64 %29, 0
  br i1 %30, label %31, label %23, !llvm.loop !9

31:                                               ; preds = %23, %17, %0
  %32 = phi i64 [ 1, %0 ], [ %18, %17 ], [ %27, %23 ]
  %33 = call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.1, i64 noundef %32)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %1) #3
  ret i32 0

34:                                               ; preds = %34, %12
  %35 = phi i64 [ %52, %34 ], [ 8, %12 ]
  %36 = phi i64 [ 1, %12 ], [ %51, %34 ]
  %37 = add i64 %35, -7
  %38 = mul i64 %36, %37
  %39 = add i64 %35, -6
  %40 = mul i64 %38, %39
  %41 = add i64 %35, -5
  %42 = mul i64 %40, %41
  %43 = add i64 %35, -4
  %44 = mul i64 %42, %43
  %45 = add i64 %35, -3
  %46 = mul i64 %44, %45
  %47 = add i64 %35, -2
  %48 = mul i64 %46, %47
  %49 = add i64 %35, -1
  %50 = mul i64 %48, %49
  %51 = mul i64 %50, %35
  %52 = add i64 %35, 8
  %53 = add i64 %14, %52
  %54 = icmp eq i64 %53, 8
  br i1 %54, label %15, label %34, !llvm.loop !11
}
# *** IR Dump After X86 DAG->DAG Instruction Selection (x86-isel) ***:
# Machine code for function main: IsSSA, TracksLiveness
Frame Objects:
  fi#0: size=4, align=4, at location [SP+8]

bb.0 (%ir-block.0):
  successors: %bb.7(0x30000000), %bb.1(0x50000000); %bb.7(37.50%), %bb.1(62.50%)

  LIFETIME_START %stack.0
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %20:gr64 = LEA64r $rip, 1, $noreg, @.str, $noreg
  %21:gr32 = MOV32r0 implicit-def dead $eflags
  %22:gr8 = COPY %21.sub_8bit:gr32
  %23:gr64 = LEA64r %stack.0, 1, $noreg, 0, $noreg
  $rdi = COPY %20:gr64
  $rsi = COPY %23:gr64
  $al = COPY %22:gr8
  CALL64pcrel32 target-flags(x86-plt) @__isoc99_scanf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %24:gr32 = COPY $eax
  %25:gr32 = MOV32rm %stack.0, 1, $noreg, 0, $noreg :: (dereferenceable load (s32) from %ir.1, !tbaa !5)
  %0:gr64 = SUBREG_TO_REG 0, killed %25:gr32, %subreg.sub_32bit
  %26:gr32 = COPY %0.sub_32bit:gr64
  %19:gr64 = MOV32ri64 1
  TEST32rr %26:gr32, %26:gr32, implicit-def $eflags
  JCC_1 %bb.7, 14, implicit $eflags
  JMP_1 %bb.1

bb.1 (%ir-block.6):
; predecessors: %bb.0
  successors: %bb.4(0x40000000), %bb.2(0x40000000); %bb.4(50.00%), %bb.2(50.00%)

  %1:gr64 = COPY %0:gr64
  %29:gr64 = DEC64r %0:gr64(tied-def 0), implicit-def dead $eflags
  %30:gr32 = COPY %0.sub_32bit:gr64
  %31:gr32 = AND32ri %30:gr32(tied-def 0), 7, implicit-def dead $eflags
  %2:gr64 = SUBREG_TO_REG 0, killed %31:gr32, %subreg.sub_32bit
  %28:gr64 = MOV32ri64 1
  %27:gr64 = IMPLICIT_DEF
  %32:gr64 = SUB64ri32 %29:gr64(tied-def 0), 7, implicit-def $eflags
  JCC_1 %bb.4, 2, implicit $eflags
  JMP_1 %bb.2

bb.2 (%ir-block.12):
; predecessors: %bb.1
  successors: %bb.8(0x80000000); %bb.8(100.00%)

  %35:gr32 = COPY %1.sub_32bit:gr64
  %36:gr32 = AND32ri %35:gr32(tied-def 0), -8, implicit-def dead $eflags
  %37:gr64 = SUBREG_TO_REG 0, killed %36:gr32, %subreg.sub_32bit
  %3:gr64 = NEG64r %37:gr64(tied-def 0), implicit-def dead $eflags
  %34:gr64 = MOV32ri64 1
  %33:gr64 = MOV32ri64 8
  JMP_1 %bb.8

bb.3 (%ir-block.15):
; predecessors: %bb.8
  successors: %bb.4(0x80000000); %bb.4(100.00%)

  %4:gr64 = ADD64ri32 %18:gr64(tied-def 0), -7, implicit-def dead $eflags

bb.4 (%ir-block.17):
; predecessors: %bb.1, %bb.3
  successors: %bb.7(0x30000000), %bb.5(0x50000000); %bb.7(37.50%), %bb.5(62.50%)

  %5:gr64 = PHI %27:gr64, %bb.1, %17:gr64, %bb.3
  %6:gr64 = PHI %28:gr64, %bb.1, %4:gr64, %bb.3
  %7:gr64 = PHI %28:gr64, %bb.1, %17:gr64, %bb.3
  TEST64rr %2:gr64, %2:gr64, implicit-def $eflags
  JCC_1 %bb.7, 4, implicit $eflags
  JMP_1 %bb.5

bb.5 (%ir-block.22):
; predecessors: %bb.4
  successors: %bb.6(0x80000000); %bb.6(100.00%)


bb.6 (%ir-block.23):
; predecessors: %bb.5, %bb.6
  successors: %bb.7(0x04000000), %bb.6(0x7c000000); %bb.7(3.12%), %bb.6(96.88%)

  %8:gr64 = PHI %2:gr64, %bb.5, %13:gr64, %bb.6
  %9:gr64 = PHI %6:gr64, %bb.5, %12:gr64, %bb.6
  %10:gr64 = PHI %7:gr64, %bb.5, %11:gr64, %bb.6
  %11:gr64 = IMUL64rr %10:gr64(tied-def 0), %9:gr64, implicit-def dead $eflags
  %12:gr64 = nuw nsw INC64r %9:gr64(tied-def 0), implicit-def dead $eflags
  %13:gr64 = DEC64r %8:gr64(tied-def 0), implicit-def $eflags
  JCC_1 %bb.6, 5, implicit $eflags
  JMP_1 %bb.7

bb.7 (%ir-block.31):
; predecessors: %bb.0, %bb.4, %bb.6

  %14:gr64 = PHI %19:gr64, %bb.0, %5:gr64, %bb.4, %11:gr64, %bb.6
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %54:gr64 = LEA64r $rip, 1, $noreg, @.str.1, $noreg
  %55:gr32 = MOV32r0 implicit-def dead $eflags
  %56:gr8 = COPY %55.sub_8bit:gr32
  $rdi = COPY %54:gr64
  $rsi = COPY %14:gr64
  $al = COPY %56:gr8
  CALL64pcrel32 target-flags(x86-plt) @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %57:gr32 = COPY $eax
  LIFETIME_END %stack.0
  $eax = COPY %55:gr32
  RET 0, $eax

bb.8 (%ir-block.34):
; predecessors: %bb.2, %bb.8
  successors: %bb.3(0x04000000), %bb.8(0x7c000000); %bb.3(3.12%), %bb.8(96.88%)

  %15:gr64_nosp = PHI %33:gr64, %bb.2, %18:gr64, %bb.8
  %16:gr64 = PHI %34:gr64, %bb.2, %17:gr64, %bb.8
  %38:gr64 = ADD64ri32 %15:gr64_nosp(tied-def 0), -7, implicit-def dead $eflags
  %39:gr64 = IMUL64rr %16:gr64(tied-def 0), killed %38:gr64, implicit-def dead $eflags
  %40:gr64 = ADD64ri32 %15:gr64_nosp(tied-def 0), -6, implicit-def dead $eflags
  %41:gr64 = IMUL64rr %39:gr64(tied-def 0), killed %40:gr64, implicit-def dead $eflags
  %42:gr64 = ADD64ri32 %15:gr64_nosp(tied-def 0), -5, implicit-def dead $eflags
  %43:gr64 = IMUL64rr %41:gr64(tied-def 0), killed %42:gr64, implicit-def dead $eflags
  %44:gr64 = ADD64ri32 %15:gr64_nosp(tied-def 0), -4, implicit-def dead $eflags
  %45:gr64 = IMUL64rr %43:gr64(tied-def 0), killed %44:gr64, implicit-def dead $eflags
  %46:gr64 = ADD64ri32 %15:gr64_nosp(tied-def 0), -3, implicit-def dead $eflags
  %47:gr64 = IMUL64rr %45:gr64(tied-def 0), killed %46:gr64, implicit-def dead $eflags
  %48:gr64 = ADD64ri32 %15:gr64_nosp(tied-def 0), -2, implicit-def dead $eflags
  %49:gr64 = IMUL64rr %47:gr64(tied-def 0), killed %48:gr64, implicit-def dead $eflags
  %50:gr64 = DEC64r %15:gr64_nosp(tied-def 0), implicit-def dead $eflags
  %51:gr64 = IMUL64rr %49:gr64(tied-def 0), killed %50:gr64, implicit-def dead $eflags
  %17:gr64 = IMUL64rr %51:gr64(tied-def 0), %15:gr64_nosp, implicit-def dead $eflags
  %18:gr64 = ADD64ri32 %15:gr64_nosp(tied-def 0), 8, implicit-def dead $eflags
  %52:gr64 = LEA64r %3:gr64, 1, %15:gr64_nosp, 8, $noreg
  %53:gr64 = SUB64ri32 %52:gr64(tied-def 0), 8, implicit-def $eflags
  JCC_1 %bb.3, 4, implicit $eflags
  JMP_1 %bb.8

# End machine code for function main.

# *** IR Dump After Argument Stack Rebase (x86argumentstackrebase) ***:
# Machine code for function main: IsSSA, TracksLiveness
Frame Objects:
  fi#0: size=4, align=4, at location [SP+8]

bb.0 (%ir-block.0):
  successors: %bb.7(0x30000000), %bb.1(0x50000000); %bb.7(37.50%), %bb.1(62.50%)

  LIFETIME_START %stack.0
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %20:gr64 = LEA64r $rip, 1, $noreg, @.str, $noreg
  %21:gr32 = MOV32r0 implicit-def dead $eflags
  %22:gr8 = COPY %21.sub_8bit:gr32
  %23:gr64 = LEA64r %stack.0, 1, $noreg, 0, $noreg
  $rdi = COPY %20:gr64
  $rsi = COPY %23:gr64
  $al = COPY %22:gr8
  CALL64pcrel32 target-flags(x86-plt) @__isoc99_scanf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %24:gr32 = COPY $eax
  %25:gr32 = MOV32rm %stack.0, 1, $noreg, 0, $noreg :: (dereferenceable load (s32) from %ir.1, !tbaa !5)
  %0:gr64 = SUBREG_TO_REG 0, killed %25:gr32, %subreg.sub_32bit
  %26:gr32 = COPY %0.sub_32bit:gr64
  %19:gr64 = MOV32ri64 1
  TEST32rr %26:gr32, %26:gr32, implicit-def $eflags
  JCC_1 %bb.7, 14, implicit $eflags
  JMP_1 %bb.1

bb.1 (%ir-block.6):
; predecessors: %bb.0
  successors: %bb.4(0x40000000), %bb.2(0x40000000); %bb.4(50.00%), %bb.2(50.00%)

  %1:gr64 = COPY %0:gr64
  %29:gr64 = DEC64r %0:gr64(tied-def 0), implicit-def dead $eflags
  %30:gr32 = COPY %0.sub_32bit:gr64
  %31:gr32 = AND32ri %30:gr32(tied-def 0), 7, implicit-def dead $eflags
  %2:gr64 = SUBREG_TO_REG 0, killed %31:gr32, %subreg.sub_32bit
  %28:gr64 = MOV32ri64 1
  %27:gr64 = IMPLICIT_DEF
  %32:gr64 = SUB64ri32 %29:gr64(tied-def 0), 7, implicit-def $eflags
  JCC_1 %bb.4, 2, implicit $eflags
  JMP_1 %bb.2

bb.2 (%ir-block.12):
; predecessors: %bb.1
  successors: %bb.8(0x80000000); %bb.8(100.00%)

  %35:gr32 = COPY %1.sub_32bit:gr64
  %36:gr32 = AND32ri %35:gr32(tied-def 0), -8, implicit-def dead $eflags
  %37:gr64 = SUBREG_TO_REG 0, killed %36:gr32, %subreg.sub_32bit
  %3:gr64 = NEG64r %37:gr64(tied-def 0), implicit-def dead $eflags
  %34:gr64 = MOV32ri64 1
  %33:gr64 = MOV32ri64 8
  JMP_1 %bb.8

bb.3 (%ir-block.15):
; predecessors: %bb.8
  successors: %bb.4(0x80000000); %bb.4(100.00%)

  %4:gr64 = ADD64ri32 %18:gr64(tied-def 0), -7, implicit-def dead $eflags

bb.4 (%ir-block.17):
; predecessors: %bb.1, %bb.3
  successors: %bb.7(0x30000000), %bb.5(0x50000000); %bb.7(37.50%), %bb.5(62.50%)

  %5:gr64 = PHI %27:gr64, %bb.1, %17:gr64, %bb.3
  %6:gr64 = PHI %28:gr64, %bb.1, %4:gr64, %bb.3
  %7:gr64 = PHI %28:gr64, %bb.1, %17:gr64, %bb.3
  TEST64rr %2:gr64, %2:gr64, implicit-def $eflags
  JCC_1 %bb.7, 4, implicit $eflags
  JMP_1 %bb.5

bb.5 (%ir-block.22):
; predecessors: %bb.4
  successors: %bb.6(0x80000000); %bb.6(100.00%)


bb.6 (%ir-block.23):
; predecessors: %bb.5, %bb.6
  successors: %bb.7(0x04000000), %bb.6(0x7c000000); %bb.7(3.12%), %bb.6(96.88%)

  %8:gr64 = PHI %2:gr64, %bb.5, %13:gr64, %bb.6
  %9:gr64 = PHI %6:gr64, %bb.5, %12:gr64, %bb.6
  %10:gr64 = PHI %7:gr64, %bb.5, %11:gr64, %bb.6
  %11:gr64 = IMUL64rr %10:gr64(tied-def 0), %9:gr64, implicit-def dead $eflags
  %12:gr64 = nuw nsw INC64r %9:gr64(tied-def 0), implicit-def dead $eflags
  %13:gr64 = DEC64r %8:gr64(tied-def 0), implicit-def $eflags
  JCC_1 %bb.6, 5, implicit $eflags
  JMP_1 %bb.7

bb.7 (%ir-block.31):
; predecessors: %bb.0, %bb.4, %bb.6

  %14:gr64 = PHI %19:gr64, %bb.0, %5:gr64, %bb.4, %11:gr64, %bb.6
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %54:gr64 = LEA64r $rip, 1, $noreg, @.str.1, $noreg
  %55:gr32 = MOV32r0 implicit-def dead $eflags
  %56:gr8 = COPY %55.sub_8bit:gr32
  $rdi = COPY %54:gr64
  $rsi = COPY %14:gr64
  $al = COPY %56:gr8
  CALL64pcrel32 target-flags(x86-plt) @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %57:gr32 = COPY $eax
  LIFETIME_END %stack.0
  $eax = COPY %55:gr32
  RET 0, $eax

bb.8 (%ir-block.34):
; predecessors: %bb.2, %bb.8
  successors: %bb.3(0x04000000), %bb.8(0x7c000000); %bb.3(3.12%), %bb.8(96.88%)

  %15:gr64_nosp = PHI %33:gr64, %bb.2, %18:gr64, %bb.8
  %16:gr64 = PHI %34:gr64, %bb.2, %17:gr64, %bb.8
  %38:gr64 = ADD64ri32 %15:gr64_nosp(tied-def 0), -7, implicit-def dead $eflags
  %39:gr64 = IMUL64rr %16:gr64(tied-def 0), killed %38:gr64, implicit-def dead $eflags
  %40:gr64 = ADD64ri32 %15:gr64_nosp(tied-def 0), -6, implicit-def dead $eflags
  %41:gr64 = IMUL64rr %39:gr64(tied-def 0), killed %40:gr64, implicit-def dead $eflags
  %42:gr64 = ADD64ri32 %15:gr64_nosp(tied-def 0), -5, implicit-def dead $eflags
  %43:gr64 = IMUL64rr %41:gr64(tied-def 0), killed %42:gr64, implicit-def dead $eflags
  %44:gr64 = ADD64ri32 %15:gr64_nosp(tied-def 0), -4, implicit-def dead $eflags
  %45:gr64 = IMUL64rr %43:gr64(tied-def 0), killed %44:gr64, implicit-def dead $eflags
  %46:gr64 = ADD64ri32 %15:gr64_nosp(tied-def 0), -3, implicit-def dead $eflags
  %47:gr64 = IMUL64rr %45:gr64(tied-def 0), killed %46:gr64, implicit-def dead $eflags
  %48:gr64 = ADD64ri32 %15:gr64_nosp(tied-def 0), -2, implicit-def dead $eflags
  %49:gr64 = IMUL64rr %47:gr64(tied-def 0), killed %48:gr64, implicit-def dead $eflags
  %50:gr64 = DEC64r %15:gr64_nosp(tied-def 0), implicit-def dead $eflags
  %51:gr64 = IMUL64rr %49:gr64(tied-def 0), killed %50:gr64, implicit-def dead $eflags
  %17:gr64 = IMUL64rr %51:gr64(tied-def 0), %15:gr64_nosp, implicit-def dead $eflags
  %18:gr64 = ADD64ri32 %15:gr64_nosp(tied-def 0), 8, implicit-def dead $eflags
  %52:gr64 = LEA64r %3:gr64, 1, %15:gr64_nosp, 8, $noreg
  %53:gr64 = SUB64ri32 %52:gr64(tied-def 0), 8, implicit-def $eflags
  JCC_1 %bb.3, 4, implicit $eflags
  JMP_1 %bb.8

# End machine code for function main.

# *** IR Dump After Finalize ISel and expand pseudo-instructions (finalize-isel) ***:
# Machine code for function main: IsSSA, TracksLiveness
Frame Objects:
  fi#0: size=4, align=4, at location [SP+8]

bb.0 (%ir-block.0):
  successors: %bb.7(0x30000000), %bb.1(0x50000000); %bb.7(37.50%), %bb.1(62.50%)

  LIFETIME_START %stack.0
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %20:gr64 = LEA64r $rip, 1, $noreg, @.str, $noreg
  %21:gr32 = MOV32r0 implicit-def dead $eflags
  %22:gr8 = COPY %21.sub_8bit:gr32
  %23:gr64 = LEA64r %stack.0, 1, $noreg, 0, $noreg
  $rdi = COPY %20:gr64
  $rsi = COPY %23:gr64
  $al = COPY %22:gr8
  CALL64pcrel32 target-flags(x86-plt) @__isoc99_scanf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %24:gr32 = COPY $eax
  %25:gr32 = MOV32rm %stack.0, 1, $noreg, 0, $noreg :: (dereferenceable load (s32) from %ir.1, !tbaa !5)
  %0:gr64 = SUBREG_TO_REG 0, killed %25:gr32, %subreg.sub_32bit
  %26:gr32 = COPY %0.sub_32bit:gr64
  %19:gr64 = MOV32ri64 1
  TEST32rr %26:gr32, %26:gr32, implicit-def $eflags
  JCC_1 %bb.7, 14, implicit $eflags
  JMP_1 %bb.1

bb.1 (%ir-block.6):
; predecessors: %bb.0
  successors: %bb.4(0x40000000), %bb.2(0x40000000); %bb.4(50.00%), %bb.2(50.00%)

  %1:gr64 = COPY %0:gr64
  %29:gr64 = DEC64r %0:gr64(tied-def 0), implicit-def dead $eflags
  %30:gr32 = COPY %0.sub_32bit:gr64
  %31:gr32 = AND32ri %30:gr32(tied-def 0), 7, implicit-def dead $eflags
  %2:gr64 = SUBREG_TO_REG 0, killed %31:gr32, %subreg.sub_32bit
  %28:gr64 = MOV32ri64 1
  %27:gr64 = IMPLICIT_DEF
  %32:gr64 = SUB64ri32 %29:gr64(tied-def 0), 7, implicit-def $eflags
  JCC_1 %bb.4, 2, implicit $eflags
  JMP_1 %bb.2

bb.2 (%ir-block.12):
; predecessors: %bb.1
  successors: %bb.8(0x80000000); %bb.8(100.00%)

  %35:gr32 = COPY %1.sub_32bit:gr64
  %36:gr32 = AND32ri %35:gr32(tied-def 0), -8, implicit-def dead $eflags
  %37:gr64 = SUBREG_TO_REG 0, killed %36:gr32, %subreg.sub_32bit
  %3:gr64 = NEG64r %37:gr64(tied-def 0), implicit-def dead $eflags
  %34:gr64 = MOV32ri64 1
  %33:gr64 = MOV32ri64 8
  JMP_1 %bb.8

bb.3 (%ir-block.15):
; predecessors: %bb.8
  successors: %bb.4(0x80000000); %bb.4(100.00%)

  %4:gr64 = ADD64ri32 %18:gr64(tied-def 0), -7, implicit-def dead $eflags

bb.4 (%ir-block.17):
; predecessors: %bb.1, %bb.3
  successors: %bb.7(0x30000000), %bb.5(0x50000000); %bb.7(37.50%), %bb.5(62.50%)

  %5:gr64 = PHI %27:gr64, %bb.1, %17:gr64, %bb.3
  %6:gr64 = PHI %28:gr64, %bb.1, %4:gr64, %bb.3
  %7:gr64 = PHI %28:gr64, %bb.1, %17:gr64, %bb.3
  TEST64rr %2:gr64, %2:gr64, implicit-def $eflags
  JCC_1 %bb.7, 4, implicit $eflags
  JMP_1 %bb.5

bb.5 (%ir-block.22):
; predecessors: %bb.4
  successors: %bb.6(0x80000000); %bb.6(100.00%)


bb.6 (%ir-block.23):
; predecessors: %bb.5, %bb.6
  successors: %bb.7(0x04000000), %bb.6(0x7c000000); %bb.7(3.12%), %bb.6(96.88%)

  %8:gr64 = PHI %2:gr64, %bb.5, %13:gr64, %bb.6
  %9:gr64 = PHI %6:gr64, %bb.5, %12:gr64, %bb.6
  %10:gr64 = PHI %7:gr64, %bb.5, %11:gr64, %bb.6
  %11:gr64 = IMUL64rr %10:gr64(tied-def 0), %9:gr64, implicit-def dead $eflags
  %12:gr64 = nuw nsw INC64r %9:gr64(tied-def 0), implicit-def dead $eflags
  %13:gr64 = DEC64r %8:gr64(tied-def 0), implicit-def $eflags
  JCC_1 %bb.6, 5, implicit $eflags
  JMP_1 %bb.7

bb.7 (%ir-block.31):
; predecessors: %bb.0, %bb.4, %bb.6

  %14:gr64 = PHI %19:gr64, %bb.0, %5:gr64, %bb.4, %11:gr64, %bb.6
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %54:gr64 = LEA64r $rip, 1, $noreg, @.str.1, $noreg
  %55:gr32 = MOV32r0 implicit-def dead $eflags
  %56:gr8 = COPY %55.sub_8bit:gr32
  $rdi = COPY %54:gr64
  $rsi = COPY %14:gr64
  $al = COPY %56:gr8
  CALL64pcrel32 target-flags(x86-plt) @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %57:gr32 = COPY $eax
  LIFETIME_END %stack.0
  $eax = COPY %55:gr32
  RET 0, $eax

bb.8 (%ir-block.34):
; predecessors: %bb.2, %bb.8
  successors: %bb.3(0x04000000), %bb.8(0x7c000000); %bb.3(3.12%), %bb.8(96.88%)

  %15:gr64_nosp = PHI %33:gr64, %bb.2, %18:gr64, %bb.8
  %16:gr64 = PHI %34:gr64, %bb.2, %17:gr64, %bb.8
  %38:gr64 = ADD64ri32 %15:gr64_nosp(tied-def 0), -7, implicit-def dead $eflags
  %39:gr64 = IMUL64rr %16:gr64(tied-def 0), killed %38:gr64, implicit-def dead $eflags
  %40:gr64 = ADD64ri32 %15:gr64_nosp(tied-def 0), -6, implicit-def dead $eflags
  %41:gr64 = IMUL64rr %39:gr64(tied-def 0), killed %40:gr64, implicit-def dead $eflags
  %42:gr64 = ADD64ri32 %15:gr64_nosp(tied-def 0), -5, implicit-def dead $eflags
  %43:gr64 = IMUL64rr %41:gr64(tied-def 0), killed %42:gr64, implicit-def dead $eflags
  %44:gr64 = ADD64ri32 %15:gr64_nosp(tied-def 0), -4, implicit-def dead $eflags
  %45:gr64 = IMUL64rr %43:gr64(tied-def 0), killed %44:gr64, implicit-def dead $eflags
  %46:gr64 = ADD64ri32 %15:gr64_nosp(tied-def 0), -3, implicit-def dead $eflags
  %47:gr64 = IMUL64rr %45:gr64(tied-def 0), killed %46:gr64, implicit-def dead $eflags
  %48:gr64 = ADD64ri32 %15:gr64_nosp(tied-def 0), -2, implicit-def dead $eflags
  %49:gr64 = IMUL64rr %47:gr64(tied-def 0), killed %48:gr64, implicit-def dead $eflags
  %50:gr64 = DEC64r %15:gr64_nosp(tied-def 0), implicit-def dead $eflags
  %51:gr64 = IMUL64rr %49:gr64(tied-def 0), killed %50:gr64, implicit-def dead $eflags
  %17:gr64 = IMUL64rr %51:gr64(tied-def 0), %15:gr64_nosp, implicit-def dead $eflags
  %18:gr64 = ADD64ri32 %15:gr64_nosp(tied-def 0), 8, implicit-def dead $eflags
  %52:gr64 = LEA64r %3:gr64, 1, %15:gr64_nosp, 8, $noreg
  %53:gr64 = SUB64ri32 %52:gr64(tied-def 0), 8, implicit-def $eflags
  JCC_1 %bb.3, 4, implicit $eflags
  JMP_1 %bb.8

# End machine code for function main.

# *** IR Dump After X86 Domain Reassignment Pass (x86-domain-reassignment) ***:
# Machine code for function main: IsSSA, TracksLiveness
Frame Objects:
  fi#0: size=4, align=4, at location [SP+8]

bb.0 (%ir-block.0):
  successors: %bb.7(0x30000000), %bb.1(0x50000000); %bb.7(37.50%), %bb.1(62.50%)

  LIFETIME_START %stack.0
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %20:gr64 = LEA64r $rip, 1, $noreg, @.str, $noreg
  %21:gr32 = MOV32r0 implicit-def dead $eflags
  %22:gr8 = COPY %21.sub_8bit:gr32
  %23:gr64 = LEA64r %stack.0, 1, $noreg, 0, $noreg
  $rdi = COPY %20:gr64
  $rsi = COPY %23:gr64
  $al = COPY %22:gr8
  CALL64pcrel32 target-flags(x86-plt) @__isoc99_scanf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %24:gr32 = COPY $eax
  %25:gr32 = MOV32rm %stack.0, 1, $noreg, 0, $noreg :: (dereferenceable load (s32) from %ir.1, !tbaa !5)
  %0:gr64 = SUBREG_TO_REG 0, killed %25:gr32, %subreg.sub_32bit
  %26:gr32 = COPY %0.sub_32bit:gr64
  %19:gr64 = MOV32ri64 1
  TEST32rr %26:gr32, %26:gr32, implicit-def $eflags
  JCC_1 %bb.7, 14, implicit $eflags
  JMP_1 %bb.1

bb.1 (%ir-block.6):
; predecessors: %bb.0
  successors: %bb.4(0x40000000), %bb.2(0x40000000); %bb.4(50.00%), %bb.2(50.00%)

  %1:gr64 = COPY %0:gr64
  %29:gr64 = DEC64r %0:gr64(tied-def 0), implicit-def dead $eflags
  %30:gr32 = COPY %0.sub_32bit:gr64
  %31:gr32 = AND32ri %30:gr32(tied-def 0), 7, implicit-def dead $eflags
  %2:gr64 = SUBREG_TO_REG 0, killed %31:gr32, %subreg.sub_32bit
  %28:gr64 = MOV32ri64 1
  %27:gr64 = IMPLICIT_DEF
  %32:gr64 = SUB64ri32 %29:gr64(tied-def 0), 7, implicit-def $eflags
  JCC_1 %bb.4, 2, implicit $eflags
  JMP_1 %bb.2

bb.2 (%ir-block.12):
; predecessors: %bb.1
  successors: %bb.8(0x80000000); %bb.8(100.00%)

  %35:gr32 = COPY %1.sub_32bit:gr64
  %36:gr32 = AND32ri %35:gr32(tied-def 0), -8, implicit-def dead $eflags
  %37:gr64 = SUBREG_TO_REG 0, killed %36:gr32, %subreg.sub_32bit
  %3:gr64 = NEG64r %37:gr64(tied-def 0), implicit-def dead $eflags
  %34:gr64 = MOV32ri64 1
  %33:gr64 = MOV32ri64 8
  JMP_1 %bb.8

bb.3 (%ir-block.15):
; predecessors: %bb.8
  successors: %bb.4(0x80000000); %bb.4(100.00%)

  %4:gr64 = ADD64ri32 %18:gr64(tied-def 0), -7, implicit-def dead $eflags

bb.4 (%ir-block.17):
; predecessors: %bb.1, %bb.3
  successors: %bb.7(0x30000000), %bb.5(0x50000000); %bb.7(37.50%), %bb.5(62.50%)

  %5:gr64 = PHI %27:gr64, %bb.1, %17:gr64, %bb.3
  %6:gr64 = PHI %28:gr64, %bb.1, %4:gr64, %bb.3
  %7:gr64 = PHI %28:gr64, %bb.1, %17:gr64, %bb.3
  TEST64rr %2:gr64, %2:gr64, implicit-def $eflags
  JCC_1 %bb.7, 4, implicit $eflags
  JMP_1 %bb.5

bb.5 (%ir-block.22):
; predecessors: %bb.4
  successors: %bb.6(0x80000000); %bb.6(100.00%)


bb.6 (%ir-block.23):
; predecessors: %bb.5, %bb.6
  successors: %bb.7(0x04000000), %bb.6(0x7c000000); %bb.7(3.12%), %bb.6(96.88%)

  %8:gr64 = PHI %2:gr64, %bb.5, %13:gr64, %bb.6
  %9:gr64 = PHI %6:gr64, %bb.5, %12:gr64, %bb.6
  %10:gr64 = PHI %7:gr64, %bb.5, %11:gr64, %bb.6
  %11:gr64 = IMUL64rr %10:gr64(tied-def 0), %9:gr64, implicit-def dead $eflags
  %12:gr64 = nuw nsw INC64r %9:gr64(tied-def 0), implicit-def dead $eflags
  %13:gr64 = DEC64r %8:gr64(tied-def 0), implicit-def $eflags
  JCC_1 %bb.6, 5, implicit $eflags
  JMP_1 %bb.7

bb.7 (%ir-block.31):
; predecessors: %bb.0, %bb.4, %bb.6

  %14:gr64 = PHI %19:gr64, %bb.0, %5:gr64, %bb.4, %11:gr64, %bb.6
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %54:gr64 = LEA64r $rip, 1, $noreg, @.str.1, $noreg
  %55:gr32 = MOV32r0 implicit-def dead $eflags
  %56:gr8 = COPY %55.sub_8bit:gr32
  $rdi = COPY %54:gr64
  $rsi = COPY %14:gr64
  $al = COPY %56:gr8
  CALL64pcrel32 target-flags(x86-plt) @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %57:gr32 = COPY $eax
  LIFETIME_END %stack.0
  $eax = COPY %55:gr32
  RET 0, $eax

bb.8 (%ir-block.34):
; predecessors: %bb.2, %bb.8
  successors: %bb.3(0x04000000), %bb.8(0x7c000000); %bb.3(3.12%), %bb.8(96.88%)

  %15:gr64_nosp = PHI %33:gr64, %bb.2, %18:gr64, %bb.8
  %16:gr64 = PHI %34:gr64, %bb.2, %17:gr64, %bb.8
  %38:gr64 = ADD64ri32 %15:gr64_nosp(tied-def 0), -7, implicit-def dead $eflags
  %39:gr64 = IMUL64rr %16:gr64(tied-def 0), killed %38:gr64, implicit-def dead $eflags
  %40:gr64 = ADD64ri32 %15:gr64_nosp(tied-def 0), -6, implicit-def dead $eflags
  %41:gr64 = IMUL64rr %39:gr64(tied-def 0), killed %40:gr64, implicit-def dead $eflags
  %42:gr64 = ADD64ri32 %15:gr64_nosp(tied-def 0), -5, implicit-def dead $eflags
  %43:gr64 = IMUL64rr %41:gr64(tied-def 0), killed %42:gr64, implicit-def dead $eflags
  %44:gr64 = ADD64ri32 %15:gr64_nosp(tied-def 0), -4, implicit-def dead $eflags
  %45:gr64 = IMUL64rr %43:gr64(tied-def 0), killed %44:gr64, implicit-def dead $eflags
  %46:gr64 = ADD64ri32 %15:gr64_nosp(tied-def 0), -3, implicit-def dead $eflags
  %47:gr64 = IMUL64rr %45:gr64(tied-def 0), killed %46:gr64, implicit-def dead $eflags
  %48:gr64 = ADD64ri32 %15:gr64_nosp(tied-def 0), -2, implicit-def dead $eflags
  %49:gr64 = IMUL64rr %47:gr64(tied-def 0), killed %48:gr64, implicit-def dead $eflags
  %50:gr64 = DEC64r %15:gr64_nosp(tied-def 0), implicit-def dead $eflags
  %51:gr64 = IMUL64rr %49:gr64(tied-def 0), killed %50:gr64, implicit-def dead $eflags
  %17:gr64 = IMUL64rr %51:gr64(tied-def 0), %15:gr64_nosp, implicit-def dead $eflags
  %18:gr64 = ADD64ri32 %15:gr64_nosp(tied-def 0), 8, implicit-def dead $eflags
  %52:gr64 = LEA64r %3:gr64, 1, %15:gr64_nosp, 8, $noreg
  %53:gr64 = SUB64ri32 %52:gr64(tied-def 0), 8, implicit-def $eflags
  JCC_1 %bb.3, 4, implicit $eflags
  JMP_1 %bb.8

# End machine code for function main.

# *** IR Dump After Early Tail Duplication (early-tailduplication) ***:
# Machine code for function main: IsSSA, TracksLiveness
Frame Objects:
  fi#0: size=4, align=4, at location [SP+8]

bb.0 (%ir-block.0):
  successors: %bb.7(0x30000000), %bb.1(0x50000000); %bb.7(37.50%), %bb.1(62.50%)

  LIFETIME_START %stack.0
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %20:gr64 = LEA64r $rip, 1, $noreg, @.str, $noreg
  %21:gr32 = MOV32r0 implicit-def dead $eflags
  %22:gr8 = COPY %21.sub_8bit:gr32
  %23:gr64 = LEA64r %stack.0, 1, $noreg, 0, $noreg
  $rdi = COPY %20:gr64
  $rsi = COPY %23:gr64
  $al = COPY %22:gr8
  CALL64pcrel32 target-flags(x86-plt) @__isoc99_scanf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %24:gr32 = COPY $eax
  %25:gr32 = MOV32rm %stack.0, 1, $noreg, 0, $noreg :: (dereferenceable load (s32) from %ir.1, !tbaa !5)
  %0:gr64 = SUBREG_TO_REG 0, killed %25:gr32, %subreg.sub_32bit
  %26:gr32 = COPY %0.sub_32bit:gr64
  %19:gr64 = MOV32ri64 1
  TEST32rr %26:gr32, %26:gr32, implicit-def $eflags
  JCC_1 %bb.7, 14, implicit $eflags
  JMP_1 %bb.1

bb.1 (%ir-block.6):
; predecessors: %bb.0
  successors: %bb.4(0x40000000), %bb.2(0x40000000); %bb.4(50.00%), %bb.2(50.00%)

  %1:gr64 = COPY %0:gr64
  %29:gr64 = DEC64r %0:gr64(tied-def 0), implicit-def dead $eflags
  %30:gr32 = COPY %0.sub_32bit:gr64
  %31:gr32 = AND32ri %30:gr32(tied-def 0), 7, implicit-def dead $eflags
  %2:gr64 = SUBREG_TO_REG 0, killed %31:gr32, %subreg.sub_32bit
  %28:gr64 = MOV32ri64 1
  %27:gr64 = IMPLICIT_DEF
  %32:gr64 = SUB64ri32 %29:gr64(tied-def 0), 7, implicit-def $eflags
  JCC_1 %bb.4, 2, implicit $eflags
  JMP_1 %bb.2

bb.2 (%ir-block.12):
; predecessors: %bb.1
  successors: %bb.8(0x80000000); %bb.8(100.00%)

  %35:gr32 = COPY %1.sub_32bit:gr64
  %36:gr32 = AND32ri %35:gr32(tied-def 0), -8, implicit-def dead $eflags
  %37:gr64 = SUBREG_TO_REG 0, killed %36:gr32, %subreg.sub_32bit
  %3:gr64 = NEG64r %37:gr64(tied-def 0), implicit-def dead $eflags
  %34:gr64 = MOV32ri64 1
  %33:gr64 = MOV32ri64 8
  JMP_1 %bb.8

bb.3 (%ir-block.15):
; predecessors: %bb.8
  successors: %bb.4(0x80000000); %bb.4(100.00%)

  %4:gr64 = ADD64ri32 %18:gr64(tied-def 0), -7, implicit-def dead $eflags

bb.4 (%ir-block.17):
; predecessors: %bb.1, %bb.3
  successors: %bb.7(0x30000000), %bb.5(0x50000000); %bb.7(37.50%), %bb.5(62.50%)

  %5:gr64 = PHI %27:gr64, %bb.1, %17:gr64, %bb.3
  %6:gr64 = PHI %28:gr64, %bb.1, %4:gr64, %bb.3
  %7:gr64 = PHI %28:gr64, %bb.1, %17:gr64, %bb.3
  TEST64rr %2:gr64, %2:gr64, implicit-def $eflags
  JCC_1 %bb.7, 4, implicit $eflags
  JMP_1 %bb.5

bb.5 (%ir-block.22):
; predecessors: %bb.4
  successors: %bb.6(0x80000000); %bb.6(100.00%)


bb.6 (%ir-block.23):
; predecessors: %bb.5, %bb.6
  successors: %bb.7(0x04000000), %bb.6(0x7c000000); %bb.7(3.12%), %bb.6(96.88%)

  %8:gr64 = PHI %2:gr64, %bb.5, %13:gr64, %bb.6
  %9:gr64 = PHI %6:gr64, %bb.5, %12:gr64, %bb.6
  %10:gr64 = PHI %7:gr64, %bb.5, %11:gr64, %bb.6
  %11:gr64 = IMUL64rr %10:gr64(tied-def 0), %9:gr64, implicit-def dead $eflags
  %12:gr64 = nuw nsw INC64r %9:gr64(tied-def 0), implicit-def dead $eflags
  %13:gr64 = DEC64r %8:gr64(tied-def 0), implicit-def $eflags
  JCC_1 %bb.6, 5, implicit $eflags
  JMP_1 %bb.7

bb.7 (%ir-block.31):
; predecessors: %bb.0, %bb.4, %bb.6

  %14:gr64 = PHI %19:gr64, %bb.0, %5:gr64, %bb.4, %11:gr64, %bb.6
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %54:gr64 = LEA64r $rip, 1, $noreg, @.str.1, $noreg
  %55:gr32 = MOV32r0 implicit-def dead $eflags
  %56:gr8 = COPY %55.sub_8bit:gr32
  $rdi = COPY %54:gr64
  $rsi = COPY %14:gr64
  $al = COPY %56:gr8
  CALL64pcrel32 target-flags(x86-plt) @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %57:gr32 = COPY $eax
  LIFETIME_END %stack.0
  $eax = COPY %55:gr32
  RET 0, $eax

bb.8 (%ir-block.34):
; predecessors: %bb.2, %bb.8
  successors: %bb.3(0x04000000), %bb.8(0x7c000000); %bb.3(3.12%), %bb.8(96.88%)

  %15:gr64_nosp = PHI %33:gr64, %bb.2, %18:gr64, %bb.8
  %16:gr64 = PHI %34:gr64, %bb.2, %17:gr64, %bb.8
  %38:gr64 = ADD64ri32 %15:gr64_nosp(tied-def 0), -7, implicit-def dead $eflags
  %39:gr64 = IMUL64rr %16:gr64(tied-def 0), killed %38:gr64, implicit-def dead $eflags
  %40:gr64 = ADD64ri32 %15:gr64_nosp(tied-def 0), -6, implicit-def dead $eflags
  %41:gr64 = IMUL64rr %39:gr64(tied-def 0), killed %40:gr64, implicit-def dead $eflags
  %42:gr64 = ADD64ri32 %15:gr64_nosp(tied-def 0), -5, implicit-def dead $eflags
  %43:gr64 = IMUL64rr %41:gr64(tied-def 0), killed %42:gr64, implicit-def dead $eflags
  %44:gr64 = ADD64ri32 %15:gr64_nosp(tied-def 0), -4, implicit-def dead $eflags
  %45:gr64 = IMUL64rr %43:gr64(tied-def 0), killed %44:gr64, implicit-def dead $eflags
  %46:gr64 = ADD64ri32 %15:gr64_nosp(tied-def 0), -3, implicit-def dead $eflags
  %47:gr64 = IMUL64rr %45:gr64(tied-def 0), killed %46:gr64, implicit-def dead $eflags
  %48:gr64 = ADD64ri32 %15:gr64_nosp(tied-def 0), -2, implicit-def dead $eflags
  %49:gr64 = IMUL64rr %47:gr64(tied-def 0), killed %48:gr64, implicit-def dead $eflags
  %50:gr64 = DEC64r %15:gr64_nosp(tied-def 0), implicit-def dead $eflags
  %51:gr64 = IMUL64rr %49:gr64(tied-def 0), killed %50:gr64, implicit-def dead $eflags
  %17:gr64 = IMUL64rr %51:gr64(tied-def 0), %15:gr64_nosp, implicit-def dead $eflags
  %18:gr64 = ADD64ri32 %15:gr64_nosp(tied-def 0), 8, implicit-def dead $eflags
  %52:gr64 = LEA64r %3:gr64, 1, %15:gr64_nosp, 8, $noreg
  %53:gr64 = SUB64ri32 %52:gr64(tied-def 0), 8, implicit-def $eflags
  JCC_1 %bb.3, 4, implicit $eflags
  JMP_1 %bb.8

# End machine code for function main.

# *** IR Dump After Optimize machine instruction PHIs (opt-phis) ***:
# Machine code for function main: IsSSA, TracksLiveness
Frame Objects:
  fi#0: size=4, align=4, at location [SP+8]

bb.0 (%ir-block.0):
  successors: %bb.7(0x30000000), %bb.1(0x50000000); %bb.7(37.50%), %bb.1(62.50%)

  LIFETIME_START %stack.0
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %20:gr64 = LEA64r $rip, 1, $noreg, @.str, $noreg
  %21:gr32 = MOV32r0 implicit-def dead $eflags
  %22:gr8 = COPY %21.sub_8bit:gr32
  %23:gr64 = LEA64r %stack.0, 1, $noreg, 0, $noreg
  $rdi = COPY %20:gr64
  $rsi = COPY %23:gr64
  $al = COPY %22:gr8
  CALL64pcrel32 target-flags(x86-plt) @__isoc99_scanf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %24:gr32 = COPY $eax
  %25:gr32 = MOV32rm %stack.0, 1, $noreg, 0, $noreg :: (dereferenceable load (s32) from %ir.1, !tbaa !5)
  %0:gr64 = SUBREG_TO_REG 0, killed %25:gr32, %subreg.sub_32bit
  %26:gr32 = COPY %0.sub_32bit:gr64
  %19:gr64 = MOV32ri64 1
  TEST32rr %26:gr32, %26:gr32, implicit-def $eflags
  JCC_1 %bb.7, 14, implicit $eflags
  JMP_1 %bb.1

bb.1 (%ir-block.6):
; predecessors: %bb.0
  successors: %bb.4(0x40000000), %bb.2(0x40000000); %bb.4(50.00%), %bb.2(50.00%)

  %1:gr64 = COPY %0:gr64
  %29:gr64 = DEC64r %0:gr64(tied-def 0), implicit-def dead $eflags
  %30:gr32 = COPY %0.sub_32bit:gr64
  %31:gr32 = AND32ri %30:gr32(tied-def 0), 7, implicit-def dead $eflags
  %2:gr64 = SUBREG_TO_REG 0, killed %31:gr32, %subreg.sub_32bit
  %28:gr64 = MOV32ri64 1
  %27:gr64 = IMPLICIT_DEF
  %32:gr64 = SUB64ri32 %29:gr64(tied-def 0), 7, implicit-def $eflags
  JCC_1 %bb.4, 2, implicit $eflags
  JMP_1 %bb.2

bb.2 (%ir-block.12):
; predecessors: %bb.1
  successors: %bb.8(0x80000000); %bb.8(100.00%)

  %35:gr32 = COPY %1.sub_32bit:gr64
  %36:gr32 = AND32ri %35:gr32(tied-def 0), -8, implicit-def dead $eflags
  %37:gr64 = SUBREG_TO_REG 0, killed %36:gr32, %subreg.sub_32bit
  %3:gr64 = NEG64r %37:gr64(tied-def 0), implicit-def dead $eflags
  %34:gr64 = MOV32ri64 1
  %33:gr64 = MOV32ri64 8
  JMP_1 %bb.8

bb.3 (%ir-block.15):
; predecessors: %bb.8
  successors: %bb.4(0x80000000); %bb.4(100.00%)

  %4:gr64 = ADD64ri32 %18:gr64(tied-def 0), -7, implicit-def dead $eflags

bb.4 (%ir-block.17):
; predecessors: %bb.1, %bb.3
  successors: %bb.7(0x30000000), %bb.5(0x50000000); %bb.7(37.50%), %bb.5(62.50%)

  %5:gr64 = PHI %27:gr64, %bb.1, %17:gr64, %bb.3
  %6:gr64 = PHI %28:gr64, %bb.1, %4:gr64, %bb.3
  %7:gr64 = PHI %28:gr64, %bb.1, %17:gr64, %bb.3
  TEST64rr %2:gr64, %2:gr64, implicit-def $eflags
  JCC_1 %bb.7, 4, implicit $eflags
  JMP_1 %bb.5

bb.5 (%ir-block.22):
; predecessors: %bb.4
  successors: %bb.6(0x80000000); %bb.6(100.00%)


bb.6 (%ir-block.23):
; predecessors: %bb.5, %bb.6
  successors: %bb.7(0x04000000), %bb.6(0x7c000000); %bb.7(3.12%), %bb.6(96.88%)

  %8:gr64 = PHI %2:gr64, %bb.5, %13:gr64, %bb.6
  %9:gr64 = PHI %6:gr64, %bb.5, %12:gr64, %bb.6
  %10:gr64 = PHI %7:gr64, %bb.5, %11:gr64, %bb.6
  %11:gr64 = IMUL64rr %10:gr64(tied-def 0), %9:gr64, implicit-def dead $eflags
  %12:gr64 = nuw nsw INC64r %9:gr64(tied-def 0), implicit-def dead $eflags
  %13:gr64 = DEC64r %8:gr64(tied-def 0), implicit-def $eflags
  JCC_1 %bb.6, 5, implicit $eflags
  JMP_1 %bb.7

bb.7 (%ir-block.31):
; predecessors: %bb.0, %bb.4, %bb.6

  %14:gr64 = PHI %19:gr64, %bb.0, %5:gr64, %bb.4, %11:gr64, %bb.6
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %54:gr64 = LEA64r $rip, 1, $noreg, @.str.1, $noreg
  %55:gr32 = MOV32r0 implicit-def dead $eflags
  %56:gr8 = COPY %55.sub_8bit:gr32
  $rdi = COPY %54:gr64
  $rsi = COPY %14:gr64
  $al = COPY %56:gr8
  CALL64pcrel32 target-flags(x86-plt) @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %57:gr32 = COPY $eax
  LIFETIME_END %stack.0
  $eax = COPY %55:gr32
  RET 0, $eax

bb.8 (%ir-block.34):
; predecessors: %bb.2, %bb.8
  successors: %bb.3(0x04000000), %bb.8(0x7c000000); %bb.3(3.12%), %bb.8(96.88%)

  %15:gr64_nosp = PHI %33:gr64, %bb.2, %18:gr64, %bb.8
  %16:gr64 = PHI %34:gr64, %bb.2, %17:gr64, %bb.8
  %38:gr64 = ADD64ri32 %15:gr64_nosp(tied-def 0), -7, implicit-def dead $eflags
  %39:gr64 = IMUL64rr %16:gr64(tied-def 0), killed %38:gr64, implicit-def dead $eflags
  %40:gr64 = ADD64ri32 %15:gr64_nosp(tied-def 0), -6, implicit-def dead $eflags
  %41:gr64 = IMUL64rr %39:gr64(tied-def 0), killed %40:gr64, implicit-def dead $eflags
  %42:gr64 = ADD64ri32 %15:gr64_nosp(tied-def 0), -5, implicit-def dead $eflags
  %43:gr64 = IMUL64rr %41:gr64(tied-def 0), killed %42:gr64, implicit-def dead $eflags
  %44:gr64 = ADD64ri32 %15:gr64_nosp(tied-def 0), -4, implicit-def dead $eflags
  %45:gr64 = IMUL64rr %43:gr64(tied-def 0), killed %44:gr64, implicit-def dead $eflags
  %46:gr64 = ADD64ri32 %15:gr64_nosp(tied-def 0), -3, implicit-def dead $eflags
  %47:gr64 = IMUL64rr %45:gr64(tied-def 0), killed %46:gr64, implicit-def dead $eflags
  %48:gr64 = ADD64ri32 %15:gr64_nosp(tied-def 0), -2, implicit-def dead $eflags
  %49:gr64 = IMUL64rr %47:gr64(tied-def 0), killed %48:gr64, implicit-def dead $eflags
  %50:gr64 = DEC64r %15:gr64_nosp(tied-def 0), implicit-def dead $eflags
  %51:gr64 = IMUL64rr %49:gr64(tied-def 0), killed %50:gr64, implicit-def dead $eflags
  %17:gr64 = IMUL64rr %51:gr64(tied-def 0), %15:gr64_nosp, implicit-def dead $eflags
  %18:gr64 = ADD64ri32 %15:gr64_nosp(tied-def 0), 8, implicit-def dead $eflags
  %52:gr64 = LEA64r %3:gr64, 1, %15:gr64_nosp, 8, $noreg
  %53:gr64 = SUB64ri32 %52:gr64(tied-def 0), 8, implicit-def $eflags
  JCC_1 %bb.3, 4, implicit $eflags
  JMP_1 %bb.8

# End machine code for function main.

# *** IR Dump After Slot index numbering (slotindexes) ***:
# Machine code for function main: IsSSA, TracksLiveness
Frame Objects:
  fi#0: size=4, align=4, at location [SP+8]

0B	bb.0 (%ir-block.0):
	  successors: %bb.7(0x30000000), %bb.1(0x50000000); %bb.7(37.50%), %bb.1(62.50%)

16B	  LIFETIME_START %stack.0
32B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
48B	  %20:gr64 = LEA64r $rip, 1, $noreg, @.str, $noreg
64B	  %21:gr32 = MOV32r0 implicit-def dead $eflags
80B	  %22:gr8 = COPY %21.sub_8bit:gr32
96B	  %23:gr64 = LEA64r %stack.0, 1, $noreg, 0, $noreg
112B	  $rdi = COPY %20:gr64
128B	  $rsi = COPY %23:gr64
144B	  $al = COPY %22:gr8
160B	  CALL64pcrel32 target-flags(x86-plt) @__isoc99_scanf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
176B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
192B	  %24:gr32 = COPY $eax
208B	  %25:gr32 = MOV32rm %stack.0, 1, $noreg, 0, $noreg :: (dereferenceable load (s32) from %ir.1, !tbaa !5)
224B	  %0:gr64 = SUBREG_TO_REG 0, killed %25:gr32, %subreg.sub_32bit
240B	  %26:gr32 = COPY %0.sub_32bit:gr64
256B	  %19:gr64 = MOV32ri64 1
272B	  TEST32rr %26:gr32, %26:gr32, implicit-def $eflags
288B	  JCC_1 %bb.7, 14, implicit $eflags
304B	  JMP_1 %bb.1

320B	bb.1 (%ir-block.6):
	; predecessors: %bb.0
	  successors: %bb.4(0x40000000), %bb.2(0x40000000); %bb.4(50.00%), %bb.2(50.00%)

336B	  %1:gr64 = COPY %0:gr64
352B	  %29:gr64 = DEC64r %0:gr64(tied-def 0), implicit-def dead $eflags
368B	  %30:gr32 = COPY %0.sub_32bit:gr64
384B	  %31:gr32 = AND32ri %30:gr32(tied-def 0), 7, implicit-def dead $eflags
400B	  %2:gr64 = SUBREG_TO_REG 0, killed %31:gr32, %subreg.sub_32bit
416B	  %28:gr64 = MOV32ri64 1
432B	  %27:gr64 = IMPLICIT_DEF
448B	  %32:gr64 = SUB64ri32 %29:gr64(tied-def 0), 7, implicit-def $eflags
464B	  JCC_1 %bb.4, 2, implicit $eflags
480B	  JMP_1 %bb.2

496B	bb.2 (%ir-block.12):
	; predecessors: %bb.1
	  successors: %bb.8(0x80000000); %bb.8(100.00%)

512B	  %35:gr32 = COPY %1.sub_32bit:gr64
528B	  %36:gr32 = AND32ri %35:gr32(tied-def 0), -8, implicit-def dead $eflags
544B	  %37:gr64 = SUBREG_TO_REG 0, killed %36:gr32, %subreg.sub_32bit
560B	  %3:gr64 = NEG64r %37:gr64(tied-def 0), implicit-def dead $eflags
576B	  %34:gr64 = MOV32ri64 1
592B	  %33:gr64 = MOV32ri64 8
608B	  JMP_1 %bb.8

624B	bb.3 (%ir-block.15):
	; predecessors: %bb.8
	  successors: %bb.4(0x80000000); %bb.4(100.00%)

640B	  %4:gr64 = ADD64ri32 %18:gr64(tied-def 0), -7, implicit-def dead $eflags

656B	bb.4 (%ir-block.17):
	; predecessors: %bb.1, %bb.3
	  successors: %bb.7(0x30000000), %bb.5(0x50000000); %bb.7(37.50%), %bb.5(62.50%)

672B	  %5:gr64 = PHI %27:gr64, %bb.1, %17:gr64, %bb.3
688B	  %6:gr64 = PHI %28:gr64, %bb.1, %4:gr64, %bb.3
704B	  %7:gr64 = PHI %28:gr64, %bb.1, %17:gr64, %bb.3
720B	  TEST64rr %2:gr64, %2:gr64, implicit-def $eflags
736B	  JCC_1 %bb.7, 4, implicit $eflags
752B	  JMP_1 %bb.5

768B	bb.5 (%ir-block.22):
	; predecessors: %bb.4
	  successors: %bb.6(0x80000000); %bb.6(100.00%)


784B	bb.6 (%ir-block.23):
	; predecessors: %bb.5, %bb.6
	  successors: %bb.7(0x04000000), %bb.6(0x7c000000); %bb.7(3.12%), %bb.6(96.88%)

800B	  %8:gr64 = PHI %2:gr64, %bb.5, %13:gr64, %bb.6
816B	  %9:gr64 = PHI %6:gr64, %bb.5, %12:gr64, %bb.6
832B	  %10:gr64 = PHI %7:gr64, %bb.5, %11:gr64, %bb.6
848B	  %11:gr64 = IMUL64rr %10:gr64(tied-def 0), %9:gr64, implicit-def dead $eflags
864B	  %12:gr64 = nuw nsw INC64r %9:gr64(tied-def 0), implicit-def dead $eflags
880B	  %13:gr64 = DEC64r %8:gr64(tied-def 0), implicit-def $eflags
896B	  JCC_1 %bb.6, 5, implicit $eflags
912B	  JMP_1 %bb.7

928B	bb.7 (%ir-block.31):
	; predecessors: %bb.0, %bb.4, %bb.6

944B	  %14:gr64 = PHI %19:gr64, %bb.0, %5:gr64, %bb.4, %11:gr64, %bb.6
960B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
976B	  %54:gr64 = LEA64r $rip, 1, $noreg, @.str.1, $noreg
992B	  %55:gr32 = MOV32r0 implicit-def dead $eflags
1008B	  %56:gr8 = COPY %55.sub_8bit:gr32
1024B	  $rdi = COPY %54:gr64
1040B	  $rsi = COPY %14:gr64
1056B	  $al = COPY %56:gr8
1072B	  CALL64pcrel32 target-flags(x86-plt) @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
1088B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
1104B	  %57:gr32 = COPY $eax
1120B	  LIFETIME_END %stack.0
1136B	  $eax = COPY %55:gr32
1152B	  RET 0, $eax

1168B	bb.8 (%ir-block.34):
	; predecessors: %bb.2, %bb.8
	  successors: %bb.3(0x04000000), %bb.8(0x7c000000); %bb.3(3.12%), %bb.8(96.88%)

1184B	  %15:gr64_nosp = PHI %33:gr64, %bb.2, %18:gr64, %bb.8
1200B	  %16:gr64 = PHI %34:gr64, %bb.2, %17:gr64, %bb.8
1216B	  %38:gr64 = ADD64ri32 %15:gr64_nosp(tied-def 0), -7, implicit-def dead $eflags
1232B	  %39:gr64 = IMUL64rr %16:gr64(tied-def 0), killed %38:gr64, implicit-def dead $eflags
1248B	  %40:gr64 = ADD64ri32 %15:gr64_nosp(tied-def 0), -6, implicit-def dead $eflags
1264B	  %41:gr64 = IMUL64rr %39:gr64(tied-def 0), killed %40:gr64, implicit-def dead $eflags
1280B	  %42:gr64 = ADD64ri32 %15:gr64_nosp(tied-def 0), -5, implicit-def dead $eflags
1296B	  %43:gr64 = IMUL64rr %41:gr64(tied-def 0), killed %42:gr64, implicit-def dead $eflags
1312B	  %44:gr64 = ADD64ri32 %15:gr64_nosp(tied-def 0), -4, implicit-def dead $eflags
1328B	  %45:gr64 = IMUL64rr %43:gr64(tied-def 0), killed %44:gr64, implicit-def dead $eflags
1344B	  %46:gr64 = ADD64ri32 %15:gr64_nosp(tied-def 0), -3, implicit-def dead $eflags
1360B	  %47:gr64 = IMUL64rr %45:gr64(tied-def 0), killed %46:gr64, implicit-def dead $eflags
1376B	  %48:gr64 = ADD64ri32 %15:gr64_nosp(tied-def 0), -2, implicit-def dead $eflags
1392B	  %49:gr64 = IMUL64rr %47:gr64(tied-def 0), killed %48:gr64, implicit-def dead $eflags
1408B	  %50:gr64 = DEC64r %15:gr64_nosp(tied-def 0), implicit-def dead $eflags
1424B	  %51:gr64 = IMUL64rr %49:gr64(tied-def 0), killed %50:gr64, implicit-def dead $eflags
1440B	  %17:gr64 = IMUL64rr %51:gr64(tied-def 0), %15:gr64_nosp, implicit-def dead $eflags
1456B	  %18:gr64 = ADD64ri32 %15:gr64_nosp(tied-def 0), 8, implicit-def dead $eflags
1472B	  %52:gr64 = LEA64r %3:gr64, 1, %15:gr64_nosp, 8, $noreg
1488B	  %53:gr64 = SUB64ri32 %52:gr64(tied-def 0), 8, implicit-def $eflags
1504B	  JCC_1 %bb.3, 4, implicit $eflags
1520B	  JMP_1 %bb.8

# End machine code for function main.

# *** IR Dump After Merge disjoint stack slots (stack-coloring) ***:
# Machine code for function main: IsSSA, TracksLiveness
Frame Objects:
  fi#0: size=4, align=4, at location [SP+8]

bb.0 (%ir-block.0):
  successors: %bb.7(0x30000000), %bb.1(0x50000000); %bb.7(37.50%), %bb.1(62.50%)

  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %20:gr64 = LEA64r $rip, 1, $noreg, @.str, $noreg
  %21:gr32 = MOV32r0 implicit-def dead $eflags
  %22:gr8 = COPY %21.sub_8bit:gr32
  %23:gr64 = LEA64r %stack.0, 1, $noreg, 0, $noreg
  $rdi = COPY %20:gr64
  $rsi = COPY %23:gr64
  $al = COPY %22:gr8
  CALL64pcrel32 target-flags(x86-plt) @__isoc99_scanf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %24:gr32 = COPY $eax
  %25:gr32 = MOV32rm %stack.0, 1, $noreg, 0, $noreg :: (dereferenceable load (s32) from %ir.1, !tbaa !5)
  %0:gr64 = SUBREG_TO_REG 0, killed %25:gr32, %subreg.sub_32bit
  %26:gr32 = COPY %0.sub_32bit:gr64
  %19:gr64 = MOV32ri64 1
  TEST32rr %26:gr32, %26:gr32, implicit-def $eflags
  JCC_1 %bb.7, 14, implicit $eflags
  JMP_1 %bb.1

bb.1 (%ir-block.6):
; predecessors: %bb.0
  successors: %bb.4(0x40000000), %bb.2(0x40000000); %bb.4(50.00%), %bb.2(50.00%)

  %1:gr64 = COPY %0:gr64
  %29:gr64 = DEC64r %0:gr64(tied-def 0), implicit-def dead $eflags
  %30:gr32 = COPY %0.sub_32bit:gr64
  %31:gr32 = AND32ri %30:gr32(tied-def 0), 7, implicit-def dead $eflags
  %2:gr64 = SUBREG_TO_REG 0, killed %31:gr32, %subreg.sub_32bit
  %28:gr64 = MOV32ri64 1
  %27:gr64 = IMPLICIT_DEF
  %32:gr64 = SUB64ri32 %29:gr64(tied-def 0), 7, implicit-def $eflags
  JCC_1 %bb.4, 2, implicit $eflags
  JMP_1 %bb.2

bb.2 (%ir-block.12):
; predecessors: %bb.1
  successors: %bb.8(0x80000000); %bb.8(100.00%)

  %35:gr32 = COPY %1.sub_32bit:gr64
  %36:gr32 = AND32ri %35:gr32(tied-def 0), -8, implicit-def dead $eflags
  %37:gr64 = SUBREG_TO_REG 0, killed %36:gr32, %subreg.sub_32bit
  %3:gr64 = NEG64r %37:gr64(tied-def 0), implicit-def dead $eflags
  %34:gr64 = MOV32ri64 1
  %33:gr64 = MOV32ri64 8
  JMP_1 %bb.8

bb.3 (%ir-block.15):
; predecessors: %bb.8
  successors: %bb.4(0x80000000); %bb.4(100.00%)

  %4:gr64 = ADD64ri32 %18:gr64(tied-def 0), -7, implicit-def dead $eflags

bb.4 (%ir-block.17):
; predecessors: %bb.1, %bb.3
  successors: %bb.7(0x30000000), %bb.5(0x50000000); %bb.7(37.50%), %bb.5(62.50%)

  %5:gr64 = PHI %27:gr64, %bb.1, %17:gr64, %bb.3
  %6:gr64 = PHI %28:gr64, %bb.1, %4:gr64, %bb.3
  %7:gr64 = PHI %28:gr64, %bb.1, %17:gr64, %bb.3
  TEST64rr %2:gr64, %2:gr64, implicit-def $eflags
  JCC_1 %bb.7, 4, implicit $eflags
  JMP_1 %bb.5

bb.5 (%ir-block.22):
; predecessors: %bb.4
  successors: %bb.6(0x80000000); %bb.6(100.00%)


bb.6 (%ir-block.23):
; predecessors: %bb.5, %bb.6
  successors: %bb.7(0x04000000), %bb.6(0x7c000000); %bb.7(3.12%), %bb.6(96.88%)

  %8:gr64 = PHI %2:gr64, %bb.5, %13:gr64, %bb.6
  %9:gr64 = PHI %6:gr64, %bb.5, %12:gr64, %bb.6
  %10:gr64 = PHI %7:gr64, %bb.5, %11:gr64, %bb.6
  %11:gr64 = IMUL64rr %10:gr64(tied-def 0), %9:gr64, implicit-def dead $eflags
  %12:gr64 = nuw nsw INC64r %9:gr64(tied-def 0), implicit-def dead $eflags
  %13:gr64 = DEC64r %8:gr64(tied-def 0), implicit-def $eflags
  JCC_1 %bb.6, 5, implicit $eflags
  JMP_1 %bb.7

bb.7 (%ir-block.31):
; predecessors: %bb.0, %bb.4, %bb.6

  %14:gr64 = PHI %19:gr64, %bb.0, %5:gr64, %bb.4, %11:gr64, %bb.6
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %54:gr64 = LEA64r $rip, 1, $noreg, @.str.1, $noreg
  %55:gr32 = MOV32r0 implicit-def dead $eflags
  %56:gr8 = COPY %55.sub_8bit:gr32
  $rdi = COPY %54:gr64
  $rsi = COPY %14:gr64
  $al = COPY %56:gr8
  CALL64pcrel32 target-flags(x86-plt) @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %57:gr32 = COPY $eax
  $eax = COPY %55:gr32
  RET 0, $eax

bb.8 (%ir-block.34):
; predecessors: %bb.2, %bb.8
  successors: %bb.3(0x04000000), %bb.8(0x7c000000); %bb.3(3.12%), %bb.8(96.88%)

  %15:gr64_nosp = PHI %33:gr64, %bb.2, %18:gr64, %bb.8
  %16:gr64 = PHI %34:gr64, %bb.2, %17:gr64, %bb.8
  %38:gr64 = ADD64ri32 %15:gr64_nosp(tied-def 0), -7, implicit-def dead $eflags
  %39:gr64 = IMUL64rr %16:gr64(tied-def 0), killed %38:gr64, implicit-def dead $eflags
  %40:gr64 = ADD64ri32 %15:gr64_nosp(tied-def 0), -6, implicit-def dead $eflags
  %41:gr64 = IMUL64rr %39:gr64(tied-def 0), killed %40:gr64, implicit-def dead $eflags
  %42:gr64 = ADD64ri32 %15:gr64_nosp(tied-def 0), -5, implicit-def dead $eflags
  %43:gr64 = IMUL64rr %41:gr64(tied-def 0), killed %42:gr64, implicit-def dead $eflags
  %44:gr64 = ADD64ri32 %15:gr64_nosp(tied-def 0), -4, implicit-def dead $eflags
  %45:gr64 = IMUL64rr %43:gr64(tied-def 0), killed %44:gr64, implicit-def dead $eflags
  %46:gr64 = ADD64ri32 %15:gr64_nosp(tied-def 0), -3, implicit-def dead $eflags
  %47:gr64 = IMUL64rr %45:gr64(tied-def 0), killed %46:gr64, implicit-def dead $eflags
  %48:gr64 = ADD64ri32 %15:gr64_nosp(tied-def 0), -2, implicit-def dead $eflags
  %49:gr64 = IMUL64rr %47:gr64(tied-def 0), killed %48:gr64, implicit-def dead $eflags
  %50:gr64 = DEC64r %15:gr64_nosp(tied-def 0), implicit-def dead $eflags
  %51:gr64 = IMUL64rr %49:gr64(tied-def 0), killed %50:gr64, implicit-def dead $eflags
  %17:gr64 = IMUL64rr %51:gr64(tied-def 0), %15:gr64_nosp, implicit-def dead $eflags
  %18:gr64 = ADD64ri32 %15:gr64_nosp(tied-def 0), 8, implicit-def dead $eflags
  %52:gr64 = LEA64r %3:gr64, 1, %15:gr64_nosp, 8, $noreg
  %53:gr64 = SUB64ri32 %52:gr64(tied-def 0), 8, implicit-def $eflags
  JCC_1 %bb.3, 4, implicit $eflags
  JMP_1 %bb.8

# End machine code for function main.

# *** IR Dump After Local Stack Slot Allocation (localstackalloc) ***:
# Machine code for function main: IsSSA, TracksLiveness
Frame Objects:
  fi#0: size=4, align=4, at location [SP+8]

bb.0 (%ir-block.0):
  successors: %bb.7(0x30000000), %bb.1(0x50000000); %bb.7(37.50%), %bb.1(62.50%)

  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %20:gr64 = LEA64r $rip, 1, $noreg, @.str, $noreg
  %21:gr32 = MOV32r0 implicit-def dead $eflags
  %22:gr8 = COPY %21.sub_8bit:gr32
  %23:gr64 = LEA64r %stack.0, 1, $noreg, 0, $noreg
  $rdi = COPY %20:gr64
  $rsi = COPY %23:gr64
  $al = COPY %22:gr8
  CALL64pcrel32 target-flags(x86-plt) @__isoc99_scanf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %24:gr32 = COPY $eax
  %25:gr32 = MOV32rm %stack.0, 1, $noreg, 0, $noreg :: (dereferenceable load (s32) from %ir.1, !tbaa !5)
  %0:gr64 = SUBREG_TO_REG 0, killed %25:gr32, %subreg.sub_32bit
  %26:gr32 = COPY %0.sub_32bit:gr64
  %19:gr64 = MOV32ri64 1
  TEST32rr %26:gr32, %26:gr32, implicit-def $eflags
  JCC_1 %bb.7, 14, implicit $eflags
  JMP_1 %bb.1

bb.1 (%ir-block.6):
; predecessors: %bb.0
  successors: %bb.4(0x40000000), %bb.2(0x40000000); %bb.4(50.00%), %bb.2(50.00%)

  %1:gr64 = COPY %0:gr64
  %29:gr64 = DEC64r %0:gr64(tied-def 0), implicit-def dead $eflags
  %30:gr32 = COPY %0.sub_32bit:gr64
  %31:gr32 = AND32ri %30:gr32(tied-def 0), 7, implicit-def dead $eflags
  %2:gr64 = SUBREG_TO_REG 0, killed %31:gr32, %subreg.sub_32bit
  %28:gr64 = MOV32ri64 1
  %27:gr64 = IMPLICIT_DEF
  %32:gr64 = SUB64ri32 %29:gr64(tied-def 0), 7, implicit-def $eflags
  JCC_1 %bb.4, 2, implicit $eflags
  JMP_1 %bb.2

bb.2 (%ir-block.12):
; predecessors: %bb.1
  successors: %bb.8(0x80000000); %bb.8(100.00%)

  %35:gr32 = COPY %1.sub_32bit:gr64
  %36:gr32 = AND32ri %35:gr32(tied-def 0), -8, implicit-def dead $eflags
  %37:gr64 = SUBREG_TO_REG 0, killed %36:gr32, %subreg.sub_32bit
  %3:gr64 = NEG64r %37:gr64(tied-def 0), implicit-def dead $eflags
  %34:gr64 = MOV32ri64 1
  %33:gr64 = MOV32ri64 8
  JMP_1 %bb.8

bb.3 (%ir-block.15):
; predecessors: %bb.8
  successors: %bb.4(0x80000000); %bb.4(100.00%)

  %4:gr64 = ADD64ri32 %18:gr64(tied-def 0), -7, implicit-def dead $eflags

bb.4 (%ir-block.17):
; predecessors: %bb.1, %bb.3
  successors: %bb.7(0x30000000), %bb.5(0x50000000); %bb.7(37.50%), %bb.5(62.50%)

  %5:gr64 = PHI %27:gr64, %bb.1, %17:gr64, %bb.3
  %6:gr64 = PHI %28:gr64, %bb.1, %4:gr64, %bb.3
  %7:gr64 = PHI %28:gr64, %bb.1, %17:gr64, %bb.3
  TEST64rr %2:gr64, %2:gr64, implicit-def $eflags
  JCC_1 %bb.7, 4, implicit $eflags
  JMP_1 %bb.5

bb.5 (%ir-block.22):
; predecessors: %bb.4
  successors: %bb.6(0x80000000); %bb.6(100.00%)


bb.6 (%ir-block.23):
; predecessors: %bb.5, %bb.6
  successors: %bb.7(0x04000000), %bb.6(0x7c000000); %bb.7(3.12%), %bb.6(96.88%)

  %8:gr64 = PHI %2:gr64, %bb.5, %13:gr64, %bb.6
  %9:gr64 = PHI %6:gr64, %bb.5, %12:gr64, %bb.6
  %10:gr64 = PHI %7:gr64, %bb.5, %11:gr64, %bb.6
  %11:gr64 = IMUL64rr %10:gr64(tied-def 0), %9:gr64, implicit-def dead $eflags
  %12:gr64 = nuw nsw INC64r %9:gr64(tied-def 0), implicit-def dead $eflags
  %13:gr64 = DEC64r %8:gr64(tied-def 0), implicit-def $eflags
  JCC_1 %bb.6, 5, implicit $eflags
  JMP_1 %bb.7

bb.7 (%ir-block.31):
; predecessors: %bb.0, %bb.4, %bb.6

  %14:gr64 = PHI %19:gr64, %bb.0, %5:gr64, %bb.4, %11:gr64, %bb.6
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %54:gr64 = LEA64r $rip, 1, $noreg, @.str.1, $noreg
  %55:gr32 = MOV32r0 implicit-def dead $eflags
  %56:gr8 = COPY %55.sub_8bit:gr32
  $rdi = COPY %54:gr64
  $rsi = COPY %14:gr64
  $al = COPY %56:gr8
  CALL64pcrel32 target-flags(x86-plt) @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %57:gr32 = COPY $eax
  $eax = COPY %55:gr32
  RET 0, $eax

bb.8 (%ir-block.34):
; predecessors: %bb.2, %bb.8
  successors: %bb.3(0x04000000), %bb.8(0x7c000000); %bb.3(3.12%), %bb.8(96.88%)

  %15:gr64_nosp = PHI %33:gr64, %bb.2, %18:gr64, %bb.8
  %16:gr64 = PHI %34:gr64, %bb.2, %17:gr64, %bb.8
  %38:gr64 = ADD64ri32 %15:gr64_nosp(tied-def 0), -7, implicit-def dead $eflags
  %39:gr64 = IMUL64rr %16:gr64(tied-def 0), killed %38:gr64, implicit-def dead $eflags
  %40:gr64 = ADD64ri32 %15:gr64_nosp(tied-def 0), -6, implicit-def dead $eflags
  %41:gr64 = IMUL64rr %39:gr64(tied-def 0), killed %40:gr64, implicit-def dead $eflags
  %42:gr64 = ADD64ri32 %15:gr64_nosp(tied-def 0), -5, implicit-def dead $eflags
  %43:gr64 = IMUL64rr %41:gr64(tied-def 0), killed %42:gr64, implicit-def dead $eflags
  %44:gr64 = ADD64ri32 %15:gr64_nosp(tied-def 0), -4, implicit-def dead $eflags
  %45:gr64 = IMUL64rr %43:gr64(tied-def 0), killed %44:gr64, implicit-def dead $eflags
  %46:gr64 = ADD64ri32 %15:gr64_nosp(tied-def 0), -3, implicit-def dead $eflags
  %47:gr64 = IMUL64rr %45:gr64(tied-def 0), killed %46:gr64, implicit-def dead $eflags
  %48:gr64 = ADD64ri32 %15:gr64_nosp(tied-def 0), -2, implicit-def dead $eflags
  %49:gr64 = IMUL64rr %47:gr64(tied-def 0), killed %48:gr64, implicit-def dead $eflags
  %50:gr64 = DEC64r %15:gr64_nosp(tied-def 0), implicit-def dead $eflags
  %51:gr64 = IMUL64rr %49:gr64(tied-def 0), killed %50:gr64, implicit-def dead $eflags
  %17:gr64 = IMUL64rr %51:gr64(tied-def 0), %15:gr64_nosp, implicit-def dead $eflags
  %18:gr64 = ADD64ri32 %15:gr64_nosp(tied-def 0), 8, implicit-def dead $eflags
  %52:gr64 = LEA64r %3:gr64, 1, %15:gr64_nosp, 8, $noreg
  %53:gr64 = SUB64ri32 %52:gr64(tied-def 0), 8, implicit-def $eflags
  JCC_1 %bb.3, 4, implicit $eflags
  JMP_1 %bb.8

# End machine code for function main.

# *** IR Dump After Remove dead machine instructions (dead-mi-elimination) ***:
# Machine code for function main: IsSSA, TracksLiveness
Frame Objects:
  fi#0: size=4, align=4, at location [SP+8]

bb.0 (%ir-block.0):
  successors: %bb.7(0x30000000), %bb.1(0x50000000); %bb.7(37.50%), %bb.1(62.50%)

  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %20:gr64 = LEA64r $rip, 1, $noreg, @.str, $noreg
  %21:gr32 = MOV32r0 implicit-def dead $eflags
  %22:gr8 = COPY %21.sub_8bit:gr32
  %23:gr64 = LEA64r %stack.0, 1, $noreg, 0, $noreg
  $rdi = COPY %20:gr64
  $rsi = COPY %23:gr64
  $al = COPY %22:gr8
  CALL64pcrel32 target-flags(x86-plt) @__isoc99_scanf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %25:gr32 = MOV32rm %stack.0, 1, $noreg, 0, $noreg :: (dereferenceable load (s32) from %ir.1, !tbaa !5)
  %0:gr64 = SUBREG_TO_REG 0, killed %25:gr32, %subreg.sub_32bit
  %26:gr32 = COPY %0.sub_32bit:gr64
  %19:gr64 = MOV32ri64 1
  TEST32rr %26:gr32, %26:gr32, implicit-def $eflags
  JCC_1 %bb.7, 14, implicit $eflags
  JMP_1 %bb.1

bb.1 (%ir-block.6):
; predecessors: %bb.0
  successors: %bb.4(0x40000000), %bb.2(0x40000000); %bb.4(50.00%), %bb.2(50.00%)

  %1:gr64 = COPY %0:gr64
  %29:gr64 = DEC64r %0:gr64(tied-def 0), implicit-def dead $eflags
  %30:gr32 = COPY %0.sub_32bit:gr64
  %31:gr32 = AND32ri %30:gr32(tied-def 0), 7, implicit-def dead $eflags
  %2:gr64 = SUBREG_TO_REG 0, killed %31:gr32, %subreg.sub_32bit
  %28:gr64 = MOV32ri64 1
  %27:gr64 = IMPLICIT_DEF
  %32:gr64 = SUB64ri32 %29:gr64(tied-def 0), 7, implicit-def $eflags
  JCC_1 %bb.4, 2, implicit $eflags
  JMP_1 %bb.2

bb.2 (%ir-block.12):
; predecessors: %bb.1
  successors: %bb.8(0x80000000); %bb.8(100.00%)

  %35:gr32 = COPY %1.sub_32bit:gr64
  %36:gr32 = AND32ri %35:gr32(tied-def 0), -8, implicit-def dead $eflags
  %37:gr64 = SUBREG_TO_REG 0, killed %36:gr32, %subreg.sub_32bit
  %3:gr64 = NEG64r %37:gr64(tied-def 0), implicit-def dead $eflags
  %34:gr64 = MOV32ri64 1
  %33:gr64 = MOV32ri64 8
  JMP_1 %bb.8

bb.3 (%ir-block.15):
; predecessors: %bb.8
  successors: %bb.4(0x80000000); %bb.4(100.00%)

  %4:gr64 = ADD64ri32 %18:gr64(tied-def 0), -7, implicit-def dead $eflags

bb.4 (%ir-block.17):
; predecessors: %bb.1, %bb.3
  successors: %bb.7(0x30000000), %bb.5(0x50000000); %bb.7(37.50%), %bb.5(62.50%)

  %5:gr64 = PHI %27:gr64, %bb.1, %17:gr64, %bb.3
  %6:gr64 = PHI %28:gr64, %bb.1, %4:gr64, %bb.3
  %7:gr64 = PHI %28:gr64, %bb.1, %17:gr64, %bb.3
  TEST64rr %2:gr64, %2:gr64, implicit-def $eflags
  JCC_1 %bb.7, 4, implicit $eflags
  JMP_1 %bb.5

bb.5 (%ir-block.22):
; predecessors: %bb.4
  successors: %bb.6(0x80000000); %bb.6(100.00%)


bb.6 (%ir-block.23):
; predecessors: %bb.5, %bb.6
  successors: %bb.7(0x04000000), %bb.6(0x7c000000); %bb.7(3.12%), %bb.6(96.88%)

  %8:gr64 = PHI %2:gr64, %bb.5, %13:gr64, %bb.6
  %9:gr64 = PHI %6:gr64, %bb.5, %12:gr64, %bb.6
  %10:gr64 = PHI %7:gr64, %bb.5, %11:gr64, %bb.6
  %11:gr64 = IMUL64rr %10:gr64(tied-def 0), %9:gr64, implicit-def dead $eflags
  %12:gr64 = nuw nsw INC64r %9:gr64(tied-def 0), implicit-def dead $eflags
  %13:gr64 = DEC64r %8:gr64(tied-def 0), implicit-def $eflags
  JCC_1 %bb.6, 5, implicit $eflags
  JMP_1 %bb.7

bb.7 (%ir-block.31):
; predecessors: %bb.0, %bb.4, %bb.6

  %14:gr64 = PHI %19:gr64, %bb.0, %5:gr64, %bb.4, %11:gr64, %bb.6
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %54:gr64 = LEA64r $rip, 1, $noreg, @.str.1, $noreg
  %55:gr32 = MOV32r0 implicit-def dead $eflags
  %56:gr8 = COPY %55.sub_8bit:gr32
  $rdi = COPY %54:gr64
  $rsi = COPY %14:gr64
  $al = COPY %56:gr8
  CALL64pcrel32 target-flags(x86-plt) @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $eax = COPY %55:gr32
  RET 0, $eax

bb.8 (%ir-block.34):
; predecessors: %bb.2, %bb.8
  successors: %bb.3(0x04000000), %bb.8(0x7c000000); %bb.3(3.12%), %bb.8(96.88%)

  %15:gr64_nosp = PHI %33:gr64, %bb.2, %18:gr64, %bb.8
  %16:gr64 = PHI %34:gr64, %bb.2, %17:gr64, %bb.8
  %38:gr64 = ADD64ri32 %15:gr64_nosp(tied-def 0), -7, implicit-def dead $eflags
  %39:gr64 = IMUL64rr %16:gr64(tied-def 0), killed %38:gr64, implicit-def dead $eflags
  %40:gr64 = ADD64ri32 %15:gr64_nosp(tied-def 0), -6, implicit-def dead $eflags
  %41:gr64 = IMUL64rr %39:gr64(tied-def 0), killed %40:gr64, implicit-def dead $eflags
  %42:gr64 = ADD64ri32 %15:gr64_nosp(tied-def 0), -5, implicit-def dead $eflags
  %43:gr64 = IMUL64rr %41:gr64(tied-def 0), killed %42:gr64, implicit-def dead $eflags
  %44:gr64 = ADD64ri32 %15:gr64_nosp(tied-def 0), -4, implicit-def dead $eflags
  %45:gr64 = IMUL64rr %43:gr64(tied-def 0), killed %44:gr64, implicit-def dead $eflags
  %46:gr64 = ADD64ri32 %15:gr64_nosp(tied-def 0), -3, implicit-def dead $eflags
  %47:gr64 = IMUL64rr %45:gr64(tied-def 0), killed %46:gr64, implicit-def dead $eflags
  %48:gr64 = ADD64ri32 %15:gr64_nosp(tied-def 0), -2, implicit-def dead $eflags
  %49:gr64 = IMUL64rr %47:gr64(tied-def 0), killed %48:gr64, implicit-def dead $eflags
  %50:gr64 = DEC64r %15:gr64_nosp(tied-def 0), implicit-def dead $eflags
  %51:gr64 = IMUL64rr %49:gr64(tied-def 0), killed %50:gr64, implicit-def dead $eflags
  %17:gr64 = IMUL64rr %51:gr64(tied-def 0), %15:gr64_nosp, implicit-def dead $eflags
  %18:gr64 = ADD64ri32 %15:gr64_nosp(tied-def 0), 8, implicit-def dead $eflags
  %52:gr64 = LEA64r %3:gr64, 1, %15:gr64_nosp, 8, $noreg
  %53:gr64 = SUB64ri32 %52:gr64(tied-def 0), 8, implicit-def $eflags
  JCC_1 %bb.3, 4, implicit $eflags
  JMP_1 %bb.8

# End machine code for function main.

# *** IR Dump After Early If-Conversion (early-ifcvt) ***:
# Machine code for function main: IsSSA, TracksLiveness
Frame Objects:
  fi#0: size=4, align=4, at location [SP+8]

bb.0 (%ir-block.0):
  successors: %bb.7(0x30000000), %bb.1(0x50000000); %bb.7(37.50%), %bb.1(62.50%)

  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %20:gr64 = LEA64r $rip, 1, $noreg, @.str, $noreg
  %21:gr32 = MOV32r0 implicit-def dead $eflags
  %22:gr8 = COPY %21.sub_8bit:gr32
  %23:gr64 = LEA64r %stack.0, 1, $noreg, 0, $noreg
  $rdi = COPY %20:gr64
  $rsi = COPY %23:gr64
  $al = COPY %22:gr8
  CALL64pcrel32 target-flags(x86-plt) @__isoc99_scanf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %25:gr32 = MOV32rm %stack.0, 1, $noreg, 0, $noreg :: (dereferenceable load (s32) from %ir.1, !tbaa !5)
  %0:gr64 = SUBREG_TO_REG 0, killed %25:gr32, %subreg.sub_32bit
  %26:gr32 = COPY %0.sub_32bit:gr64
  %19:gr64 = MOV32ri64 1
  TEST32rr %26:gr32, %26:gr32, implicit-def $eflags
  JCC_1 %bb.7, 14, implicit $eflags
  JMP_1 %bb.1

bb.1 (%ir-block.6):
; predecessors: %bb.0
  successors: %bb.4(0x40000000), %bb.2(0x40000000); %bb.4(50.00%), %bb.2(50.00%)

  %1:gr64 = COPY %0:gr64
  %29:gr64 = DEC64r %0:gr64(tied-def 0), implicit-def dead $eflags
  %30:gr32 = COPY %0.sub_32bit:gr64
  %31:gr32 = AND32ri %30:gr32(tied-def 0), 7, implicit-def dead $eflags
  %2:gr64 = SUBREG_TO_REG 0, killed %31:gr32, %subreg.sub_32bit
  %28:gr64 = MOV32ri64 1
  %27:gr64 = IMPLICIT_DEF
  %32:gr64 = SUB64ri32 %29:gr64(tied-def 0), 7, implicit-def $eflags
  JCC_1 %bb.4, 2, implicit $eflags
  JMP_1 %bb.2

bb.2 (%ir-block.12):
; predecessors: %bb.1
  successors: %bb.8(0x80000000); %bb.8(100.00%)

  %35:gr32 = COPY %1.sub_32bit:gr64
  %36:gr32 = AND32ri %35:gr32(tied-def 0), -8, implicit-def dead $eflags
  %37:gr64 = SUBREG_TO_REG 0, killed %36:gr32, %subreg.sub_32bit
  %3:gr64 = NEG64r %37:gr64(tied-def 0), implicit-def dead $eflags
  %34:gr64 = MOV32ri64 1
  %33:gr64 = MOV32ri64 8
  JMP_1 %bb.8

bb.3 (%ir-block.15):
; predecessors: %bb.8
  successors: %bb.4(0x80000000); %bb.4(100.00%)

  %4:gr64 = ADD64ri32 %18:gr64(tied-def 0), -7, implicit-def dead $eflags

bb.4 (%ir-block.17):
; predecessors: %bb.1, %bb.3
  successors: %bb.7(0x30000000), %bb.5(0x50000000); %bb.7(37.50%), %bb.5(62.50%)

  %5:gr64 = PHI %27:gr64, %bb.1, %17:gr64, %bb.3
  %6:gr64 = PHI %28:gr64, %bb.1, %4:gr64, %bb.3
  %7:gr64 = PHI %28:gr64, %bb.1, %17:gr64, %bb.3
  TEST64rr %2:gr64, %2:gr64, implicit-def $eflags
  JCC_1 %bb.7, 4, implicit $eflags
  JMP_1 %bb.5

bb.5 (%ir-block.22):
; predecessors: %bb.4
  successors: %bb.6(0x80000000); %bb.6(100.00%)


bb.6 (%ir-block.23):
; predecessors: %bb.5, %bb.6
  successors: %bb.7(0x04000000), %bb.6(0x7c000000); %bb.7(3.12%), %bb.6(96.88%)

  %8:gr64 = PHI %2:gr64, %bb.5, %13:gr64, %bb.6
  %9:gr64 = PHI %6:gr64, %bb.5, %12:gr64, %bb.6
  %10:gr64 = PHI %7:gr64, %bb.5, %11:gr64, %bb.6
  %11:gr64 = IMUL64rr %10:gr64(tied-def 0), %9:gr64, implicit-def dead $eflags
  %12:gr64 = nuw nsw INC64r %9:gr64(tied-def 0), implicit-def dead $eflags
  %13:gr64 = DEC64r %8:gr64(tied-def 0), implicit-def $eflags
  JCC_1 %bb.6, 5, implicit $eflags
  JMP_1 %bb.7

bb.7 (%ir-block.31):
; predecessors: %bb.0, %bb.4, %bb.6

  %14:gr64 = PHI %19:gr64, %bb.0, %5:gr64, %bb.4, %11:gr64, %bb.6
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %54:gr64 = LEA64r $rip, 1, $noreg, @.str.1, $noreg
  %55:gr32 = MOV32r0 implicit-def dead $eflags
  %56:gr8 = COPY %55.sub_8bit:gr32
  $rdi = COPY %54:gr64
  $rsi = COPY %14:gr64
  $al = COPY %56:gr8
  CALL64pcrel32 target-flags(x86-plt) @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $eax = COPY %55:gr32
  RET 0, $eax

bb.8 (%ir-block.34):
; predecessors: %bb.2, %bb.8
  successors: %bb.3(0x04000000), %bb.8(0x7c000000); %bb.3(3.12%), %bb.8(96.88%)

  %15:gr64_nosp = PHI %33:gr64, %bb.2, %18:gr64, %bb.8
  %16:gr64 = PHI %34:gr64, %bb.2, %17:gr64, %bb.8
  %38:gr64 = ADD64ri32 %15:gr64_nosp(tied-def 0), -7, implicit-def dead $eflags
  %39:gr64 = IMUL64rr %16:gr64(tied-def 0), killed %38:gr64, implicit-def dead $eflags
  %40:gr64 = ADD64ri32 %15:gr64_nosp(tied-def 0), -6, implicit-def dead $eflags
  %41:gr64 = IMUL64rr %39:gr64(tied-def 0), killed %40:gr64, implicit-def dead $eflags
  %42:gr64 = ADD64ri32 %15:gr64_nosp(tied-def 0), -5, implicit-def dead $eflags
  %43:gr64 = IMUL64rr %41:gr64(tied-def 0), killed %42:gr64, implicit-def dead $eflags
  %44:gr64 = ADD64ri32 %15:gr64_nosp(tied-def 0), -4, implicit-def dead $eflags
  %45:gr64 = IMUL64rr %43:gr64(tied-def 0), killed %44:gr64, implicit-def dead $eflags
  %46:gr64 = ADD64ri32 %15:gr64_nosp(tied-def 0), -3, implicit-def dead $eflags
  %47:gr64 = IMUL64rr %45:gr64(tied-def 0), killed %46:gr64, implicit-def dead $eflags
  %48:gr64 = ADD64ri32 %15:gr64_nosp(tied-def 0), -2, implicit-def dead $eflags
  %49:gr64 = IMUL64rr %47:gr64(tied-def 0), killed %48:gr64, implicit-def dead $eflags
  %50:gr64 = DEC64r %15:gr64_nosp(tied-def 0), implicit-def dead $eflags
  %51:gr64 = IMUL64rr %49:gr64(tied-def 0), killed %50:gr64, implicit-def dead $eflags
  %17:gr64 = IMUL64rr %51:gr64(tied-def 0), %15:gr64_nosp, implicit-def dead $eflags
  %18:gr64 = ADD64ri32 %15:gr64_nosp(tied-def 0), 8, implicit-def dead $eflags
  %52:gr64 = LEA64r %3:gr64, 1, %15:gr64_nosp, 8, $noreg
  %53:gr64 = SUB64ri32 %52:gr64(tied-def 0), 8, implicit-def $eflags
  JCC_1 %bb.3, 4, implicit $eflags
  JMP_1 %bb.8

# End machine code for function main.

# *** IR Dump After Machine InstCombiner (machine-combiner) ***:
# Machine code for function main: IsSSA, TracksLiveness
Frame Objects:
  fi#0: size=4, align=4, at location [SP+8]

bb.0 (%ir-block.0):
  successors: %bb.7(0x30000000), %bb.1(0x50000000); %bb.7(37.50%), %bb.1(62.50%)

  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %20:gr64 = LEA64r $rip, 1, $noreg, @.str, $noreg
  %21:gr32 = MOV32r0 implicit-def dead $eflags
  %22:gr8 = COPY %21.sub_8bit:gr32
  %23:gr64 = LEA64r %stack.0, 1, $noreg, 0, $noreg
  $rdi = COPY %20:gr64
  $rsi = COPY %23:gr64
  $al = COPY %22:gr8
  CALL64pcrel32 target-flags(x86-plt) @__isoc99_scanf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %25:gr32 = MOV32rm %stack.0, 1, $noreg, 0, $noreg :: (dereferenceable load (s32) from %ir.1, !tbaa !5)
  %0:gr64 = SUBREG_TO_REG 0, killed %25:gr32, %subreg.sub_32bit
  %26:gr32 = COPY %0.sub_32bit:gr64
  %19:gr64 = MOV32ri64 1
  TEST32rr %26:gr32, %26:gr32, implicit-def $eflags
  JCC_1 %bb.7, 14, implicit $eflags
  JMP_1 %bb.1

bb.1 (%ir-block.6):
; predecessors: %bb.0
  successors: %bb.4(0x40000000), %bb.2(0x40000000); %bb.4(50.00%), %bb.2(50.00%)

  %1:gr64 = COPY %0:gr64
  %29:gr64 = DEC64r %0:gr64(tied-def 0), implicit-def dead $eflags
  %30:gr32 = COPY %0.sub_32bit:gr64
  %31:gr32 = AND32ri %30:gr32(tied-def 0), 7, implicit-def dead $eflags
  %2:gr64 = SUBREG_TO_REG 0, killed %31:gr32, %subreg.sub_32bit
  %28:gr64 = MOV32ri64 1
  %27:gr64 = IMPLICIT_DEF
  %32:gr64 = SUB64ri32 %29:gr64(tied-def 0), 7, implicit-def $eflags
  JCC_1 %bb.4, 2, implicit $eflags
  JMP_1 %bb.2

bb.2 (%ir-block.12):
; predecessors: %bb.1
  successors: %bb.8(0x80000000); %bb.8(100.00%)

  %35:gr32 = COPY %1.sub_32bit:gr64
  %36:gr32 = AND32ri %35:gr32(tied-def 0), -8, implicit-def dead $eflags
  %37:gr64 = SUBREG_TO_REG 0, killed %36:gr32, %subreg.sub_32bit
  %3:gr64 = NEG64r %37:gr64(tied-def 0), implicit-def dead $eflags
  %34:gr64 = MOV32ri64 1
  %33:gr64 = MOV32ri64 8
  JMP_1 %bb.8

bb.3 (%ir-block.15):
; predecessors: %bb.8
  successors: %bb.4(0x80000000); %bb.4(100.00%)

  %4:gr64 = ADD64ri32 %18:gr64(tied-def 0), -7, implicit-def dead $eflags

bb.4 (%ir-block.17):
; predecessors: %bb.1, %bb.3
  successors: %bb.7(0x30000000), %bb.5(0x50000000); %bb.7(37.50%), %bb.5(62.50%)

  %5:gr64 = PHI %27:gr64, %bb.1, %17:gr64, %bb.3
  %6:gr64 = PHI %28:gr64, %bb.1, %4:gr64, %bb.3
  %7:gr64 = PHI %28:gr64, %bb.1, %17:gr64, %bb.3
  TEST64rr %2:gr64, %2:gr64, implicit-def $eflags
  JCC_1 %bb.7, 4, implicit $eflags
  JMP_1 %bb.5

bb.5 (%ir-block.22):
; predecessors: %bb.4
  successors: %bb.6(0x80000000); %bb.6(100.00%)


bb.6 (%ir-block.23):
; predecessors: %bb.5, %bb.6
  successors: %bb.7(0x04000000), %bb.6(0x7c000000); %bb.7(3.12%), %bb.6(96.88%)

  %8:gr64 = PHI %2:gr64, %bb.5, %13:gr64, %bb.6
  %9:gr64 = PHI %6:gr64, %bb.5, %12:gr64, %bb.6
  %10:gr64 = PHI %7:gr64, %bb.5, %11:gr64, %bb.6
  %11:gr64 = IMUL64rr %10:gr64(tied-def 0), %9:gr64, implicit-def dead $eflags
  %12:gr64 = nuw nsw INC64r %9:gr64(tied-def 0), implicit-def dead $eflags
  %13:gr64 = DEC64r %8:gr64(tied-def 0), implicit-def $eflags
  JCC_1 %bb.6, 5, implicit $eflags
  JMP_1 %bb.7

bb.7 (%ir-block.31):
; predecessors: %bb.0, %bb.4, %bb.6

  %14:gr64 = PHI %19:gr64, %bb.0, %5:gr64, %bb.4, %11:gr64, %bb.6
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %54:gr64 = LEA64r $rip, 1, $noreg, @.str.1, $noreg
  %55:gr32 = MOV32r0 implicit-def dead $eflags
  %56:gr8 = COPY %55.sub_8bit:gr32
  $rdi = COPY %54:gr64
  $rsi = COPY %14:gr64
  $al = COPY %56:gr8
  CALL64pcrel32 target-flags(x86-plt) @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $eax = COPY %55:gr32
  RET 0, $eax

bb.8 (%ir-block.34):
; predecessors: %bb.2, %bb.8
  successors: %bb.3(0x04000000), %bb.8(0x7c000000); %bb.3(3.12%), %bb.8(96.88%)

  %15:gr64_nosp = PHI %33:gr64, %bb.2, %18:gr64, %bb.8
  %16:gr64 = PHI %34:gr64, %bb.2, %17:gr64, %bb.8
  %38:gr64 = ADD64ri32 %15:gr64_nosp(tied-def 0), -7, implicit-def dead $eflags
  %39:gr64 = IMUL64rr %16:gr64(tied-def 0), killed %38:gr64, implicit-def dead $eflags
  %40:gr64 = ADD64ri32 %15:gr64_nosp(tied-def 0), -6, implicit-def dead $eflags
  %42:gr64 = ADD64ri32 %15:gr64_nosp(tied-def 0), -5, implicit-def dead $eflags
  %60:gr64 = IMUL64rr killed %40:gr64(tied-def 0), killed %42:gr64, implicit-def dead $eflags
  %43:gr64 = IMUL64rr %39:gr64(tied-def 0), killed %60:gr64, implicit-def dead $eflags
  %44:gr64 = ADD64ri32 %15:gr64_nosp(tied-def 0), -4, implicit-def dead $eflags
  %46:gr64 = ADD64ri32 %15:gr64_nosp(tied-def 0), -3, implicit-def dead $eflags
  %63:gr64 = IMUL64rr killed %44:gr64(tied-def 0), killed %46:gr64, implicit-def dead $eflags
  %48:gr64 = ADD64ri32 %15:gr64_nosp(tied-def 0), -2, implicit-def dead $eflags
  %64:gr64 = IMUL64rr killed %63:gr64(tied-def 0), killed %48:gr64, implicit-def dead $eflags
  %49:gr64 = IMUL64rr %43:gr64(tied-def 0), killed %64:gr64, implicit-def dead $eflags
  %50:gr64 = DEC64r %15:gr64_nosp(tied-def 0), implicit-def dead $eflags
  %67:gr64 = IMUL64rr killed %50:gr64(tied-def 0), %15:gr64_nosp, implicit-def dead $eflags
  %17:gr64 = IMUL64rr %49:gr64(tied-def 0), killed %67:gr64, implicit-def dead $eflags
  %18:gr64 = ADD64ri32 %15:gr64_nosp(tied-def 0), 8, implicit-def dead $eflags
  %52:gr64 = LEA64r %3:gr64, 1, %15:gr64_nosp, 8, $noreg
  %53:gr64 = SUB64ri32 %52:gr64(tied-def 0), 8, implicit-def $eflags
  JCC_1 %bb.3, 4, implicit $eflags
  JMP_1 %bb.8

# End machine code for function main.

# *** IR Dump After X86 cmov Conversion (x86-cmov-conversion) ***:
# Machine code for function main: IsSSA, TracksLiveness
Frame Objects:
  fi#0: size=4, align=4, at location [SP+8]

bb.0 (%ir-block.0):
  successors: %bb.7(0x30000000), %bb.1(0x50000000); %bb.7(37.50%), %bb.1(62.50%)

  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %20:gr64 = LEA64r $rip, 1, $noreg, @.str, $noreg
  %21:gr32 = MOV32r0 implicit-def dead $eflags
  %22:gr8 = COPY %21.sub_8bit:gr32
  %23:gr64 = LEA64r %stack.0, 1, $noreg, 0, $noreg
  $rdi = COPY %20:gr64
  $rsi = COPY %23:gr64
  $al = COPY %22:gr8
  CALL64pcrel32 target-flags(x86-plt) @__isoc99_scanf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %25:gr32 = MOV32rm %stack.0, 1, $noreg, 0, $noreg :: (dereferenceable load (s32) from %ir.1, !tbaa !5)
  %0:gr64 = SUBREG_TO_REG 0, killed %25:gr32, %subreg.sub_32bit
  %26:gr32 = COPY %0.sub_32bit:gr64
  %19:gr64 = MOV32ri64 1
  TEST32rr %26:gr32, %26:gr32, implicit-def $eflags
  JCC_1 %bb.7, 14, implicit $eflags
  JMP_1 %bb.1

bb.1 (%ir-block.6):
; predecessors: %bb.0
  successors: %bb.4(0x40000000), %bb.2(0x40000000); %bb.4(50.00%), %bb.2(50.00%)

  %1:gr64 = COPY %0:gr64
  %29:gr64 = DEC64r %0:gr64(tied-def 0), implicit-def dead $eflags
  %30:gr32 = COPY %0.sub_32bit:gr64
  %31:gr32 = AND32ri %30:gr32(tied-def 0), 7, implicit-def dead $eflags
  %2:gr64 = SUBREG_TO_REG 0, killed %31:gr32, %subreg.sub_32bit
  %28:gr64 = MOV32ri64 1
  %27:gr64 = IMPLICIT_DEF
  %32:gr64 = SUB64ri32 %29:gr64(tied-def 0), 7, implicit-def $eflags
  JCC_1 %bb.4, 2, implicit $eflags
  JMP_1 %bb.2

bb.2 (%ir-block.12):
; predecessors: %bb.1
  successors: %bb.8(0x80000000); %bb.8(100.00%)

  %35:gr32 = COPY %1.sub_32bit:gr64
  %36:gr32 = AND32ri %35:gr32(tied-def 0), -8, implicit-def dead $eflags
  %37:gr64 = SUBREG_TO_REG 0, killed %36:gr32, %subreg.sub_32bit
  %3:gr64 = NEG64r %37:gr64(tied-def 0), implicit-def dead $eflags
  %34:gr64 = MOV32ri64 1
  %33:gr64 = MOV32ri64 8
  JMP_1 %bb.8

bb.3 (%ir-block.15):
; predecessors: %bb.8
  successors: %bb.4(0x80000000); %bb.4(100.00%)

  %4:gr64 = ADD64ri32 %18:gr64(tied-def 0), -7, implicit-def dead $eflags

bb.4 (%ir-block.17):
; predecessors: %bb.1, %bb.3
  successors: %bb.7(0x30000000), %bb.5(0x50000000); %bb.7(37.50%), %bb.5(62.50%)

  %5:gr64 = PHI %27:gr64, %bb.1, %17:gr64, %bb.3
  %6:gr64 = PHI %28:gr64, %bb.1, %4:gr64, %bb.3
  %7:gr64 = PHI %28:gr64, %bb.1, %17:gr64, %bb.3
  TEST64rr %2:gr64, %2:gr64, implicit-def $eflags
  JCC_1 %bb.7, 4, implicit $eflags
  JMP_1 %bb.5

bb.5 (%ir-block.22):
; predecessors: %bb.4
  successors: %bb.6(0x80000000); %bb.6(100.00%)


bb.6 (%ir-block.23):
; predecessors: %bb.5, %bb.6
  successors: %bb.7(0x04000000), %bb.6(0x7c000000); %bb.7(3.12%), %bb.6(96.88%)

  %8:gr64 = PHI %2:gr64, %bb.5, %13:gr64, %bb.6
  %9:gr64 = PHI %6:gr64, %bb.5, %12:gr64, %bb.6
  %10:gr64 = PHI %7:gr64, %bb.5, %11:gr64, %bb.6
  %11:gr64 = IMUL64rr %10:gr64(tied-def 0), %9:gr64, implicit-def dead $eflags
  %12:gr64 = nuw nsw INC64r %9:gr64(tied-def 0), implicit-def dead $eflags
  %13:gr64 = DEC64r %8:gr64(tied-def 0), implicit-def $eflags
  JCC_1 %bb.6, 5, implicit $eflags
  JMP_1 %bb.7

bb.7 (%ir-block.31):
; predecessors: %bb.0, %bb.4, %bb.6

  %14:gr64 = PHI %19:gr64, %bb.0, %5:gr64, %bb.4, %11:gr64, %bb.6
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %54:gr64 = LEA64r $rip, 1, $noreg, @.str.1, $noreg
  %55:gr32 = MOV32r0 implicit-def dead $eflags
  %56:gr8 = COPY %55.sub_8bit:gr32
  $rdi = COPY %54:gr64
  $rsi = COPY %14:gr64
  $al = COPY %56:gr8
  CALL64pcrel32 target-flags(x86-plt) @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $eax = COPY %55:gr32
  RET 0, $eax

bb.8 (%ir-block.34):
; predecessors: %bb.2, %bb.8
  successors: %bb.3(0x04000000), %bb.8(0x7c000000); %bb.3(3.12%), %bb.8(96.88%)

  %15:gr64_nosp = PHI %33:gr64, %bb.2, %18:gr64, %bb.8
  %16:gr64 = PHI %34:gr64, %bb.2, %17:gr64, %bb.8
  %38:gr64 = ADD64ri32 %15:gr64_nosp(tied-def 0), -7, implicit-def dead $eflags
  %39:gr64 = IMUL64rr %16:gr64(tied-def 0), killed %38:gr64, implicit-def dead $eflags
  %40:gr64 = ADD64ri32 %15:gr64_nosp(tied-def 0), -6, implicit-def dead $eflags
  %42:gr64 = ADD64ri32 %15:gr64_nosp(tied-def 0), -5, implicit-def dead $eflags
  %60:gr64 = IMUL64rr killed %40:gr64(tied-def 0), killed %42:gr64, implicit-def dead $eflags
  %43:gr64 = IMUL64rr %39:gr64(tied-def 0), killed %60:gr64, implicit-def dead $eflags
  %44:gr64 = ADD64ri32 %15:gr64_nosp(tied-def 0), -4, implicit-def dead $eflags
  %46:gr64 = ADD64ri32 %15:gr64_nosp(tied-def 0), -3, implicit-def dead $eflags
  %63:gr64 = IMUL64rr killed %44:gr64(tied-def 0), killed %46:gr64, implicit-def dead $eflags
  %48:gr64 = ADD64ri32 %15:gr64_nosp(tied-def 0), -2, implicit-def dead $eflags
  %64:gr64 = IMUL64rr killed %63:gr64(tied-def 0), killed %48:gr64, implicit-def dead $eflags
  %49:gr64 = IMUL64rr %43:gr64(tied-def 0), killed %64:gr64, implicit-def dead $eflags
  %50:gr64 = DEC64r %15:gr64_nosp(tied-def 0), implicit-def dead $eflags
  %67:gr64 = IMUL64rr killed %50:gr64(tied-def 0), %15:gr64_nosp, implicit-def dead $eflags
  %17:gr64 = IMUL64rr %49:gr64(tied-def 0), killed %67:gr64, implicit-def dead $eflags
  %18:gr64 = ADD64ri32 %15:gr64_nosp(tied-def 0), 8, implicit-def dead $eflags
  %52:gr64 = LEA64r %3:gr64, 1, %15:gr64_nosp, 8, $noreg
  %53:gr64 = SUB64ri32 %52:gr64(tied-def 0), 8, implicit-def $eflags
  JCC_1 %bb.3, 4, implicit $eflags
  JMP_1 %bb.8

# End machine code for function main.

# *** IR Dump After Early Machine Loop Invariant Code Motion (early-machinelicm) ***:
# Machine code for function main: IsSSA, TracksLiveness
Frame Objects:
  fi#0: size=4, align=4, at location [SP+8]

bb.0 (%ir-block.0):
  successors: %bb.7(0x30000000), %bb.1(0x50000000); %bb.7(37.50%), %bb.1(62.50%)

  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %20:gr64 = LEA64r $rip, 1, $noreg, @.str, $noreg
  %21:gr32 = MOV32r0 implicit-def dead $eflags
  %22:gr8 = COPY %21.sub_8bit:gr32
  %23:gr64 = LEA64r %stack.0, 1, $noreg, 0, $noreg
  $rdi = COPY %20:gr64
  $rsi = COPY %23:gr64
  $al = COPY %22:gr8
  CALL64pcrel32 target-flags(x86-plt) @__isoc99_scanf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %25:gr32 = MOV32rm %stack.0, 1, $noreg, 0, $noreg :: (dereferenceable load (s32) from %ir.1, !tbaa !5)
  %0:gr64 = SUBREG_TO_REG 0, killed %25:gr32, %subreg.sub_32bit
  %26:gr32 = COPY %0.sub_32bit:gr64
  %19:gr64 = MOV32ri64 1
  TEST32rr %26:gr32, %26:gr32, implicit-def $eflags
  JCC_1 %bb.7, 14, implicit $eflags
  JMP_1 %bb.1

bb.1 (%ir-block.6):
; predecessors: %bb.0
  successors: %bb.4(0x40000000), %bb.2(0x40000000); %bb.4(50.00%), %bb.2(50.00%)

  %1:gr64 = COPY %0:gr64
  %29:gr64 = DEC64r %0:gr64(tied-def 0), implicit-def dead $eflags
  %30:gr32 = COPY %0.sub_32bit:gr64
  %31:gr32 = AND32ri %30:gr32(tied-def 0), 7, implicit-def dead $eflags
  %2:gr64 = SUBREG_TO_REG 0, killed %31:gr32, %subreg.sub_32bit
  %28:gr64 = MOV32ri64 1
  %27:gr64 = IMPLICIT_DEF
  %32:gr64 = SUB64ri32 %29:gr64(tied-def 0), 7, implicit-def $eflags
  JCC_1 %bb.4, 2, implicit $eflags
  JMP_1 %bb.2

bb.2 (%ir-block.12):
; predecessors: %bb.1
  successors: %bb.8(0x80000000); %bb.8(100.00%)

  %35:gr32 = COPY %1.sub_32bit:gr64
  %36:gr32 = AND32ri %35:gr32(tied-def 0), -8, implicit-def dead $eflags
  %37:gr64 = SUBREG_TO_REG 0, killed %36:gr32, %subreg.sub_32bit
  %3:gr64 = NEG64r %37:gr64(tied-def 0), implicit-def dead $eflags
  %34:gr64 = MOV32ri64 1
  %33:gr64 = MOV32ri64 8
  JMP_1 %bb.8

bb.3 (%ir-block.15):
; predecessors: %bb.8
  successors: %bb.4(0x80000000); %bb.4(100.00%)

  %4:gr64 = ADD64ri32 %18:gr64(tied-def 0), -7, implicit-def dead $eflags

bb.4 (%ir-block.17):
; predecessors: %bb.1, %bb.3
  successors: %bb.7(0x30000000), %bb.5(0x50000000); %bb.7(37.50%), %bb.5(62.50%)

  %5:gr64 = PHI %27:gr64, %bb.1, %17:gr64, %bb.3
  %6:gr64 = PHI %28:gr64, %bb.1, %4:gr64, %bb.3
  %7:gr64 = PHI %28:gr64, %bb.1, %17:gr64, %bb.3
  TEST64rr %2:gr64, %2:gr64, implicit-def $eflags
  JCC_1 %bb.7, 4, implicit $eflags
  JMP_1 %bb.5

bb.5 (%ir-block.22):
; predecessors: %bb.4
  successors: %bb.6(0x80000000); %bb.6(100.00%)


bb.6 (%ir-block.23):
; predecessors: %bb.5, %bb.6
  successors: %bb.7(0x04000000), %bb.6(0x7c000000); %bb.7(3.12%), %bb.6(96.88%)

  %8:gr64 = PHI %2:gr64, %bb.5, %13:gr64, %bb.6
  %9:gr64 = PHI %6:gr64, %bb.5, %12:gr64, %bb.6
  %10:gr64 = PHI %7:gr64, %bb.5, %11:gr64, %bb.6
  %11:gr64 = IMUL64rr %10:gr64(tied-def 0), %9:gr64, implicit-def dead $eflags
  %12:gr64 = nuw nsw INC64r %9:gr64(tied-def 0), implicit-def dead $eflags
  %13:gr64 = DEC64r %8:gr64(tied-def 0), implicit-def $eflags
  JCC_1 %bb.6, 5, implicit $eflags
  JMP_1 %bb.7

bb.7 (%ir-block.31):
; predecessors: %bb.0, %bb.4, %bb.6

  %14:gr64 = PHI %19:gr64, %bb.0, %5:gr64, %bb.4, %11:gr64, %bb.6
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %54:gr64 = LEA64r $rip, 1, $noreg, @.str.1, $noreg
  %55:gr32 = MOV32r0 implicit-def dead $eflags
  %56:gr8 = COPY %55.sub_8bit:gr32
  $rdi = COPY %54:gr64
  $rsi = COPY %14:gr64
  $al = COPY %56:gr8
  CALL64pcrel32 target-flags(x86-plt) @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $eax = COPY %55:gr32
  RET 0, $eax

bb.8 (%ir-block.34):
; predecessors: %bb.2, %bb.8
  successors: %bb.3(0x04000000), %bb.8(0x7c000000); %bb.3(3.12%), %bb.8(96.88%)

  %15:gr64_nosp = PHI %33:gr64, %bb.2, %18:gr64, %bb.8
  %16:gr64 = PHI %34:gr64, %bb.2, %17:gr64, %bb.8
  %38:gr64 = ADD64ri32 %15:gr64_nosp(tied-def 0), -7, implicit-def dead $eflags
  %39:gr64 = IMUL64rr %16:gr64(tied-def 0), killed %38:gr64, implicit-def dead $eflags
  %40:gr64 = ADD64ri32 %15:gr64_nosp(tied-def 0), -6, implicit-def dead $eflags
  %42:gr64 = ADD64ri32 %15:gr64_nosp(tied-def 0), -5, implicit-def dead $eflags
  %60:gr64 = IMUL64rr killed %40:gr64(tied-def 0), killed %42:gr64, implicit-def dead $eflags
  %43:gr64 = IMUL64rr %39:gr64(tied-def 0), killed %60:gr64, implicit-def dead $eflags
  %44:gr64 = ADD64ri32 %15:gr64_nosp(tied-def 0), -4, implicit-def dead $eflags
  %46:gr64 = ADD64ri32 %15:gr64_nosp(tied-def 0), -3, implicit-def dead $eflags
  %63:gr64 = IMUL64rr killed %44:gr64(tied-def 0), killed %46:gr64, implicit-def dead $eflags
  %48:gr64 = ADD64ri32 %15:gr64_nosp(tied-def 0), -2, implicit-def dead $eflags
  %64:gr64 = IMUL64rr killed %63:gr64(tied-def 0), killed %48:gr64, implicit-def dead $eflags
  %49:gr64 = IMUL64rr %43:gr64(tied-def 0), killed %64:gr64, implicit-def dead $eflags
  %50:gr64 = DEC64r %15:gr64_nosp(tied-def 0), implicit-def dead $eflags
  %67:gr64 = IMUL64rr killed %50:gr64(tied-def 0), %15:gr64_nosp, implicit-def dead $eflags
  %17:gr64 = IMUL64rr %49:gr64(tied-def 0), killed %67:gr64, implicit-def dead $eflags
  %18:gr64 = ADD64ri32 %15:gr64_nosp(tied-def 0), 8, implicit-def dead $eflags
  %52:gr64 = LEA64r %3:gr64, 1, %15:gr64_nosp, 8, $noreg
  %53:gr64 = SUB64ri32 %52:gr64(tied-def 0), 8, implicit-def $eflags
  JCC_1 %bb.3, 4, implicit $eflags
  JMP_1 %bb.8

# End machine code for function main.

# *** IR Dump After Machine Common Subexpression Elimination (machine-cse) ***:
# Machine code for function main: IsSSA, TracksLiveness
Frame Objects:
  fi#0: size=4, align=4, at location [SP+8]

bb.0 (%ir-block.0):
  successors: %bb.7(0x30000000), %bb.1(0x50000000); %bb.7(37.50%), %bb.1(62.50%)

  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %20:gr64 = LEA64r $rip, 1, $noreg, @.str, $noreg
  %21:gr32 = MOV32r0 implicit-def dead $eflags
  %22:gr8 = COPY %21.sub_8bit:gr32
  %23:gr64 = LEA64r %stack.0, 1, $noreg, 0, $noreg
  $rdi = COPY %20:gr64
  $rsi = COPY %23:gr64
  $al = COPY %22:gr8
  CALL64pcrel32 target-flags(x86-plt) @__isoc99_scanf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %25:gr32 = MOV32rm %stack.0, 1, $noreg, 0, $noreg :: (dereferenceable load (s32) from %ir.1, !tbaa !5)
  %0:gr64 = SUBREG_TO_REG 0, killed %25:gr32, %subreg.sub_32bit
  %26:gr32 = COPY %0.sub_32bit:gr64
  %19:gr64 = MOV32ri64 1
  TEST32rr %26:gr32, %26:gr32, implicit-def $eflags
  JCC_1 %bb.7, 14, implicit $eflags
  JMP_1 %bb.1

bb.1 (%ir-block.6):
; predecessors: %bb.0
  successors: %bb.4(0x40000000), %bb.2(0x40000000); %bb.4(50.00%), %bb.2(50.00%)

  %1:gr64 = COPY %0:gr64
  %29:gr64 = DEC64r %0:gr64(tied-def 0), implicit-def dead $eflags
  %30:gr32 = COPY %0.sub_32bit:gr64
  %31:gr32 = AND32ri %30:gr32(tied-def 0), 7, implicit-def dead $eflags
  %2:gr64 = SUBREG_TO_REG 0, killed %31:gr32, %subreg.sub_32bit
  %28:gr64 = MOV32ri64 1
  %27:gr64 = IMPLICIT_DEF
  %32:gr64 = SUB64ri32 %29:gr64(tied-def 0), 7, implicit-def $eflags
  JCC_1 %bb.4, 2, implicit $eflags
  JMP_1 %bb.2

bb.2 (%ir-block.12):
; predecessors: %bb.1
  successors: %bb.8(0x80000000); %bb.8(100.00%)

  %35:gr32 = COPY %1.sub_32bit:gr64
  %36:gr32 = AND32ri %35:gr32(tied-def 0), -8, implicit-def dead $eflags
  %37:gr64 = SUBREG_TO_REG 0, killed %36:gr32, %subreg.sub_32bit
  %3:gr64 = NEG64r %37:gr64(tied-def 0), implicit-def dead $eflags
  %34:gr64 = MOV32ri64 1
  %33:gr64 = MOV32ri64 8
  JMP_1 %bb.8

bb.3 (%ir-block.15):
; predecessors: %bb.8
  successors: %bb.4(0x80000000); %bb.4(100.00%)

  %4:gr64 = ADD64ri32 %18:gr64(tied-def 0), -7, implicit-def dead $eflags

bb.4 (%ir-block.17):
; predecessors: %bb.1, %bb.3
  successors: %bb.7(0x30000000), %bb.5(0x50000000); %bb.7(37.50%), %bb.5(62.50%)

  %5:gr64 = PHI %27:gr64, %bb.1, %17:gr64, %bb.3
  %6:gr64 = PHI %28:gr64, %bb.1, %4:gr64, %bb.3
  %7:gr64 = PHI %28:gr64, %bb.1, %17:gr64, %bb.3
  TEST64rr %2:gr64, %2:gr64, implicit-def $eflags
  JCC_1 %bb.7, 4, implicit $eflags
  JMP_1 %bb.5

bb.5 (%ir-block.22):
; predecessors: %bb.4
  successors: %bb.6(0x80000000); %bb.6(100.00%)


bb.6 (%ir-block.23):
; predecessors: %bb.5, %bb.6
  successors: %bb.7(0x04000000), %bb.6(0x7c000000); %bb.7(3.12%), %bb.6(96.88%)

  %8:gr64 = PHI %2:gr64, %bb.5, %13:gr64, %bb.6
  %9:gr64 = PHI %6:gr64, %bb.5, %12:gr64, %bb.6
  %10:gr64 = PHI %7:gr64, %bb.5, %11:gr64, %bb.6
  %11:gr64 = IMUL64rr %10:gr64(tied-def 0), %9:gr64, implicit-def dead $eflags
  %12:gr64 = nuw nsw INC64r %9:gr64(tied-def 0), implicit-def dead $eflags
  %13:gr64 = DEC64r %8:gr64(tied-def 0), implicit-def $eflags
  JCC_1 %bb.6, 5, implicit $eflags
  JMP_1 %bb.7

bb.7 (%ir-block.31):
; predecessors: %bb.0, %bb.4, %bb.6

  %14:gr64 = PHI %19:gr64, %bb.0, %5:gr64, %bb.4, %11:gr64, %bb.6
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %54:gr64 = LEA64r $rip, 1, $noreg, @.str.1, $noreg
  %55:gr32 = MOV32r0 implicit-def dead $eflags
  %56:gr8 = COPY %55.sub_8bit:gr32
  $rdi = COPY %54:gr64
  $rsi = COPY %14:gr64
  $al = COPY %56:gr8
  CALL64pcrel32 target-flags(x86-plt) @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $eax = COPY %55:gr32
  RET 0, $eax

bb.8 (%ir-block.34):
; predecessors: %bb.2, %bb.8
  successors: %bb.3(0x04000000), %bb.8(0x7c000000); %bb.3(3.12%), %bb.8(96.88%)

  %15:gr64_nosp = PHI %33:gr64, %bb.2, %18:gr64, %bb.8
  %16:gr64 = PHI %34:gr64, %bb.2, %17:gr64, %bb.8
  %38:gr64 = ADD64ri32 %15:gr64_nosp(tied-def 0), -7, implicit-def dead $eflags
  %39:gr64 = IMUL64rr %16:gr64(tied-def 0), killed %38:gr64, implicit-def dead $eflags
  %40:gr64 = ADD64ri32 %15:gr64_nosp(tied-def 0), -6, implicit-def dead $eflags
  %42:gr64 = ADD64ri32 %15:gr64_nosp(tied-def 0), -5, implicit-def dead $eflags
  %60:gr64 = IMUL64rr killed %40:gr64(tied-def 0), killed %42:gr64, implicit-def dead $eflags
  %43:gr64 = IMUL64rr %39:gr64(tied-def 0), killed %60:gr64, implicit-def dead $eflags
  %44:gr64 = ADD64ri32 %15:gr64_nosp(tied-def 0), -4, implicit-def dead $eflags
  %46:gr64 = ADD64ri32 %15:gr64_nosp(tied-def 0), -3, implicit-def dead $eflags
  %63:gr64 = IMUL64rr killed %44:gr64(tied-def 0), killed %46:gr64, implicit-def dead $eflags
  %48:gr64 = ADD64ri32 %15:gr64_nosp(tied-def 0), -2, implicit-def dead $eflags
  %64:gr64 = IMUL64rr killed %63:gr64(tied-def 0), killed %48:gr64, implicit-def dead $eflags
  %49:gr64 = IMUL64rr %43:gr64(tied-def 0), killed %64:gr64, implicit-def dead $eflags
  %50:gr64 = DEC64r %15:gr64_nosp(tied-def 0), implicit-def dead $eflags
  %67:gr64 = IMUL64rr killed %50:gr64(tied-def 0), %15:gr64_nosp, implicit-def dead $eflags
  %17:gr64 = IMUL64rr %49:gr64(tied-def 0), killed %67:gr64, implicit-def dead $eflags
  %18:gr64 = ADD64ri32 %15:gr64_nosp(tied-def 0), 8, implicit-def dead $eflags
  %52:gr64 = LEA64r %3:gr64, 1, %15:gr64_nosp, 8, $noreg
  %53:gr64 = SUB64ri32 %52:gr64(tied-def 0), 8, implicit-def $eflags
  JCC_1 %bb.3, 4, implicit $eflags
  JMP_1 %bb.8

# End machine code for function main.

# *** IR Dump After Machine code sinking (machine-sink) ***:
# Machine code for function main: IsSSA, TracksLiveness
Frame Objects:
  fi#0: size=4, align=4, at location [SP+8]

bb.0 (%ir-block.0):
  successors: %bb.9(0x30000000), %bb.1(0x50000000); %bb.9(37.50%), %bb.1(62.50%)

  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %20:gr64 = LEA64r $rip, 1, $noreg, @.str, $noreg
  %21:gr32 = MOV32r0 implicit-def dead $eflags
  %22:gr8 = COPY %21.sub_8bit:gr32
  %23:gr64 = LEA64r %stack.0, 1, $noreg, 0, $noreg
  $rdi = COPY %20:gr64
  $rsi = COPY %23:gr64
  $al = COPY %22:gr8
  CALL64pcrel32 target-flags(x86-plt) @__isoc99_scanf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %25:gr32 = MOV32rm %stack.0, 1, $noreg, 0, $noreg :: (dereferenceable load (s32) from %ir.1, !tbaa !5)
  %0:gr64 = SUBREG_TO_REG 0, killed %25:gr32, %subreg.sub_32bit
  %26:gr32 = COPY %0.sub_32bit:gr64
  TEST32rr %26:gr32, %26:gr32, implicit-def $eflags
  JCC_1 %bb.1, 15, implicit $eflags

bb.9:
; predecessors: %bb.0
  successors: %bb.7(0x80000000); %bb.7(100.00%)

  %19:gr64 = MOV32ri64 1
  JMP_1 %bb.7

bb.1 (%ir-block.6):
; predecessors: %bb.0
  successors: %bb.10(0x40000000), %bb.2(0x40000000); %bb.10(50.00%), %bb.2(50.00%)

  %29:gr64 = DEC64r %0:gr64(tied-def 0), implicit-def dead $eflags
  %30:gr32 = COPY %0.sub_32bit:gr64
  %31:gr32 = AND32ri %30:gr32(tied-def 0), 7, implicit-def dead $eflags
  %2:gr64 = SUBREG_TO_REG 0, killed %31:gr32, %subreg.sub_32bit
  %32:gr64 = SUB64ri32 %29:gr64(tied-def 0), 7, implicit-def $eflags
  JCC_1 %bb.2, 3, implicit $eflags

bb.10:
; predecessors: %bb.1
  successors: %bb.4(0x80000000); %bb.4(100.00%)

  %28:gr64 = MOV32ri64 1
  %27:gr64 = IMPLICIT_DEF
  JMP_1 %bb.4

bb.2 (%ir-block.12):
; predecessors: %bb.1
  successors: %bb.8(0x80000000); %bb.8(100.00%)

  %1:gr64 = COPY %0:gr64
  %35:gr32 = COPY %1.sub_32bit:gr64
  %36:gr32 = AND32ri %35:gr32(tied-def 0), -8, implicit-def dead $eflags
  %37:gr64 = SUBREG_TO_REG 0, killed %36:gr32, %subreg.sub_32bit
  %3:gr64 = NEG64r %37:gr64(tied-def 0), implicit-def dead $eflags
  %34:gr64 = MOV32ri64 1
  %33:gr64 = MOV32ri64 8
  JMP_1 %bb.8

bb.3 (%ir-block.15):
; predecessors: %bb.8
  successors: %bb.4(0x80000000); %bb.4(100.00%)

  %4:gr64 = ADD64ri32 %18:gr64(tied-def 0), -7, implicit-def dead $eflags

bb.4 (%ir-block.17):
; predecessors: %bb.3, %bb.10
  successors: %bb.7(0x30000000), %bb.5(0x50000000); %bb.7(37.50%), %bb.5(62.50%)

  %5:gr64 = PHI %27:gr64, %bb.10, %17:gr64, %bb.3
  %6:gr64 = PHI %28:gr64, %bb.10, %4:gr64, %bb.3
  %7:gr64 = PHI %28:gr64, %bb.10, %17:gr64, %bb.3
  TEST64rr %2:gr64, %2:gr64, implicit-def $eflags
  JCC_1 %bb.7, 4, implicit $eflags
  JMP_1 %bb.5

bb.5 (%ir-block.22):
; predecessors: %bb.4
  successors: %bb.6(0x80000000); %bb.6(100.00%)


bb.6 (%ir-block.23):
; predecessors: %bb.5, %bb.6
  successors: %bb.7(0x04000000), %bb.6(0x7c000000); %bb.7(3.12%), %bb.6(96.88%)

  %8:gr64 = PHI %2:gr64, %bb.5, %13:gr64, %bb.6
  %9:gr64 = PHI %6:gr64, %bb.5, %12:gr64, %bb.6
  %10:gr64 = PHI %7:gr64, %bb.5, %11:gr64, %bb.6
  %11:gr64 = IMUL64rr %10:gr64(tied-def 0), %9:gr64, implicit-def dead $eflags
  %12:gr64 = nuw nsw INC64r %9:gr64(tied-def 0), implicit-def dead $eflags
  %13:gr64 = DEC64r %8:gr64(tied-def 0), implicit-def $eflags
  JCC_1 %bb.6, 5, implicit $eflags
  JMP_1 %bb.7

bb.7 (%ir-block.31):
; predecessors: %bb.4, %bb.6, %bb.9

  %14:gr64 = PHI %19:gr64, %bb.9, %5:gr64, %bb.4, %11:gr64, %bb.6
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %54:gr64 = LEA64r $rip, 1, $noreg, @.str.1, $noreg
  %55:gr32 = MOV32r0 implicit-def dead $eflags
  %56:gr8 = COPY %55.sub_8bit:gr32
  $rdi = COPY %54:gr64
  $rsi = COPY %14:gr64
  $al = COPY %56:gr8
  CALL64pcrel32 target-flags(x86-plt) @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $eax = COPY %55:gr32
  RET 0, $eax

bb.8 (%ir-block.34):
; predecessors: %bb.2, %bb.8
  successors: %bb.3(0x04000000), %bb.8(0x7c000000); %bb.3(3.12%), %bb.8(96.88%)

  %15:gr64_nosp = PHI %33:gr64, %bb.2, %18:gr64, %bb.8
  %16:gr64 = PHI %34:gr64, %bb.2, %17:gr64, %bb.8
  %38:gr64 = ADD64ri32 %15:gr64_nosp(tied-def 0), -7, implicit-def dead $eflags
  %39:gr64 = IMUL64rr %16:gr64(tied-def 0), killed %38:gr64, implicit-def dead $eflags
  %40:gr64 = ADD64ri32 %15:gr64_nosp(tied-def 0), -6, implicit-def dead $eflags
  %42:gr64 = ADD64ri32 %15:gr64_nosp(tied-def 0), -5, implicit-def dead $eflags
  %60:gr64 = IMUL64rr killed %40:gr64(tied-def 0), killed %42:gr64, implicit-def dead $eflags
  %43:gr64 = IMUL64rr %39:gr64(tied-def 0), killed %60:gr64, implicit-def dead $eflags
  %44:gr64 = ADD64ri32 %15:gr64_nosp(tied-def 0), -4, implicit-def dead $eflags
  %46:gr64 = ADD64ri32 %15:gr64_nosp(tied-def 0), -3, implicit-def dead $eflags
  %63:gr64 = IMUL64rr killed %44:gr64(tied-def 0), killed %46:gr64, implicit-def dead $eflags
  %48:gr64 = ADD64ri32 %15:gr64_nosp(tied-def 0), -2, implicit-def dead $eflags
  %64:gr64 = IMUL64rr killed %63:gr64(tied-def 0), killed %48:gr64, implicit-def dead $eflags
  %49:gr64 = IMUL64rr %43:gr64(tied-def 0), killed %64:gr64, implicit-def dead $eflags
  %50:gr64 = DEC64r %15:gr64_nosp(tied-def 0), implicit-def dead $eflags
  %67:gr64 = IMUL64rr killed %50:gr64(tied-def 0), %15:gr64_nosp, implicit-def dead $eflags
  %17:gr64 = IMUL64rr %49:gr64(tied-def 0), killed %67:gr64, implicit-def dead $eflags
  %18:gr64 = ADD64ri32 %15:gr64_nosp(tied-def 0), 8, implicit-def dead $eflags
  %52:gr64 = LEA64r %3:gr64, 1, %15:gr64_nosp, 8, $noreg
  %53:gr64 = SUB64ri32 %52:gr64(tied-def 0), 8, implicit-def $eflags
  JCC_1 %bb.3, 4, implicit $eflags
  JMP_1 %bb.8

# End machine code for function main.

# *** IR Dump After Peephole Optimizations (peephole-opt) ***:
# Machine code for function main: IsSSA, TracksLiveness
Frame Objects:
  fi#0: size=4, align=4, at location [SP+8]

bb.0 (%ir-block.0):
  successors: %bb.9(0x30000000), %bb.1(0x50000000); %bb.9(37.50%), %bb.1(62.50%)

  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %20:gr64 = LEA64r $rip, 1, $noreg, @.str, $noreg
  %21:gr32 = MOV32r0 implicit-def dead $eflags
  %22:gr8 = COPY %21.sub_8bit:gr32
  %23:gr64 = LEA64r %stack.0, 1, $noreg, 0, $noreg
  $rdi = COPY %20:gr64
  $rsi = COPY %23:gr64
  $al = COPY %22:gr8
  CALL64pcrel32 target-flags(x86-plt) @__isoc99_scanf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %25:gr32 = MOV32rm %stack.0, 1, $noreg, 0, $noreg :: (dereferenceable load (s32) from %ir.1, !tbaa !5)
  %0:gr64 = SUBREG_TO_REG 0, killed %25:gr32, %subreg.sub_32bit
  %26:gr32 = COPY %0.sub_32bit:gr64
  TEST32rr %26:gr32, %26:gr32, implicit-def $eflags
  JCC_1 %bb.1, 15, implicit $eflags

bb.9:
; predecessors: %bb.0
  successors: %bb.7(0x80000000); %bb.7(100.00%)

  %19:gr64 = MOV32ri64 1
  JMP_1 %bb.7

bb.1 (%ir-block.6):
; predecessors: %bb.0
  successors: %bb.10(0x40000000), %bb.2(0x40000000); %bb.10(50.00%), %bb.2(50.00%)

  %29:gr64 = DEC64r %0:gr64(tied-def 0), implicit-def dead $eflags
  %30:gr32 = COPY %0.sub_32bit:gr64
  %31:gr32 = AND32ri %30:gr32(tied-def 0), 7, implicit-def dead $eflags
  %2:gr64 = SUBREG_TO_REG 0, killed %31:gr32, %subreg.sub_32bit
  CMP64ri32 %29:gr64, 7, implicit-def $eflags
  JCC_1 %bb.2, 3, implicit $eflags

bb.10:
; predecessors: %bb.1
  successors: %bb.4(0x80000000); %bb.4(100.00%)

  %28:gr64 = MOV32ri64 1
  %27:gr64 = IMPLICIT_DEF
  JMP_1 %bb.4

bb.2 (%ir-block.12):
; predecessors: %bb.1
  successors: %bb.8(0x80000000); %bb.8(100.00%)

  %1:gr64 = COPY %0:gr64
  %35:gr32 = COPY %1.sub_32bit:gr64
  %36:gr32 = AND32ri %35:gr32(tied-def 0), -8, implicit-def dead $eflags
  %37:gr64 = SUBREG_TO_REG 0, killed %36:gr32, %subreg.sub_32bit
  %3:gr64 = NEG64r %37:gr64(tied-def 0), implicit-def dead $eflags
  %34:gr64 = MOV32ri64 1
  %33:gr64 = MOV32ri64 8
  JMP_1 %bb.8

bb.3 (%ir-block.15):
; predecessors: %bb.8
  successors: %bb.4(0x80000000); %bb.4(100.00%)

  %4:gr64 = ADD64ri32 %18:gr64(tied-def 0), -7, implicit-def dead $eflags

bb.4 (%ir-block.17):
; predecessors: %bb.3, %bb.10
  successors: %bb.7(0x30000000), %bb.5(0x50000000); %bb.7(37.50%), %bb.5(62.50%)

  %5:gr64 = PHI %27:gr64, %bb.10, %17:gr64, %bb.3
  %6:gr64 = PHI %28:gr64, %bb.10, %4:gr64, %bb.3
  %7:gr64 = PHI %28:gr64, %bb.10, %17:gr64, %bb.3
  TEST64rr %2:gr64, %2:gr64, implicit-def $eflags
  JCC_1 %bb.7, 4, implicit $eflags
  JMP_1 %bb.5

bb.5 (%ir-block.22):
; predecessors: %bb.4
  successors: %bb.6(0x80000000); %bb.6(100.00%)


bb.6 (%ir-block.23):
; predecessors: %bb.5, %bb.6
  successors: %bb.7(0x04000000), %bb.6(0x7c000000); %bb.7(3.12%), %bb.6(96.88%)

  %8:gr64 = PHI %2:gr64, %bb.5, %13:gr64, %bb.6
  %9:gr64 = PHI %6:gr64, %bb.5, %12:gr64, %bb.6
  %10:gr64 = PHI %7:gr64, %bb.5, %11:gr64, %bb.6
  %11:gr64 = IMUL64rr %10:gr64(tied-def 0), %9:gr64, implicit-def dead $eflags
  %12:gr64 = nuw nsw INC64r %9:gr64(tied-def 0), implicit-def dead $eflags
  %13:gr64 = DEC64r %8:gr64(tied-def 0), implicit-def $eflags
  JCC_1 %bb.6, 5, implicit $eflags
  JMP_1 %bb.7

bb.7 (%ir-block.31):
; predecessors: %bb.4, %bb.6, %bb.9

  %14:gr64 = PHI %19:gr64, %bb.9, %5:gr64, %bb.4, %11:gr64, %bb.6
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %54:gr64 = LEA64r $rip, 1, $noreg, @.str.1, $noreg
  %55:gr32 = MOV32r0 implicit-def dead $eflags
  %56:gr8 = COPY %55.sub_8bit:gr32
  $rdi = COPY %54:gr64
  $rsi = COPY %14:gr64
  $al = COPY %56:gr8
  CALL64pcrel32 target-flags(x86-plt) @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $eax = MOV32r0 implicit-def dead $eflags
  RET 0, $eax

bb.8 (%ir-block.34):
; predecessors: %bb.2, %bb.8
  successors: %bb.3(0x04000000), %bb.8(0x7c000000); %bb.3(3.12%), %bb.8(96.88%)

  %15:gr64_nosp = PHI %33:gr64, %bb.2, %18:gr64, %bb.8
  %16:gr64 = PHI %34:gr64, %bb.2, %17:gr64, %bb.8
  %38:gr64 = ADD64ri32 %15:gr64_nosp(tied-def 0), -7, implicit-def dead $eflags
  %39:gr64 = IMUL64rr %16:gr64(tied-def 0), killed %38:gr64, implicit-def dead $eflags
  %40:gr64 = ADD64ri32 %15:gr64_nosp(tied-def 0), -6, implicit-def dead $eflags
  %42:gr64 = ADD64ri32 %15:gr64_nosp(tied-def 0), -5, implicit-def dead $eflags
  %60:gr64 = IMUL64rr killed %40:gr64(tied-def 0), killed %42:gr64, implicit-def dead $eflags
  %43:gr64 = IMUL64rr %39:gr64(tied-def 0), killed %60:gr64, implicit-def dead $eflags
  %44:gr64 = ADD64ri32 %15:gr64_nosp(tied-def 0), -4, implicit-def dead $eflags
  %46:gr64 = ADD64ri32 %15:gr64_nosp(tied-def 0), -3, implicit-def dead $eflags
  %63:gr64 = IMUL64rr killed %44:gr64(tied-def 0), killed %46:gr64, implicit-def dead $eflags
  %48:gr64 = ADD64ri32 %15:gr64_nosp(tied-def 0), -2, implicit-def dead $eflags
  %64:gr64 = IMUL64rr killed %63:gr64(tied-def 0), killed %48:gr64, implicit-def dead $eflags
  %49:gr64 = IMUL64rr %43:gr64(tied-def 0), killed %64:gr64, implicit-def dead $eflags
  %50:gr64 = DEC64r %15:gr64_nosp(tied-def 0), implicit-def dead $eflags
  %67:gr64 = IMUL64rr killed %50:gr64(tied-def 0), %15:gr64_nosp, implicit-def dead $eflags
  %17:gr64 = IMUL64rr %49:gr64(tied-def 0), killed %67:gr64, implicit-def dead $eflags
  %18:gr64 = ADD64ri32 %15:gr64_nosp(tied-def 0), 8, implicit-def dead $eflags
  %52:gr64 = LEA64r %3:gr64, 1, %15:gr64_nosp, 8, $noreg
  CMP64ri32 %52:gr64, 8, implicit-def $eflags
  JCC_1 %bb.3, 4, implicit $eflags
  JMP_1 %bb.8

# End machine code for function main.

# *** IR Dump After Remove dead machine instructions (dead-mi-elimination) ***:
# Machine code for function main: IsSSA, TracksLiveness
Frame Objects:
  fi#0: size=4, align=4, at location [SP+8]

bb.0 (%ir-block.0):
  successors: %bb.9(0x30000000), %bb.1(0x50000000); %bb.9(37.50%), %bb.1(62.50%)

  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %20:gr64 = LEA64r $rip, 1, $noreg, @.str, $noreg
  %21:gr32 = MOV32r0 implicit-def dead $eflags
  %22:gr8 = COPY %21.sub_8bit:gr32
  %23:gr64 = LEA64r %stack.0, 1, $noreg, 0, $noreg
  $rdi = COPY %20:gr64
  $rsi = COPY %23:gr64
  $al = COPY %22:gr8
  CALL64pcrel32 target-flags(x86-plt) @__isoc99_scanf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %25:gr32 = MOV32rm %stack.0, 1, $noreg, 0, $noreg :: (dereferenceable load (s32) from %ir.1, !tbaa !5)
  %0:gr64 = SUBREG_TO_REG 0, killed %25:gr32, %subreg.sub_32bit
  %26:gr32 = COPY %0.sub_32bit:gr64
  TEST32rr %26:gr32, %26:gr32, implicit-def $eflags
  JCC_1 %bb.1, 15, implicit $eflags

bb.9:
; predecessors: %bb.0
  successors: %bb.7(0x80000000); %bb.7(100.00%)

  %19:gr64 = MOV32ri64 1
  JMP_1 %bb.7

bb.1 (%ir-block.6):
; predecessors: %bb.0
  successors: %bb.10(0x40000000), %bb.2(0x40000000); %bb.10(50.00%), %bb.2(50.00%)

  %29:gr64 = DEC64r %0:gr64(tied-def 0), implicit-def dead $eflags
  %30:gr32 = COPY %0.sub_32bit:gr64
  %31:gr32 = AND32ri %30:gr32(tied-def 0), 7, implicit-def dead $eflags
  %2:gr64 = SUBREG_TO_REG 0, killed %31:gr32, %subreg.sub_32bit
  CMP64ri32 %29:gr64, 7, implicit-def $eflags
  JCC_1 %bb.2, 3, implicit $eflags

bb.10:
; predecessors: %bb.1
  successors: %bb.4(0x80000000); %bb.4(100.00%)

  %28:gr64 = MOV32ri64 1
  %27:gr64 = IMPLICIT_DEF
  JMP_1 %bb.4

bb.2 (%ir-block.12):
; predecessors: %bb.1
  successors: %bb.8(0x80000000); %bb.8(100.00%)

  %1:gr64 = COPY %0:gr64
  %35:gr32 = COPY %1.sub_32bit:gr64
  %36:gr32 = AND32ri %35:gr32(tied-def 0), -8, implicit-def dead $eflags
  %37:gr64 = SUBREG_TO_REG 0, killed %36:gr32, %subreg.sub_32bit
  %3:gr64 = NEG64r %37:gr64(tied-def 0), implicit-def dead $eflags
  %34:gr64 = MOV32ri64 1
  %33:gr64 = MOV32ri64 8
  JMP_1 %bb.8

bb.3 (%ir-block.15):
; predecessors: %bb.8
  successors: %bb.4(0x80000000); %bb.4(100.00%)

  %4:gr64 = ADD64ri32 %18:gr64(tied-def 0), -7, implicit-def dead $eflags

bb.4 (%ir-block.17):
; predecessors: %bb.3, %bb.10
  successors: %bb.7(0x30000000), %bb.5(0x50000000); %bb.7(37.50%), %bb.5(62.50%)

  %5:gr64 = PHI %27:gr64, %bb.10, %17:gr64, %bb.3
  %6:gr64 = PHI %28:gr64, %bb.10, %4:gr64, %bb.3
  %7:gr64 = PHI %28:gr64, %bb.10, %17:gr64, %bb.3
  TEST64rr %2:gr64, %2:gr64, implicit-def $eflags
  JCC_1 %bb.7, 4, implicit $eflags
  JMP_1 %bb.5

bb.5 (%ir-block.22):
; predecessors: %bb.4
  successors: %bb.6(0x80000000); %bb.6(100.00%)


bb.6 (%ir-block.23):
; predecessors: %bb.5, %bb.6
  successors: %bb.7(0x04000000), %bb.6(0x7c000000); %bb.7(3.12%), %bb.6(96.88%)

  %8:gr64 = PHI %2:gr64, %bb.5, %13:gr64, %bb.6
  %9:gr64 = PHI %6:gr64, %bb.5, %12:gr64, %bb.6
  %10:gr64 = PHI %7:gr64, %bb.5, %11:gr64, %bb.6
  %11:gr64 = IMUL64rr %10:gr64(tied-def 0), %9:gr64, implicit-def dead $eflags
  %12:gr64 = nuw nsw INC64r %9:gr64(tied-def 0), implicit-def dead $eflags
  %13:gr64 = DEC64r %8:gr64(tied-def 0), implicit-def $eflags
  JCC_1 %bb.6, 5, implicit $eflags
  JMP_1 %bb.7

bb.7 (%ir-block.31):
; predecessors: %bb.4, %bb.6, %bb.9

  %14:gr64 = PHI %19:gr64, %bb.9, %5:gr64, %bb.4, %11:gr64, %bb.6
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %54:gr64 = LEA64r $rip, 1, $noreg, @.str.1, $noreg
  %55:gr32 = MOV32r0 implicit-def dead $eflags
  %56:gr8 = COPY %55.sub_8bit:gr32
  $rdi = COPY %54:gr64
  $rsi = COPY %14:gr64
  $al = COPY %56:gr8
  CALL64pcrel32 target-flags(x86-plt) @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $eax = MOV32r0 implicit-def dead $eflags
  RET 0, $eax

bb.8 (%ir-block.34):
; predecessors: %bb.2, %bb.8
  successors: %bb.3(0x04000000), %bb.8(0x7c000000); %bb.3(3.12%), %bb.8(96.88%)

  %15:gr64_nosp = PHI %33:gr64, %bb.2, %18:gr64, %bb.8
  %16:gr64 = PHI %34:gr64, %bb.2, %17:gr64, %bb.8
  %38:gr64 = ADD64ri32 %15:gr64_nosp(tied-def 0), -7, implicit-def dead $eflags
  %39:gr64 = IMUL64rr %16:gr64(tied-def 0), killed %38:gr64, implicit-def dead $eflags
  %40:gr64 = ADD64ri32 %15:gr64_nosp(tied-def 0), -6, implicit-def dead $eflags
  %42:gr64 = ADD64ri32 %15:gr64_nosp(tied-def 0), -5, implicit-def dead $eflags
  %60:gr64 = IMUL64rr killed %40:gr64(tied-def 0), killed %42:gr64, implicit-def dead $eflags
  %43:gr64 = IMUL64rr %39:gr64(tied-def 0), killed %60:gr64, implicit-def dead $eflags
  %44:gr64 = ADD64ri32 %15:gr64_nosp(tied-def 0), -4, implicit-def dead $eflags
  %46:gr64 = ADD64ri32 %15:gr64_nosp(tied-def 0), -3, implicit-def dead $eflags
  %63:gr64 = IMUL64rr killed %44:gr64(tied-def 0), killed %46:gr64, implicit-def dead $eflags
  %48:gr64 = ADD64ri32 %15:gr64_nosp(tied-def 0), -2, implicit-def dead $eflags
  %64:gr64 = IMUL64rr killed %63:gr64(tied-def 0), killed %48:gr64, implicit-def dead $eflags
  %49:gr64 = IMUL64rr %43:gr64(tied-def 0), killed %64:gr64, implicit-def dead $eflags
  %50:gr64 = DEC64r %15:gr64_nosp(tied-def 0), implicit-def dead $eflags
  %67:gr64 = IMUL64rr killed %50:gr64(tied-def 0), %15:gr64_nosp, implicit-def dead $eflags
  %17:gr64 = IMUL64rr %49:gr64(tied-def 0), killed %67:gr64, implicit-def dead $eflags
  %18:gr64 = ADD64ri32 %15:gr64_nosp(tied-def 0), 8, implicit-def dead $eflags
  %52:gr64 = LEA64r %3:gr64, 1, %15:gr64_nosp, 8, $noreg
  CMP64ri32 %52:gr64, 8, implicit-def $eflags
  JCC_1 %bb.3, 4, implicit $eflags
  JMP_1 %bb.8

# End machine code for function main.

# *** IR Dump After Live Range Shrink (lrshrink) ***:
# Machine code for function main: IsSSA, TracksLiveness
Frame Objects:
  fi#0: size=4, align=4, at location [SP+8]

bb.0 (%ir-block.0):
  successors: %bb.9(0x30000000), %bb.1(0x50000000); %bb.9(37.50%), %bb.1(62.50%)

  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %20:gr64 = LEA64r $rip, 1, $noreg, @.str, $noreg
  %21:gr32 = MOV32r0 implicit-def dead $eflags
  %22:gr8 = COPY %21.sub_8bit:gr32
  %23:gr64 = LEA64r %stack.0, 1, $noreg, 0, $noreg
  $rdi = COPY %20:gr64
  $rsi = COPY %23:gr64
  $al = COPY %22:gr8
  CALL64pcrel32 target-flags(x86-plt) @__isoc99_scanf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %25:gr32 = MOV32rm %stack.0, 1, $noreg, 0, $noreg :: (dereferenceable load (s32) from %ir.1, !tbaa !5)
  %0:gr64 = SUBREG_TO_REG 0, killed %25:gr32, %subreg.sub_32bit
  %26:gr32 = COPY %0.sub_32bit:gr64
  TEST32rr %26:gr32, %26:gr32, implicit-def $eflags
  JCC_1 %bb.1, 15, implicit $eflags

bb.9:
; predecessors: %bb.0
  successors: %bb.7(0x80000000); %bb.7(100.00%)

  %19:gr64 = MOV32ri64 1
  JMP_1 %bb.7

bb.1 (%ir-block.6):
; predecessors: %bb.0
  successors: %bb.10(0x40000000), %bb.2(0x40000000); %bb.10(50.00%), %bb.2(50.00%)

  %29:gr64 = DEC64r %0:gr64(tied-def 0), implicit-def dead $eflags
  %30:gr32 = COPY %0.sub_32bit:gr64
  %31:gr32 = AND32ri %30:gr32(tied-def 0), 7, implicit-def dead $eflags
  %2:gr64 = SUBREG_TO_REG 0, killed %31:gr32, %subreg.sub_32bit
  CMP64ri32 %29:gr64, 7, implicit-def $eflags
  JCC_1 %bb.2, 3, implicit $eflags

bb.10:
; predecessors: %bb.1
  successors: %bb.4(0x80000000); %bb.4(100.00%)

  %28:gr64 = MOV32ri64 1
  %27:gr64 = IMPLICIT_DEF
  JMP_1 %bb.4

bb.2 (%ir-block.12):
; predecessors: %bb.1
  successors: %bb.8(0x80000000); %bb.8(100.00%)

  %1:gr64 = COPY %0:gr64
  %35:gr32 = COPY %1.sub_32bit:gr64
  %36:gr32 = AND32ri %35:gr32(tied-def 0), -8, implicit-def dead $eflags
  %37:gr64 = SUBREG_TO_REG 0, killed %36:gr32, %subreg.sub_32bit
  %3:gr64 = NEG64r %37:gr64(tied-def 0), implicit-def dead $eflags
  %34:gr64 = MOV32ri64 1
  %33:gr64 = MOV32ri64 8
  JMP_1 %bb.8

bb.3 (%ir-block.15):
; predecessors: %bb.8
  successors: %bb.4(0x80000000); %bb.4(100.00%)

  %4:gr64 = ADD64ri32 %18:gr64(tied-def 0), -7, implicit-def dead $eflags

bb.4 (%ir-block.17):
; predecessors: %bb.3, %bb.10
  successors: %bb.7(0x30000000), %bb.5(0x50000000); %bb.7(37.50%), %bb.5(62.50%)

  %5:gr64 = PHI %27:gr64, %bb.10, %17:gr64, %bb.3
  %6:gr64 = PHI %28:gr64, %bb.10, %4:gr64, %bb.3
  %7:gr64 = PHI %28:gr64, %bb.10, %17:gr64, %bb.3
  TEST64rr %2:gr64, %2:gr64, implicit-def $eflags
  JCC_1 %bb.7, 4, implicit $eflags
  JMP_1 %bb.5

bb.5 (%ir-block.22):
; predecessors: %bb.4
  successors: %bb.6(0x80000000); %bb.6(100.00%)


bb.6 (%ir-block.23):
; predecessors: %bb.5, %bb.6
  successors: %bb.7(0x04000000), %bb.6(0x7c000000); %bb.7(3.12%), %bb.6(96.88%)

  %8:gr64 = PHI %2:gr64, %bb.5, %13:gr64, %bb.6
  %9:gr64 = PHI %6:gr64, %bb.5, %12:gr64, %bb.6
  %10:gr64 = PHI %7:gr64, %bb.5, %11:gr64, %bb.6
  %11:gr64 = IMUL64rr %10:gr64(tied-def 0), %9:gr64, implicit-def dead $eflags
  %12:gr64 = nuw nsw INC64r %9:gr64(tied-def 0), implicit-def dead $eflags
  %13:gr64 = DEC64r %8:gr64(tied-def 0), implicit-def $eflags
  JCC_1 %bb.6, 5, implicit $eflags
  JMP_1 %bb.7

bb.7 (%ir-block.31):
; predecessors: %bb.4, %bb.6, %bb.9

  %14:gr64 = PHI %19:gr64, %bb.9, %5:gr64, %bb.4, %11:gr64, %bb.6
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %54:gr64 = LEA64r $rip, 1, $noreg, @.str.1, $noreg
  %55:gr32 = MOV32r0 implicit-def dead $eflags
  %56:gr8 = COPY %55.sub_8bit:gr32
  $rdi = COPY %54:gr64
  $rsi = COPY %14:gr64
  $al = COPY %56:gr8
  CALL64pcrel32 target-flags(x86-plt) @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $eax = MOV32r0 implicit-def dead $eflags
  RET 0, $eax

bb.8 (%ir-block.34):
; predecessors: %bb.2, %bb.8
  successors: %bb.3(0x04000000), %bb.8(0x7c000000); %bb.3(3.12%), %bb.8(96.88%)

  %15:gr64_nosp = PHI %33:gr64, %bb.2, %18:gr64, %bb.8
  %16:gr64 = PHI %34:gr64, %bb.2, %17:gr64, %bb.8
  %38:gr64 = ADD64ri32 %15:gr64_nosp(tied-def 0), -7, implicit-def dead $eflags
  %39:gr64 = IMUL64rr %16:gr64(tied-def 0), killed %38:gr64, implicit-def dead $eflags
  %40:gr64 = ADD64ri32 %15:gr64_nosp(tied-def 0), -6, implicit-def dead $eflags
  %42:gr64 = ADD64ri32 %15:gr64_nosp(tied-def 0), -5, implicit-def dead $eflags
  %60:gr64 = IMUL64rr killed %40:gr64(tied-def 0), killed %42:gr64, implicit-def dead $eflags
  %43:gr64 = IMUL64rr %39:gr64(tied-def 0), killed %60:gr64, implicit-def dead $eflags
  %44:gr64 = ADD64ri32 %15:gr64_nosp(tied-def 0), -4, implicit-def dead $eflags
  %46:gr64 = ADD64ri32 %15:gr64_nosp(tied-def 0), -3, implicit-def dead $eflags
  %63:gr64 = IMUL64rr killed %44:gr64(tied-def 0), killed %46:gr64, implicit-def dead $eflags
  %48:gr64 = ADD64ri32 %15:gr64_nosp(tied-def 0), -2, implicit-def dead $eflags
  %64:gr64 = IMUL64rr killed %63:gr64(tied-def 0), killed %48:gr64, implicit-def dead $eflags
  %49:gr64 = IMUL64rr %43:gr64(tied-def 0), killed %64:gr64, implicit-def dead $eflags
  %50:gr64 = DEC64r %15:gr64_nosp(tied-def 0), implicit-def dead $eflags
  %67:gr64 = IMUL64rr killed %50:gr64(tied-def 0), %15:gr64_nosp, implicit-def dead $eflags
  %17:gr64 = IMUL64rr %49:gr64(tied-def 0), killed %67:gr64, implicit-def dead $eflags
  %18:gr64 = ADD64ri32 %15:gr64_nosp(tied-def 0), 8, implicit-def dead $eflags
  %52:gr64 = LEA64r %3:gr64, 1, %15:gr64_nosp, 8, $noreg
  CMP64ri32 %52:gr64, 8, implicit-def $eflags
  JCC_1 %bb.3, 4, implicit $eflags
  JMP_1 %bb.8

# End machine code for function main.

# *** IR Dump After X86 Fixup SetCC (x86-fixup-setcc) ***:
# Machine code for function main: IsSSA, TracksLiveness
Frame Objects:
  fi#0: size=4, align=4, at location [SP+8]

bb.0 (%ir-block.0):
  successors: %bb.9(0x30000000), %bb.1(0x50000000); %bb.9(37.50%), %bb.1(62.50%)

  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %20:gr64 = LEA64r $rip, 1, $noreg, @.str, $noreg
  %21:gr32 = MOV32r0 implicit-def dead $eflags
  %22:gr8 = COPY %21.sub_8bit:gr32
  %23:gr64 = LEA64r %stack.0, 1, $noreg, 0, $noreg
  $rdi = COPY %20:gr64
  $rsi = COPY %23:gr64
  $al = COPY %22:gr8
  CALL64pcrel32 target-flags(x86-plt) @__isoc99_scanf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %25:gr32 = MOV32rm %stack.0, 1, $noreg, 0, $noreg :: (dereferenceable load (s32) from %ir.1, !tbaa !5)
  %0:gr64 = SUBREG_TO_REG 0, killed %25:gr32, %subreg.sub_32bit
  %26:gr32 = COPY %0.sub_32bit:gr64
  TEST32rr %26:gr32, %26:gr32, implicit-def $eflags
  JCC_1 %bb.1, 15, implicit $eflags

bb.9:
; predecessors: %bb.0
  successors: %bb.7(0x80000000); %bb.7(100.00%)

  %19:gr64 = MOV32ri64 1
  JMP_1 %bb.7

bb.1 (%ir-block.6):
; predecessors: %bb.0
  successors: %bb.10(0x40000000), %bb.2(0x40000000); %bb.10(50.00%), %bb.2(50.00%)

  %29:gr64 = DEC64r %0:gr64(tied-def 0), implicit-def dead $eflags
  %30:gr32 = COPY %0.sub_32bit:gr64
  %31:gr32 = AND32ri %30:gr32(tied-def 0), 7, implicit-def dead $eflags
  %2:gr64 = SUBREG_TO_REG 0, killed %31:gr32, %subreg.sub_32bit
  CMP64ri32 %29:gr64, 7, implicit-def $eflags
  JCC_1 %bb.2, 3, implicit $eflags

bb.10:
; predecessors: %bb.1
  successors: %bb.4(0x80000000); %bb.4(100.00%)

  %28:gr64 = MOV32ri64 1
  %27:gr64 = IMPLICIT_DEF
  JMP_1 %bb.4

bb.2 (%ir-block.12):
; predecessors: %bb.1
  successors: %bb.8(0x80000000); %bb.8(100.00%)

  %1:gr64 = COPY %0:gr64
  %35:gr32 = COPY %1.sub_32bit:gr64
  %36:gr32 = AND32ri %35:gr32(tied-def 0), -8, implicit-def dead $eflags
  %37:gr64 = SUBREG_TO_REG 0, killed %36:gr32, %subreg.sub_32bit
  %3:gr64 = NEG64r %37:gr64(tied-def 0), implicit-def dead $eflags
  %34:gr64 = MOV32ri64 1
  %33:gr64 = MOV32ri64 8
  JMP_1 %bb.8

bb.3 (%ir-block.15):
; predecessors: %bb.8
  successors: %bb.4(0x80000000); %bb.4(100.00%)

  %4:gr64 = ADD64ri32 %18:gr64(tied-def 0), -7, implicit-def dead $eflags

bb.4 (%ir-block.17):
; predecessors: %bb.3, %bb.10
  successors: %bb.7(0x30000000), %bb.5(0x50000000); %bb.7(37.50%), %bb.5(62.50%)

  %5:gr64 = PHI %27:gr64, %bb.10, %17:gr64, %bb.3
  %6:gr64 = PHI %28:gr64, %bb.10, %4:gr64, %bb.3
  %7:gr64 = PHI %28:gr64, %bb.10, %17:gr64, %bb.3
  TEST64rr %2:gr64, %2:gr64, implicit-def $eflags
  JCC_1 %bb.7, 4, implicit $eflags
  JMP_1 %bb.5

bb.5 (%ir-block.22):
; predecessors: %bb.4
  successors: %bb.6(0x80000000); %bb.6(100.00%)


bb.6 (%ir-block.23):
; predecessors: %bb.5, %bb.6
  successors: %bb.7(0x04000000), %bb.6(0x7c000000); %bb.7(3.12%), %bb.6(96.88%)

  %8:gr64 = PHI %2:gr64, %bb.5, %13:gr64, %bb.6
  %9:gr64 = PHI %6:gr64, %bb.5, %12:gr64, %bb.6
  %10:gr64 = PHI %7:gr64, %bb.5, %11:gr64, %bb.6
  %11:gr64 = IMUL64rr %10:gr64(tied-def 0), %9:gr64, implicit-def dead $eflags
  %12:gr64 = nuw nsw INC64r %9:gr64(tied-def 0), implicit-def dead $eflags
  %13:gr64 = DEC64r %8:gr64(tied-def 0), implicit-def $eflags
  JCC_1 %bb.6, 5, implicit $eflags
  JMP_1 %bb.7

bb.7 (%ir-block.31):
; predecessors: %bb.4, %bb.6, %bb.9

  %14:gr64 = PHI %19:gr64, %bb.9, %5:gr64, %bb.4, %11:gr64, %bb.6
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %54:gr64 = LEA64r $rip, 1, $noreg, @.str.1, $noreg
  %55:gr32 = MOV32r0 implicit-def dead $eflags
  %56:gr8 = COPY %55.sub_8bit:gr32
  $rdi = COPY %54:gr64
  $rsi = COPY %14:gr64
  $al = COPY %56:gr8
  CALL64pcrel32 target-flags(x86-plt) @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $eax = MOV32r0 implicit-def dead $eflags
  RET 0, $eax

bb.8 (%ir-block.34):
; predecessors: %bb.2, %bb.8
  successors: %bb.3(0x04000000), %bb.8(0x7c000000); %bb.3(3.12%), %bb.8(96.88%)

  %15:gr64_nosp = PHI %33:gr64, %bb.2, %18:gr64, %bb.8
  %16:gr64 = PHI %34:gr64, %bb.2, %17:gr64, %bb.8
  %38:gr64 = ADD64ri32 %15:gr64_nosp(tied-def 0), -7, implicit-def dead $eflags
  %39:gr64 = IMUL64rr %16:gr64(tied-def 0), killed %38:gr64, implicit-def dead $eflags
  %40:gr64 = ADD64ri32 %15:gr64_nosp(tied-def 0), -6, implicit-def dead $eflags
  %42:gr64 = ADD64ri32 %15:gr64_nosp(tied-def 0), -5, implicit-def dead $eflags
  %60:gr64 = IMUL64rr killed %40:gr64(tied-def 0), killed %42:gr64, implicit-def dead $eflags
  %43:gr64 = IMUL64rr %39:gr64(tied-def 0), killed %60:gr64, implicit-def dead $eflags
  %44:gr64 = ADD64ri32 %15:gr64_nosp(tied-def 0), -4, implicit-def dead $eflags
  %46:gr64 = ADD64ri32 %15:gr64_nosp(tied-def 0), -3, implicit-def dead $eflags
  %63:gr64 = IMUL64rr killed %44:gr64(tied-def 0), killed %46:gr64, implicit-def dead $eflags
  %48:gr64 = ADD64ri32 %15:gr64_nosp(tied-def 0), -2, implicit-def dead $eflags
  %64:gr64 = IMUL64rr killed %63:gr64(tied-def 0), killed %48:gr64, implicit-def dead $eflags
  %49:gr64 = IMUL64rr %43:gr64(tied-def 0), killed %64:gr64, implicit-def dead $eflags
  %50:gr64 = DEC64r %15:gr64_nosp(tied-def 0), implicit-def dead $eflags
  %67:gr64 = IMUL64rr killed %50:gr64(tied-def 0), %15:gr64_nosp, implicit-def dead $eflags
  %17:gr64 = IMUL64rr %49:gr64(tied-def 0), killed %67:gr64, implicit-def dead $eflags
  %18:gr64 = ADD64ri32 %15:gr64_nosp(tied-def 0), 8, implicit-def dead $eflags
  %52:gr64 = LEA64r %3:gr64, 1, %15:gr64_nosp, 8, $noreg
  CMP64ri32 %52:gr64, 8, implicit-def $eflags
  JCC_1 %bb.3, 4, implicit $eflags
  JMP_1 %bb.8

# End machine code for function main.

# *** IR Dump After X86 LEA Optimize (x86-optimize-LEAs) ***:
# Machine code for function main: IsSSA, TracksLiveness
Frame Objects:
  fi#0: size=4, align=4, at location [SP+8]

bb.0 (%ir-block.0):
  successors: %bb.9(0x30000000), %bb.1(0x50000000); %bb.9(37.50%), %bb.1(62.50%)

  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %20:gr64 = LEA64r $rip, 1, $noreg, @.str, $noreg
  %21:gr32 = MOV32r0 implicit-def dead $eflags
  %22:gr8 = COPY %21.sub_8bit:gr32
  %23:gr64 = LEA64r %stack.0, 1, $noreg, 0, $noreg
  $rdi = COPY %20:gr64
  $rsi = COPY %23:gr64
  $al = COPY %22:gr8
  CALL64pcrel32 target-flags(x86-plt) @__isoc99_scanf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %25:gr32 = MOV32rm %stack.0, 1, $noreg, 0, $noreg :: (dereferenceable load (s32) from %ir.1, !tbaa !5)
  %0:gr64 = SUBREG_TO_REG 0, killed %25:gr32, %subreg.sub_32bit
  %26:gr32 = COPY %0.sub_32bit:gr64
  TEST32rr %26:gr32, %26:gr32, implicit-def $eflags
  JCC_1 %bb.1, 15, implicit $eflags

bb.9:
; predecessors: %bb.0
  successors: %bb.7(0x80000000); %bb.7(100.00%)

  %19:gr64 = MOV32ri64 1
  JMP_1 %bb.7

bb.1 (%ir-block.6):
; predecessors: %bb.0
  successors: %bb.10(0x40000000), %bb.2(0x40000000); %bb.10(50.00%), %bb.2(50.00%)

  %29:gr64 = DEC64r %0:gr64(tied-def 0), implicit-def dead $eflags
  %30:gr32 = COPY %0.sub_32bit:gr64
  %31:gr32 = AND32ri %30:gr32(tied-def 0), 7, implicit-def dead $eflags
  %2:gr64 = SUBREG_TO_REG 0, killed %31:gr32, %subreg.sub_32bit
  CMP64ri32 %29:gr64, 7, implicit-def $eflags
  JCC_1 %bb.2, 3, implicit $eflags

bb.10:
; predecessors: %bb.1
  successors: %bb.4(0x80000000); %bb.4(100.00%)

  %28:gr64 = MOV32ri64 1
  %27:gr64 = IMPLICIT_DEF
  JMP_1 %bb.4

bb.2 (%ir-block.12):
; predecessors: %bb.1
  successors: %bb.8(0x80000000); %bb.8(100.00%)

  %1:gr64 = COPY %0:gr64
  %35:gr32 = COPY %1.sub_32bit:gr64
  %36:gr32 = AND32ri %35:gr32(tied-def 0), -8, implicit-def dead $eflags
  %37:gr64 = SUBREG_TO_REG 0, killed %36:gr32, %subreg.sub_32bit
  %3:gr64 = NEG64r %37:gr64(tied-def 0), implicit-def dead $eflags
  %34:gr64 = MOV32ri64 1
  %33:gr64 = MOV32ri64 8
  JMP_1 %bb.8

bb.3 (%ir-block.15):
; predecessors: %bb.8
  successors: %bb.4(0x80000000); %bb.4(100.00%)

  %4:gr64 = ADD64ri32 %18:gr64(tied-def 0), -7, implicit-def dead $eflags

bb.4 (%ir-block.17):
; predecessors: %bb.3, %bb.10
  successors: %bb.7(0x30000000), %bb.5(0x50000000); %bb.7(37.50%), %bb.5(62.50%)

  %5:gr64 = PHI %27:gr64, %bb.10, %17:gr64, %bb.3
  %6:gr64 = PHI %28:gr64, %bb.10, %4:gr64, %bb.3
  %7:gr64 = PHI %28:gr64, %bb.10, %17:gr64, %bb.3
  TEST64rr %2:gr64, %2:gr64, implicit-def $eflags
  JCC_1 %bb.7, 4, implicit $eflags
  JMP_1 %bb.5

bb.5 (%ir-block.22):
; predecessors: %bb.4
  successors: %bb.6(0x80000000); %bb.6(100.00%)


bb.6 (%ir-block.23):
; predecessors: %bb.5, %bb.6
  successors: %bb.7(0x04000000), %bb.6(0x7c000000); %bb.7(3.12%), %bb.6(96.88%)

  %8:gr64 = PHI %2:gr64, %bb.5, %13:gr64, %bb.6
  %9:gr64 = PHI %6:gr64, %bb.5, %12:gr64, %bb.6
  %10:gr64 = PHI %7:gr64, %bb.5, %11:gr64, %bb.6
  %11:gr64 = IMUL64rr %10:gr64(tied-def 0), %9:gr64, implicit-def dead $eflags
  %12:gr64 = nuw nsw INC64r %9:gr64(tied-def 0), implicit-def dead $eflags
  %13:gr64 = DEC64r %8:gr64(tied-def 0), implicit-def $eflags
  JCC_1 %bb.6, 5, implicit $eflags
  JMP_1 %bb.7

bb.7 (%ir-block.31):
; predecessors: %bb.4, %bb.6, %bb.9

  %14:gr64 = PHI %19:gr64, %bb.9, %5:gr64, %bb.4, %11:gr64, %bb.6
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %54:gr64 = LEA64r $rip, 1, $noreg, @.str.1, $noreg
  %55:gr32 = MOV32r0 implicit-def dead $eflags
  %56:gr8 = COPY %55.sub_8bit:gr32
  $rdi = COPY %54:gr64
  $rsi = COPY %14:gr64
  $al = COPY %56:gr8
  CALL64pcrel32 target-flags(x86-plt) @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $eax = MOV32r0 implicit-def dead $eflags
  RET 0, $eax

bb.8 (%ir-block.34):
; predecessors: %bb.2, %bb.8
  successors: %bb.3(0x04000000), %bb.8(0x7c000000); %bb.3(3.12%), %bb.8(96.88%)

  %15:gr64_nosp = PHI %33:gr64, %bb.2, %18:gr64, %bb.8
  %16:gr64 = PHI %34:gr64, %bb.2, %17:gr64, %bb.8
  %38:gr64 = ADD64ri32 %15:gr64_nosp(tied-def 0), -7, implicit-def dead $eflags
  %39:gr64 = IMUL64rr %16:gr64(tied-def 0), killed %38:gr64, implicit-def dead $eflags
  %40:gr64 = ADD64ri32 %15:gr64_nosp(tied-def 0), -6, implicit-def dead $eflags
  %42:gr64 = ADD64ri32 %15:gr64_nosp(tied-def 0), -5, implicit-def dead $eflags
  %60:gr64 = IMUL64rr killed %40:gr64(tied-def 0), killed %42:gr64, implicit-def dead $eflags
  %43:gr64 = IMUL64rr %39:gr64(tied-def 0), killed %60:gr64, implicit-def dead $eflags
  %44:gr64 = ADD64ri32 %15:gr64_nosp(tied-def 0), -4, implicit-def dead $eflags
  %46:gr64 = ADD64ri32 %15:gr64_nosp(tied-def 0), -3, implicit-def dead $eflags
  %63:gr64 = IMUL64rr killed %44:gr64(tied-def 0), killed %46:gr64, implicit-def dead $eflags
  %48:gr64 = ADD64ri32 %15:gr64_nosp(tied-def 0), -2, implicit-def dead $eflags
  %64:gr64 = IMUL64rr killed %63:gr64(tied-def 0), killed %48:gr64, implicit-def dead $eflags
  %49:gr64 = IMUL64rr %43:gr64(tied-def 0), killed %64:gr64, implicit-def dead $eflags
  %50:gr64 = DEC64r %15:gr64_nosp(tied-def 0), implicit-def dead $eflags
  %67:gr64 = IMUL64rr killed %50:gr64(tied-def 0), %15:gr64_nosp, implicit-def dead $eflags
  %17:gr64 = IMUL64rr %49:gr64(tied-def 0), killed %67:gr64, implicit-def dead $eflags
  %18:gr64 = ADD64ri32 %15:gr64_nosp(tied-def 0), 8, implicit-def dead $eflags
  %52:gr64 = LEA64r %3:gr64, 1, %15:gr64_nosp, 8, $noreg
  CMP64ri32 %52:gr64, 8, implicit-def $eflags
  JCC_1 %bb.3, 4, implicit $eflags
  JMP_1 %bb.8

# End machine code for function main.

# *** IR Dump After X86 Optimize Call Frame (x86-cf-opt) ***:
# Machine code for function main: IsSSA, TracksLiveness
Frame Objects:
  fi#0: size=4, align=4, at location [SP+8]

bb.0 (%ir-block.0):
  successors: %bb.9(0x30000000), %bb.1(0x50000000); %bb.9(37.50%), %bb.1(62.50%)

  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %20:gr64 = LEA64r $rip, 1, $noreg, @.str, $noreg
  %21:gr32 = MOV32r0 implicit-def dead $eflags
  %22:gr8 = COPY %21.sub_8bit:gr32
  %23:gr64 = LEA64r %stack.0, 1, $noreg, 0, $noreg
  $rdi = COPY %20:gr64
  $rsi = COPY %23:gr64
  $al = COPY %22:gr8
  CALL64pcrel32 target-flags(x86-plt) @__isoc99_scanf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %25:gr32 = MOV32rm %stack.0, 1, $noreg, 0, $noreg :: (dereferenceable load (s32) from %ir.1, !tbaa !5)
  %0:gr64 = SUBREG_TO_REG 0, killed %25:gr32, %subreg.sub_32bit
  %26:gr32 = COPY %0.sub_32bit:gr64
  TEST32rr %26:gr32, %26:gr32, implicit-def $eflags
  JCC_1 %bb.1, 15, implicit $eflags

bb.9:
; predecessors: %bb.0
  successors: %bb.7(0x80000000); %bb.7(100.00%)

  %19:gr64 = MOV32ri64 1
  JMP_1 %bb.7

bb.1 (%ir-block.6):
; predecessors: %bb.0
  successors: %bb.10(0x40000000), %bb.2(0x40000000); %bb.10(50.00%), %bb.2(50.00%)

  %29:gr64 = DEC64r %0:gr64(tied-def 0), implicit-def dead $eflags
  %30:gr32 = COPY %0.sub_32bit:gr64
  %31:gr32 = AND32ri %30:gr32(tied-def 0), 7, implicit-def dead $eflags
  %2:gr64 = SUBREG_TO_REG 0, killed %31:gr32, %subreg.sub_32bit
  CMP64ri32 %29:gr64, 7, implicit-def $eflags
  JCC_1 %bb.2, 3, implicit $eflags

bb.10:
; predecessors: %bb.1
  successors: %bb.4(0x80000000); %bb.4(100.00%)

  %28:gr64 = MOV32ri64 1
  %27:gr64 = IMPLICIT_DEF
  JMP_1 %bb.4

bb.2 (%ir-block.12):
; predecessors: %bb.1
  successors: %bb.8(0x80000000); %bb.8(100.00%)

  %1:gr64 = COPY %0:gr64
  %35:gr32 = COPY %1.sub_32bit:gr64
  %36:gr32 = AND32ri %35:gr32(tied-def 0), -8, implicit-def dead $eflags
  %37:gr64 = SUBREG_TO_REG 0, killed %36:gr32, %subreg.sub_32bit
  %3:gr64 = NEG64r %37:gr64(tied-def 0), implicit-def dead $eflags
  %34:gr64 = MOV32ri64 1
  %33:gr64 = MOV32ri64 8
  JMP_1 %bb.8

bb.3 (%ir-block.15):
; predecessors: %bb.8
  successors: %bb.4(0x80000000); %bb.4(100.00%)

  %4:gr64 = ADD64ri32 %18:gr64(tied-def 0), -7, implicit-def dead $eflags

bb.4 (%ir-block.17):
; predecessors: %bb.3, %bb.10
  successors: %bb.7(0x30000000), %bb.5(0x50000000); %bb.7(37.50%), %bb.5(62.50%)

  %5:gr64 = PHI %27:gr64, %bb.10, %17:gr64, %bb.3
  %6:gr64 = PHI %28:gr64, %bb.10, %4:gr64, %bb.3
  %7:gr64 = PHI %28:gr64, %bb.10, %17:gr64, %bb.3
  TEST64rr %2:gr64, %2:gr64, implicit-def $eflags
  JCC_1 %bb.7, 4, implicit $eflags
  JMP_1 %bb.5

bb.5 (%ir-block.22):
; predecessors: %bb.4
  successors: %bb.6(0x80000000); %bb.6(100.00%)


bb.6 (%ir-block.23):
; predecessors: %bb.5, %bb.6
  successors: %bb.7(0x04000000), %bb.6(0x7c000000); %bb.7(3.12%), %bb.6(96.88%)

  %8:gr64 = PHI %2:gr64, %bb.5, %13:gr64, %bb.6
  %9:gr64 = PHI %6:gr64, %bb.5, %12:gr64, %bb.6
  %10:gr64 = PHI %7:gr64, %bb.5, %11:gr64, %bb.6
  %11:gr64 = IMUL64rr %10:gr64(tied-def 0), %9:gr64, implicit-def dead $eflags
  %12:gr64 = nuw nsw INC64r %9:gr64(tied-def 0), implicit-def dead $eflags
  %13:gr64 = DEC64r %8:gr64(tied-def 0), implicit-def $eflags
  JCC_1 %bb.6, 5, implicit $eflags
  JMP_1 %bb.7

bb.7 (%ir-block.31):
; predecessors: %bb.4, %bb.6, %bb.9

  %14:gr64 = PHI %19:gr64, %bb.9, %5:gr64, %bb.4, %11:gr64, %bb.6
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %54:gr64 = LEA64r $rip, 1, $noreg, @.str.1, $noreg
  %55:gr32 = MOV32r0 implicit-def dead $eflags
  %56:gr8 = COPY %55.sub_8bit:gr32
  $rdi = COPY %54:gr64
  $rsi = COPY %14:gr64
  $al = COPY %56:gr8
  CALL64pcrel32 target-flags(x86-plt) @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $eax = MOV32r0 implicit-def dead $eflags
  RET 0, $eax

bb.8 (%ir-block.34):
; predecessors: %bb.2, %bb.8
  successors: %bb.3(0x04000000), %bb.8(0x7c000000); %bb.3(3.12%), %bb.8(96.88%)

  %15:gr64_nosp = PHI %33:gr64, %bb.2, %18:gr64, %bb.8
  %16:gr64 = PHI %34:gr64, %bb.2, %17:gr64, %bb.8
  %38:gr64 = ADD64ri32 %15:gr64_nosp(tied-def 0), -7, implicit-def dead $eflags
  %39:gr64 = IMUL64rr %16:gr64(tied-def 0), killed %38:gr64, implicit-def dead $eflags
  %40:gr64 = ADD64ri32 %15:gr64_nosp(tied-def 0), -6, implicit-def dead $eflags
  %42:gr64 = ADD64ri32 %15:gr64_nosp(tied-def 0), -5, implicit-def dead $eflags
  %60:gr64 = IMUL64rr killed %40:gr64(tied-def 0), killed %42:gr64, implicit-def dead $eflags
  %43:gr64 = IMUL64rr %39:gr64(tied-def 0), killed %60:gr64, implicit-def dead $eflags
  %44:gr64 = ADD64ri32 %15:gr64_nosp(tied-def 0), -4, implicit-def dead $eflags
  %46:gr64 = ADD64ri32 %15:gr64_nosp(tied-def 0), -3, implicit-def dead $eflags
  %63:gr64 = IMUL64rr killed %44:gr64(tied-def 0), killed %46:gr64, implicit-def dead $eflags
  %48:gr64 = ADD64ri32 %15:gr64_nosp(tied-def 0), -2, implicit-def dead $eflags
  %64:gr64 = IMUL64rr killed %63:gr64(tied-def 0), killed %48:gr64, implicit-def dead $eflags
  %49:gr64 = IMUL64rr %43:gr64(tied-def 0), killed %64:gr64, implicit-def dead $eflags
  %50:gr64 = DEC64r %15:gr64_nosp(tied-def 0), implicit-def dead $eflags
  %67:gr64 = IMUL64rr killed %50:gr64(tied-def 0), %15:gr64_nosp, implicit-def dead $eflags
  %17:gr64 = IMUL64rr %49:gr64(tied-def 0), killed %67:gr64, implicit-def dead $eflags
  %18:gr64 = ADD64ri32 %15:gr64_nosp(tied-def 0), 8, implicit-def dead $eflags
  %52:gr64 = LEA64r %3:gr64, 1, %15:gr64_nosp, 8, $noreg
  CMP64ri32 %52:gr64, 8, implicit-def $eflags
  JCC_1 %bb.3, 4, implicit $eflags
  JMP_1 %bb.8

# End machine code for function main.

# *** IR Dump After X86 Avoid Store Forwarding Blocks (x86-avoid-SFB) ***:
# Machine code for function main: IsSSA, TracksLiveness
Frame Objects:
  fi#0: size=4, align=4, at location [SP+8]

bb.0 (%ir-block.0):
  successors: %bb.9(0x30000000), %bb.1(0x50000000); %bb.9(37.50%), %bb.1(62.50%)

  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %20:gr64 = LEA64r $rip, 1, $noreg, @.str, $noreg
  %21:gr32 = MOV32r0 implicit-def dead $eflags
  %22:gr8 = COPY %21.sub_8bit:gr32
  %23:gr64 = LEA64r %stack.0, 1, $noreg, 0, $noreg
  $rdi = COPY %20:gr64
  $rsi = COPY %23:gr64
  $al = COPY %22:gr8
  CALL64pcrel32 target-flags(x86-plt) @__isoc99_scanf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %25:gr32 = MOV32rm %stack.0, 1, $noreg, 0, $noreg :: (dereferenceable load (s32) from %ir.1, !tbaa !5)
  %0:gr64 = SUBREG_TO_REG 0, killed %25:gr32, %subreg.sub_32bit
  %26:gr32 = COPY %0.sub_32bit:gr64
  TEST32rr %26:gr32, %26:gr32, implicit-def $eflags
  JCC_1 %bb.1, 15, implicit $eflags

bb.9:
; predecessors: %bb.0
  successors: %bb.7(0x80000000); %bb.7(100.00%)

  %19:gr64 = MOV32ri64 1
  JMP_1 %bb.7

bb.1 (%ir-block.6):
; predecessors: %bb.0
  successors: %bb.10(0x40000000), %bb.2(0x40000000); %bb.10(50.00%), %bb.2(50.00%)

  %29:gr64 = DEC64r %0:gr64(tied-def 0), implicit-def dead $eflags
  %30:gr32 = COPY %0.sub_32bit:gr64
  %31:gr32 = AND32ri %30:gr32(tied-def 0), 7, implicit-def dead $eflags
  %2:gr64 = SUBREG_TO_REG 0, killed %31:gr32, %subreg.sub_32bit
  CMP64ri32 %29:gr64, 7, implicit-def $eflags
  JCC_1 %bb.2, 3, implicit $eflags

bb.10:
; predecessors: %bb.1
  successors: %bb.4(0x80000000); %bb.4(100.00%)

  %28:gr64 = MOV32ri64 1
  %27:gr64 = IMPLICIT_DEF
  JMP_1 %bb.4

bb.2 (%ir-block.12):
; predecessors: %bb.1
  successors: %bb.8(0x80000000); %bb.8(100.00%)

  %1:gr64 = COPY %0:gr64
  %35:gr32 = COPY %1.sub_32bit:gr64
  %36:gr32 = AND32ri %35:gr32(tied-def 0), -8, implicit-def dead $eflags
  %37:gr64 = SUBREG_TO_REG 0, killed %36:gr32, %subreg.sub_32bit
  %3:gr64 = NEG64r %37:gr64(tied-def 0), implicit-def dead $eflags
  %34:gr64 = MOV32ri64 1
  %33:gr64 = MOV32ri64 8
  JMP_1 %bb.8

bb.3 (%ir-block.15):
; predecessors: %bb.8
  successors: %bb.4(0x80000000); %bb.4(100.00%)

  %4:gr64 = ADD64ri32 %18:gr64(tied-def 0), -7, implicit-def dead $eflags

bb.4 (%ir-block.17):
; predecessors: %bb.3, %bb.10
  successors: %bb.7(0x30000000), %bb.5(0x50000000); %bb.7(37.50%), %bb.5(62.50%)

  %5:gr64 = PHI %27:gr64, %bb.10, %17:gr64, %bb.3
  %6:gr64 = PHI %28:gr64, %bb.10, %4:gr64, %bb.3
  %7:gr64 = PHI %28:gr64, %bb.10, %17:gr64, %bb.3
  TEST64rr %2:gr64, %2:gr64, implicit-def $eflags
  JCC_1 %bb.7, 4, implicit $eflags
  JMP_1 %bb.5

bb.5 (%ir-block.22):
; predecessors: %bb.4
  successors: %bb.6(0x80000000); %bb.6(100.00%)


bb.6 (%ir-block.23):
; predecessors: %bb.5, %bb.6
  successors: %bb.7(0x04000000), %bb.6(0x7c000000); %bb.7(3.12%), %bb.6(96.88%)

  %8:gr64 = PHI %2:gr64, %bb.5, %13:gr64, %bb.6
  %9:gr64 = PHI %6:gr64, %bb.5, %12:gr64, %bb.6
  %10:gr64 = PHI %7:gr64, %bb.5, %11:gr64, %bb.6
  %11:gr64 = IMUL64rr %10:gr64(tied-def 0), %9:gr64, implicit-def dead $eflags
  %12:gr64 = nuw nsw INC64r %9:gr64(tied-def 0), implicit-def dead $eflags
  %13:gr64 = DEC64r %8:gr64(tied-def 0), implicit-def $eflags
  JCC_1 %bb.6, 5, implicit $eflags
  JMP_1 %bb.7

bb.7 (%ir-block.31):
; predecessors: %bb.4, %bb.6, %bb.9

  %14:gr64 = PHI %19:gr64, %bb.9, %5:gr64, %bb.4, %11:gr64, %bb.6
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %54:gr64 = LEA64r $rip, 1, $noreg, @.str.1, $noreg
  %55:gr32 = MOV32r0 implicit-def dead $eflags
  %56:gr8 = COPY %55.sub_8bit:gr32
  $rdi = COPY %54:gr64
  $rsi = COPY %14:gr64
  $al = COPY %56:gr8
  CALL64pcrel32 target-flags(x86-plt) @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $eax = MOV32r0 implicit-def dead $eflags
  RET 0, $eax

bb.8 (%ir-block.34):
; predecessors: %bb.2, %bb.8
  successors: %bb.3(0x04000000), %bb.8(0x7c000000); %bb.3(3.12%), %bb.8(96.88%)

  %15:gr64_nosp = PHI %33:gr64, %bb.2, %18:gr64, %bb.8
  %16:gr64 = PHI %34:gr64, %bb.2, %17:gr64, %bb.8
  %38:gr64 = ADD64ri32 %15:gr64_nosp(tied-def 0), -7, implicit-def dead $eflags
  %39:gr64 = IMUL64rr %16:gr64(tied-def 0), killed %38:gr64, implicit-def dead $eflags
  %40:gr64 = ADD64ri32 %15:gr64_nosp(tied-def 0), -6, implicit-def dead $eflags
  %42:gr64 = ADD64ri32 %15:gr64_nosp(tied-def 0), -5, implicit-def dead $eflags
  %60:gr64 = IMUL64rr killed %40:gr64(tied-def 0), killed %42:gr64, implicit-def dead $eflags
  %43:gr64 = IMUL64rr %39:gr64(tied-def 0), killed %60:gr64, implicit-def dead $eflags
  %44:gr64 = ADD64ri32 %15:gr64_nosp(tied-def 0), -4, implicit-def dead $eflags
  %46:gr64 = ADD64ri32 %15:gr64_nosp(tied-def 0), -3, implicit-def dead $eflags
  %63:gr64 = IMUL64rr killed %44:gr64(tied-def 0), killed %46:gr64, implicit-def dead $eflags
  %48:gr64 = ADD64ri32 %15:gr64_nosp(tied-def 0), -2, implicit-def dead $eflags
  %64:gr64 = IMUL64rr killed %63:gr64(tied-def 0), killed %48:gr64, implicit-def dead $eflags
  %49:gr64 = IMUL64rr %43:gr64(tied-def 0), killed %64:gr64, implicit-def dead $eflags
  %50:gr64 = DEC64r %15:gr64_nosp(tied-def 0), implicit-def dead $eflags
  %67:gr64 = IMUL64rr killed %50:gr64(tied-def 0), %15:gr64_nosp, implicit-def dead $eflags
  %17:gr64 = IMUL64rr %49:gr64(tied-def 0), killed %67:gr64, implicit-def dead $eflags
  %18:gr64 = ADD64ri32 %15:gr64_nosp(tied-def 0), 8, implicit-def dead $eflags
  %52:gr64 = LEA64r %3:gr64, 1, %15:gr64_nosp, 8, $noreg
  CMP64ri32 %52:gr64, 8, implicit-def $eflags
  JCC_1 %bb.3, 4, implicit $eflags
  JMP_1 %bb.8

# End machine code for function main.

# *** IR Dump After X86 speculative load hardening (x86-slh) ***:
# Machine code for function main: IsSSA, TracksLiveness
Frame Objects:
  fi#0: size=4, align=4, at location [SP+8]

bb.0 (%ir-block.0):
  successors: %bb.9(0x30000000), %bb.1(0x50000000); %bb.9(37.50%), %bb.1(62.50%)

  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %20:gr64 = LEA64r $rip, 1, $noreg, @.str, $noreg
  %21:gr32 = MOV32r0 implicit-def dead $eflags
  %22:gr8 = COPY %21.sub_8bit:gr32
  %23:gr64 = LEA64r %stack.0, 1, $noreg, 0, $noreg
  $rdi = COPY %20:gr64
  $rsi = COPY %23:gr64
  $al = COPY %22:gr8
  CALL64pcrel32 target-flags(x86-plt) @__isoc99_scanf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %25:gr32 = MOV32rm %stack.0, 1, $noreg, 0, $noreg :: (dereferenceable load (s32) from %ir.1, !tbaa !5)
  %0:gr64 = SUBREG_TO_REG 0, killed %25:gr32, %subreg.sub_32bit
  %26:gr32 = COPY %0.sub_32bit:gr64
  TEST32rr %26:gr32, %26:gr32, implicit-def $eflags
  JCC_1 %bb.1, 15, implicit $eflags

bb.9:
; predecessors: %bb.0
  successors: %bb.7(0x80000000); %bb.7(100.00%)

  %19:gr64 = MOV32ri64 1
  JMP_1 %bb.7

bb.1 (%ir-block.6):
; predecessors: %bb.0
  successors: %bb.10(0x40000000), %bb.2(0x40000000); %bb.10(50.00%), %bb.2(50.00%)

  %29:gr64 = DEC64r %0:gr64(tied-def 0), implicit-def dead $eflags
  %30:gr32 = COPY %0.sub_32bit:gr64
  %31:gr32 = AND32ri %30:gr32(tied-def 0), 7, implicit-def dead $eflags
  %2:gr64 = SUBREG_TO_REG 0, killed %31:gr32, %subreg.sub_32bit
  CMP64ri32 %29:gr64, 7, implicit-def $eflags
  JCC_1 %bb.2, 3, implicit $eflags

bb.10:
; predecessors: %bb.1
  successors: %bb.4(0x80000000); %bb.4(100.00%)

  %28:gr64 = MOV32ri64 1
  %27:gr64 = IMPLICIT_DEF
  JMP_1 %bb.4

bb.2 (%ir-block.12):
; predecessors: %bb.1
  successors: %bb.8(0x80000000); %bb.8(100.00%)

  %1:gr64 = COPY %0:gr64
  %35:gr32 = COPY %1.sub_32bit:gr64
  %36:gr32 = AND32ri %35:gr32(tied-def 0), -8, implicit-def dead $eflags
  %37:gr64 = SUBREG_TO_REG 0, killed %36:gr32, %subreg.sub_32bit
  %3:gr64 = NEG64r %37:gr64(tied-def 0), implicit-def dead $eflags
  %34:gr64 = MOV32ri64 1
  %33:gr64 = MOV32ri64 8
  JMP_1 %bb.8

bb.3 (%ir-block.15):
; predecessors: %bb.8
  successors: %bb.4(0x80000000); %bb.4(100.00%)

  %4:gr64 = ADD64ri32 %18:gr64(tied-def 0), -7, implicit-def dead $eflags

bb.4 (%ir-block.17):
; predecessors: %bb.3, %bb.10
  successors: %bb.7(0x30000000), %bb.5(0x50000000); %bb.7(37.50%), %bb.5(62.50%)

  %5:gr64 = PHI %27:gr64, %bb.10, %17:gr64, %bb.3
  %6:gr64 = PHI %28:gr64, %bb.10, %4:gr64, %bb.3
  %7:gr64 = PHI %28:gr64, %bb.10, %17:gr64, %bb.3
  TEST64rr %2:gr64, %2:gr64, implicit-def $eflags
  JCC_1 %bb.7, 4, implicit $eflags
  JMP_1 %bb.5

bb.5 (%ir-block.22):
; predecessors: %bb.4
  successors: %bb.6(0x80000000); %bb.6(100.00%)


bb.6 (%ir-block.23):
; predecessors: %bb.5, %bb.6
  successors: %bb.7(0x04000000), %bb.6(0x7c000000); %bb.7(3.12%), %bb.6(96.88%)

  %8:gr64 = PHI %2:gr64, %bb.5, %13:gr64, %bb.6
  %9:gr64 = PHI %6:gr64, %bb.5, %12:gr64, %bb.6
  %10:gr64 = PHI %7:gr64, %bb.5, %11:gr64, %bb.6
  %11:gr64 = IMUL64rr %10:gr64(tied-def 0), %9:gr64, implicit-def dead $eflags
  %12:gr64 = nuw nsw INC64r %9:gr64(tied-def 0), implicit-def dead $eflags
  %13:gr64 = DEC64r %8:gr64(tied-def 0), implicit-def $eflags
  JCC_1 %bb.6, 5, implicit $eflags
  JMP_1 %bb.7

bb.7 (%ir-block.31):
; predecessors: %bb.4, %bb.6, %bb.9

  %14:gr64 = PHI %19:gr64, %bb.9, %5:gr64, %bb.4, %11:gr64, %bb.6
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %54:gr64 = LEA64r $rip, 1, $noreg, @.str.1, $noreg
  %55:gr32 = MOV32r0 implicit-def dead $eflags
  %56:gr8 = COPY %55.sub_8bit:gr32
  $rdi = COPY %54:gr64
  $rsi = COPY %14:gr64
  $al = COPY %56:gr8
  CALL64pcrel32 target-flags(x86-plt) @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $eax = MOV32r0 implicit-def dead $eflags
  RET 0, $eax

bb.8 (%ir-block.34):
; predecessors: %bb.2, %bb.8
  successors: %bb.3(0x04000000), %bb.8(0x7c000000); %bb.3(3.12%), %bb.8(96.88%)

  %15:gr64_nosp = PHI %33:gr64, %bb.2, %18:gr64, %bb.8
  %16:gr64 = PHI %34:gr64, %bb.2, %17:gr64, %bb.8
  %38:gr64 = ADD64ri32 %15:gr64_nosp(tied-def 0), -7, implicit-def dead $eflags
  %39:gr64 = IMUL64rr %16:gr64(tied-def 0), killed %38:gr64, implicit-def dead $eflags
  %40:gr64 = ADD64ri32 %15:gr64_nosp(tied-def 0), -6, implicit-def dead $eflags
  %42:gr64 = ADD64ri32 %15:gr64_nosp(tied-def 0), -5, implicit-def dead $eflags
  %60:gr64 = IMUL64rr killed %40:gr64(tied-def 0), killed %42:gr64, implicit-def dead $eflags
  %43:gr64 = IMUL64rr %39:gr64(tied-def 0), killed %60:gr64, implicit-def dead $eflags
  %44:gr64 = ADD64ri32 %15:gr64_nosp(tied-def 0), -4, implicit-def dead $eflags
  %46:gr64 = ADD64ri32 %15:gr64_nosp(tied-def 0), -3, implicit-def dead $eflags
  %63:gr64 = IMUL64rr killed %44:gr64(tied-def 0), killed %46:gr64, implicit-def dead $eflags
  %48:gr64 = ADD64ri32 %15:gr64_nosp(tied-def 0), -2, implicit-def dead $eflags
  %64:gr64 = IMUL64rr killed %63:gr64(tied-def 0), killed %48:gr64, implicit-def dead $eflags
  %49:gr64 = IMUL64rr %43:gr64(tied-def 0), killed %64:gr64, implicit-def dead $eflags
  %50:gr64 = DEC64r %15:gr64_nosp(tied-def 0), implicit-def dead $eflags
  %67:gr64 = IMUL64rr killed %50:gr64(tied-def 0), %15:gr64_nosp, implicit-def dead $eflags
  %17:gr64 = IMUL64rr %49:gr64(tied-def 0), killed %67:gr64, implicit-def dead $eflags
  %18:gr64 = ADD64ri32 %15:gr64_nosp(tied-def 0), 8, implicit-def dead $eflags
  %52:gr64 = LEA64r %3:gr64, 1, %15:gr64_nosp, 8, $noreg
  CMP64ri32 %52:gr64, 8, implicit-def $eflags
  JCC_1 %bb.3, 4, implicit $eflags
  JMP_1 %bb.8

# End machine code for function main.

# *** IR Dump After X86 EFLAGS copy lowering (x86-flags-copy-lowering) ***:
# Machine code for function main: IsSSA, TracksLiveness
Frame Objects:
  fi#0: size=4, align=4, at location [SP+8]

bb.0 (%ir-block.0):
  successors: %bb.9(0x30000000), %bb.1(0x50000000); %bb.9(37.50%), %bb.1(62.50%)

  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %20:gr64 = LEA64r $rip, 1, $noreg, @.str, $noreg
  %21:gr32 = MOV32r0 implicit-def dead $eflags
  %22:gr8 = COPY %21.sub_8bit:gr32
  %23:gr64 = LEA64r %stack.0, 1, $noreg, 0, $noreg
  $rdi = COPY %20:gr64
  $rsi = COPY %23:gr64
  $al = COPY %22:gr8
  CALL64pcrel32 target-flags(x86-plt) @__isoc99_scanf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %25:gr32 = MOV32rm %stack.0, 1, $noreg, 0, $noreg :: (dereferenceable load (s32) from %ir.1, !tbaa !5)
  %0:gr64 = SUBREG_TO_REG 0, killed %25:gr32, %subreg.sub_32bit
  %26:gr32 = COPY %0.sub_32bit:gr64
  TEST32rr %26:gr32, %26:gr32, implicit-def $eflags
  JCC_1 %bb.1, 15, implicit $eflags

bb.9:
; predecessors: %bb.0
  successors: %bb.7(0x80000000); %bb.7(100.00%)

  %19:gr64 = MOV32ri64 1
  JMP_1 %bb.7

bb.1 (%ir-block.6):
; predecessors: %bb.0
  successors: %bb.10(0x40000000), %bb.2(0x40000000); %bb.10(50.00%), %bb.2(50.00%)

  %29:gr64 = DEC64r %0:gr64(tied-def 0), implicit-def dead $eflags
  %30:gr32 = COPY %0.sub_32bit:gr64
  %31:gr32 = AND32ri %30:gr32(tied-def 0), 7, implicit-def dead $eflags
  %2:gr64 = SUBREG_TO_REG 0, killed %31:gr32, %subreg.sub_32bit
  CMP64ri32 %29:gr64, 7, implicit-def $eflags
  JCC_1 %bb.2, 3, implicit $eflags

bb.10:
; predecessors: %bb.1
  successors: %bb.4(0x80000000); %bb.4(100.00%)

  %28:gr64 = MOV32ri64 1
  %27:gr64 = IMPLICIT_DEF
  JMP_1 %bb.4

bb.2 (%ir-block.12):
; predecessors: %bb.1
  successors: %bb.8(0x80000000); %bb.8(100.00%)

  %1:gr64 = COPY %0:gr64
  %35:gr32 = COPY %1.sub_32bit:gr64
  %36:gr32 = AND32ri %35:gr32(tied-def 0), -8, implicit-def dead $eflags
  %37:gr64 = SUBREG_TO_REG 0, killed %36:gr32, %subreg.sub_32bit
  %3:gr64 = NEG64r %37:gr64(tied-def 0), implicit-def dead $eflags
  %34:gr64 = MOV32ri64 1
  %33:gr64 = MOV32ri64 8
  JMP_1 %bb.8

bb.3 (%ir-block.15):
; predecessors: %bb.8
  successors: %bb.4(0x80000000); %bb.4(100.00%)

  %4:gr64 = ADD64ri32 %18:gr64(tied-def 0), -7, implicit-def dead $eflags

bb.4 (%ir-block.17):
; predecessors: %bb.3, %bb.10
  successors: %bb.7(0x30000000), %bb.5(0x50000000); %bb.7(37.50%), %bb.5(62.50%)

  %5:gr64 = PHI %27:gr64, %bb.10, %17:gr64, %bb.3
  %6:gr64 = PHI %28:gr64, %bb.10, %4:gr64, %bb.3
  %7:gr64 = PHI %28:gr64, %bb.10, %17:gr64, %bb.3
  TEST64rr %2:gr64, %2:gr64, implicit-def $eflags
  JCC_1 %bb.7, 4, implicit $eflags
  JMP_1 %bb.5

bb.5 (%ir-block.22):
; predecessors: %bb.4
  successors: %bb.6(0x80000000); %bb.6(100.00%)


bb.6 (%ir-block.23):
; predecessors: %bb.5, %bb.6
  successors: %bb.7(0x04000000), %bb.6(0x7c000000); %bb.7(3.12%), %bb.6(96.88%)

  %8:gr64 = PHI %2:gr64, %bb.5, %13:gr64, %bb.6
  %9:gr64 = PHI %6:gr64, %bb.5, %12:gr64, %bb.6
  %10:gr64 = PHI %7:gr64, %bb.5, %11:gr64, %bb.6
  %11:gr64 = IMUL64rr %10:gr64(tied-def 0), %9:gr64, implicit-def dead $eflags
  %12:gr64 = nuw nsw INC64r %9:gr64(tied-def 0), implicit-def dead $eflags
  %13:gr64 = DEC64r %8:gr64(tied-def 0), implicit-def $eflags
  JCC_1 %bb.6, 5, implicit $eflags
  JMP_1 %bb.7

bb.7 (%ir-block.31):
; predecessors: %bb.4, %bb.6, %bb.9

  %14:gr64 = PHI %19:gr64, %bb.9, %5:gr64, %bb.4, %11:gr64, %bb.6
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %54:gr64 = LEA64r $rip, 1, $noreg, @.str.1, $noreg
  %55:gr32 = MOV32r0 implicit-def dead $eflags
  %56:gr8 = COPY %55.sub_8bit:gr32
  $rdi = COPY %54:gr64
  $rsi = COPY %14:gr64
  $al = COPY %56:gr8
  CALL64pcrel32 target-flags(x86-plt) @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $eax = MOV32r0 implicit-def dead $eflags
  RET 0, $eax

bb.8 (%ir-block.34):
; predecessors: %bb.2, %bb.8
  successors: %bb.3(0x04000000), %bb.8(0x7c000000); %bb.3(3.12%), %bb.8(96.88%)

  %15:gr64_nosp = PHI %33:gr64, %bb.2, %18:gr64, %bb.8
  %16:gr64 = PHI %34:gr64, %bb.2, %17:gr64, %bb.8
  %38:gr64 = ADD64ri32 %15:gr64_nosp(tied-def 0), -7, implicit-def dead $eflags
  %39:gr64 = IMUL64rr %16:gr64(tied-def 0), killed %38:gr64, implicit-def dead $eflags
  %40:gr64 = ADD64ri32 %15:gr64_nosp(tied-def 0), -6, implicit-def dead $eflags
  %42:gr64 = ADD64ri32 %15:gr64_nosp(tied-def 0), -5, implicit-def dead $eflags
  %60:gr64 = IMUL64rr killed %40:gr64(tied-def 0), killed %42:gr64, implicit-def dead $eflags
  %43:gr64 = IMUL64rr %39:gr64(tied-def 0), killed %60:gr64, implicit-def dead $eflags
  %44:gr64 = ADD64ri32 %15:gr64_nosp(tied-def 0), -4, implicit-def dead $eflags
  %46:gr64 = ADD64ri32 %15:gr64_nosp(tied-def 0), -3, implicit-def dead $eflags
  %63:gr64 = IMUL64rr killed %44:gr64(tied-def 0), killed %46:gr64, implicit-def dead $eflags
  %48:gr64 = ADD64ri32 %15:gr64_nosp(tied-def 0), -2, implicit-def dead $eflags
  %64:gr64 = IMUL64rr killed %63:gr64(tied-def 0), killed %48:gr64, implicit-def dead $eflags
  %49:gr64 = IMUL64rr %43:gr64(tied-def 0), killed %64:gr64, implicit-def dead $eflags
  %50:gr64 = DEC64r %15:gr64_nosp(tied-def 0), implicit-def dead $eflags
  %67:gr64 = IMUL64rr killed %50:gr64(tied-def 0), %15:gr64_nosp, implicit-def dead $eflags
  %17:gr64 = IMUL64rr %49:gr64(tied-def 0), killed %67:gr64, implicit-def dead $eflags
  %18:gr64 = ADD64ri32 %15:gr64_nosp(tied-def 0), 8, implicit-def dead $eflags
  %52:gr64 = LEA64r %3:gr64, 1, %15:gr64_nosp, 8, $noreg
  CMP64ri32 %52:gr64, 8, implicit-def $eflags
  JCC_1 %bb.3, 4, implicit $eflags
  JMP_1 %bb.8

# End machine code for function main.

# *** IR Dump After Tile Register Pre-configure (tilepreconfig) ***:
# Machine code for function main: IsSSA, TracksLiveness
Frame Objects:
  fi#0: size=4, align=4, at location [SP+8]

bb.0 (%ir-block.0):
  successors: %bb.9(0x30000000), %bb.1(0x50000000); %bb.9(37.50%), %bb.1(62.50%)

  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %20:gr64 = LEA64r $rip, 1, $noreg, @.str, $noreg
  %21:gr32 = MOV32r0 implicit-def dead $eflags
  %22:gr8 = COPY %21.sub_8bit:gr32
  %23:gr64 = LEA64r %stack.0, 1, $noreg, 0, $noreg
  $rdi = COPY %20:gr64
  $rsi = COPY %23:gr64
  $al = COPY %22:gr8
  CALL64pcrel32 target-flags(x86-plt) @__isoc99_scanf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %25:gr32 = MOV32rm %stack.0, 1, $noreg, 0, $noreg :: (dereferenceable load (s32) from %ir.1, !tbaa !5)
  %0:gr64 = SUBREG_TO_REG 0, killed %25:gr32, %subreg.sub_32bit
  %26:gr32 = COPY %0.sub_32bit:gr64
  TEST32rr %26:gr32, %26:gr32, implicit-def $eflags
  JCC_1 %bb.1, 15, implicit $eflags

bb.9:
; predecessors: %bb.0
  successors: %bb.7(0x80000000); %bb.7(100.00%)

  %19:gr64 = MOV32ri64 1
  JMP_1 %bb.7

bb.1 (%ir-block.6):
; predecessors: %bb.0
  successors: %bb.10(0x40000000), %bb.2(0x40000000); %bb.10(50.00%), %bb.2(50.00%)

  %29:gr64 = DEC64r %0:gr64(tied-def 0), implicit-def dead $eflags
  %30:gr32 = COPY %0.sub_32bit:gr64
  %31:gr32 = AND32ri %30:gr32(tied-def 0), 7, implicit-def dead $eflags
  %2:gr64 = SUBREG_TO_REG 0, killed %31:gr32, %subreg.sub_32bit
  CMP64ri32 %29:gr64, 7, implicit-def $eflags
  JCC_1 %bb.2, 3, implicit $eflags

bb.10:
; predecessors: %bb.1
  successors: %bb.4(0x80000000); %bb.4(100.00%)

  %28:gr64 = MOV32ri64 1
  %27:gr64 = IMPLICIT_DEF
  JMP_1 %bb.4

bb.2 (%ir-block.12):
; predecessors: %bb.1
  successors: %bb.8(0x80000000); %bb.8(100.00%)

  %1:gr64 = COPY %0:gr64
  %35:gr32 = COPY %1.sub_32bit:gr64
  %36:gr32 = AND32ri %35:gr32(tied-def 0), -8, implicit-def dead $eflags
  %37:gr64 = SUBREG_TO_REG 0, killed %36:gr32, %subreg.sub_32bit
  %3:gr64 = NEG64r %37:gr64(tied-def 0), implicit-def dead $eflags
  %34:gr64 = MOV32ri64 1
  %33:gr64 = MOV32ri64 8
  JMP_1 %bb.8

bb.3 (%ir-block.15):
; predecessors: %bb.8
  successors: %bb.4(0x80000000); %bb.4(100.00%)

  %4:gr64 = ADD64ri32 %18:gr64(tied-def 0), -7, implicit-def dead $eflags

bb.4 (%ir-block.17):
; predecessors: %bb.3, %bb.10
  successors: %bb.7(0x30000000), %bb.5(0x50000000); %bb.7(37.50%), %bb.5(62.50%)

  %5:gr64 = PHI %27:gr64, %bb.10, %17:gr64, %bb.3
  %6:gr64 = PHI %28:gr64, %bb.10, %4:gr64, %bb.3
  %7:gr64 = PHI %28:gr64, %bb.10, %17:gr64, %bb.3
  TEST64rr %2:gr64, %2:gr64, implicit-def $eflags
  JCC_1 %bb.7, 4, implicit $eflags
  JMP_1 %bb.5

bb.5 (%ir-block.22):
; predecessors: %bb.4
  successors: %bb.6(0x80000000); %bb.6(100.00%)


bb.6 (%ir-block.23):
; predecessors: %bb.5, %bb.6
  successors: %bb.7(0x04000000), %bb.6(0x7c000000); %bb.7(3.12%), %bb.6(96.88%)

  %8:gr64 = PHI %2:gr64, %bb.5, %13:gr64, %bb.6
  %9:gr64 = PHI %6:gr64, %bb.5, %12:gr64, %bb.6
  %10:gr64 = PHI %7:gr64, %bb.5, %11:gr64, %bb.6
  %11:gr64 = IMUL64rr %10:gr64(tied-def 0), %9:gr64, implicit-def dead $eflags
  %12:gr64 = nuw nsw INC64r %9:gr64(tied-def 0), implicit-def dead $eflags
  %13:gr64 = DEC64r %8:gr64(tied-def 0), implicit-def $eflags
  JCC_1 %bb.6, 5, implicit $eflags
  JMP_1 %bb.7

bb.7 (%ir-block.31):
; predecessors: %bb.4, %bb.6, %bb.9

  %14:gr64 = PHI %19:gr64, %bb.9, %5:gr64, %bb.4, %11:gr64, %bb.6
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %54:gr64 = LEA64r $rip, 1, $noreg, @.str.1, $noreg
  %55:gr32 = MOV32r0 implicit-def dead $eflags
  %56:gr8 = COPY %55.sub_8bit:gr32
  $rdi = COPY %54:gr64
  $rsi = COPY %14:gr64
  $al = COPY %56:gr8
  CALL64pcrel32 target-flags(x86-plt) @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $eax = MOV32r0 implicit-def dead $eflags
  RET 0, $eax

bb.8 (%ir-block.34):
; predecessors: %bb.2, %bb.8
  successors: %bb.3(0x04000000), %bb.8(0x7c000000); %bb.3(3.12%), %bb.8(96.88%)

  %15:gr64_nosp = PHI %33:gr64, %bb.2, %18:gr64, %bb.8
  %16:gr64 = PHI %34:gr64, %bb.2, %17:gr64, %bb.8
  %38:gr64 = ADD64ri32 %15:gr64_nosp(tied-def 0), -7, implicit-def dead $eflags
  %39:gr64 = IMUL64rr %16:gr64(tied-def 0), killed %38:gr64, implicit-def dead $eflags
  %40:gr64 = ADD64ri32 %15:gr64_nosp(tied-def 0), -6, implicit-def dead $eflags
  %42:gr64 = ADD64ri32 %15:gr64_nosp(tied-def 0), -5, implicit-def dead $eflags
  %60:gr64 = IMUL64rr killed %40:gr64(tied-def 0), killed %42:gr64, implicit-def dead $eflags
  %43:gr64 = IMUL64rr %39:gr64(tied-def 0), killed %60:gr64, implicit-def dead $eflags
  %44:gr64 = ADD64ri32 %15:gr64_nosp(tied-def 0), -4, implicit-def dead $eflags
  %46:gr64 = ADD64ri32 %15:gr64_nosp(tied-def 0), -3, implicit-def dead $eflags
  %63:gr64 = IMUL64rr killed %44:gr64(tied-def 0), killed %46:gr64, implicit-def dead $eflags
  %48:gr64 = ADD64ri32 %15:gr64_nosp(tied-def 0), -2, implicit-def dead $eflags
  %64:gr64 = IMUL64rr killed %63:gr64(tied-def 0), killed %48:gr64, implicit-def dead $eflags
  %49:gr64 = IMUL64rr %43:gr64(tied-def 0), killed %64:gr64, implicit-def dead $eflags
  %50:gr64 = DEC64r %15:gr64_nosp(tied-def 0), implicit-def dead $eflags
  %67:gr64 = IMUL64rr killed %50:gr64(tied-def 0), %15:gr64_nosp, implicit-def dead $eflags
  %17:gr64 = IMUL64rr %49:gr64(tied-def 0), killed %67:gr64, implicit-def dead $eflags
  %18:gr64 = ADD64ri32 %15:gr64_nosp(tied-def 0), 8, implicit-def dead $eflags
  %52:gr64 = LEA64r %3:gr64, 1, %15:gr64_nosp, 8, $noreg
  CMP64ri32 %52:gr64, 8, implicit-def $eflags
  JCC_1 %bb.3, 4, implicit $eflags
  JMP_1 %bb.8

# End machine code for function main.

# *** IR Dump After Detect Dead Lanes (detect-dead-lanes) ***:
# Machine code for function main: IsSSA, TracksLiveness
Frame Objects:
  fi#0: size=4, align=4, at location [SP+8]

bb.0 (%ir-block.0):
  successors: %bb.9(0x30000000), %bb.1(0x50000000); %bb.9(37.50%), %bb.1(62.50%)

  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %20:gr64 = LEA64r $rip, 1, $noreg, @.str, $noreg
  %21:gr32 = MOV32r0 implicit-def dead $eflags
  %22:gr8 = COPY %21.sub_8bit:gr32
  %23:gr64 = LEA64r %stack.0, 1, $noreg, 0, $noreg
  $rdi = COPY %20:gr64
  $rsi = COPY %23:gr64
  $al = COPY %22:gr8
  CALL64pcrel32 target-flags(x86-plt) @__isoc99_scanf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %25:gr32 = MOV32rm %stack.0, 1, $noreg, 0, $noreg :: (dereferenceable load (s32) from %ir.1, !tbaa !5)
  %0:gr64 = SUBREG_TO_REG 0, killed %25:gr32, %subreg.sub_32bit
  %26:gr32 = COPY %0.sub_32bit:gr64
  TEST32rr %26:gr32, %26:gr32, implicit-def $eflags
  JCC_1 %bb.1, 15, implicit $eflags

bb.9:
; predecessors: %bb.0
  successors: %bb.7(0x80000000); %bb.7(100.00%)

  %19:gr64 = MOV32ri64 1
  JMP_1 %bb.7

bb.1 (%ir-block.6):
; predecessors: %bb.0
  successors: %bb.10(0x40000000), %bb.2(0x40000000); %bb.10(50.00%), %bb.2(50.00%)

  %29:gr64 = DEC64r %0:gr64(tied-def 0), implicit-def dead $eflags
  %30:gr32 = COPY %0.sub_32bit:gr64
  %31:gr32 = AND32ri %30:gr32(tied-def 0), 7, implicit-def dead $eflags
  %2:gr64 = SUBREG_TO_REG 0, killed %31:gr32, %subreg.sub_32bit
  CMP64ri32 %29:gr64, 7, implicit-def $eflags
  JCC_1 %bb.2, 3, implicit $eflags

bb.10:
; predecessors: %bb.1
  successors: %bb.4(0x80000000); %bb.4(100.00%)

  %28:gr64 = MOV32ri64 1
  %27:gr64 = IMPLICIT_DEF
  JMP_1 %bb.4

bb.2 (%ir-block.12):
; predecessors: %bb.1
  successors: %bb.8(0x80000000); %bb.8(100.00%)

  %1:gr64 = COPY %0:gr64
  %35:gr32 = COPY %1.sub_32bit:gr64
  %36:gr32 = AND32ri %35:gr32(tied-def 0), -8, implicit-def dead $eflags
  %37:gr64 = SUBREG_TO_REG 0, killed %36:gr32, %subreg.sub_32bit
  %3:gr64 = NEG64r %37:gr64(tied-def 0), implicit-def dead $eflags
  %34:gr64 = MOV32ri64 1
  %33:gr64 = MOV32ri64 8
  JMP_1 %bb.8

bb.3 (%ir-block.15):
; predecessors: %bb.8
  successors: %bb.4(0x80000000); %bb.4(100.00%)

  %4:gr64 = ADD64ri32 %18:gr64(tied-def 0), -7, implicit-def dead $eflags

bb.4 (%ir-block.17):
; predecessors: %bb.3, %bb.10
  successors: %bb.7(0x30000000), %bb.5(0x50000000); %bb.7(37.50%), %bb.5(62.50%)

  %5:gr64 = PHI %27:gr64, %bb.10, %17:gr64, %bb.3
  %6:gr64 = PHI %28:gr64, %bb.10, %4:gr64, %bb.3
  %7:gr64 = PHI %28:gr64, %bb.10, %17:gr64, %bb.3
  TEST64rr %2:gr64, %2:gr64, implicit-def $eflags
  JCC_1 %bb.7, 4, implicit $eflags
  JMP_1 %bb.5

bb.5 (%ir-block.22):
; predecessors: %bb.4
  successors: %bb.6(0x80000000); %bb.6(100.00%)


bb.6 (%ir-block.23):
; predecessors: %bb.5, %bb.6
  successors: %bb.7(0x04000000), %bb.6(0x7c000000); %bb.7(3.12%), %bb.6(96.88%)

  %8:gr64 = PHI %2:gr64, %bb.5, %13:gr64, %bb.6
  %9:gr64 = PHI %6:gr64, %bb.5, %12:gr64, %bb.6
  %10:gr64 = PHI %7:gr64, %bb.5, %11:gr64, %bb.6
  %11:gr64 = IMUL64rr %10:gr64(tied-def 0), %9:gr64, implicit-def dead $eflags
  %12:gr64 = nuw nsw INC64r %9:gr64(tied-def 0), implicit-def dead $eflags
  %13:gr64 = DEC64r %8:gr64(tied-def 0), implicit-def $eflags
  JCC_1 %bb.6, 5, implicit $eflags
  JMP_1 %bb.7

bb.7 (%ir-block.31):
; predecessors: %bb.4, %bb.6, %bb.9

  %14:gr64 = PHI %19:gr64, %bb.9, %5:gr64, %bb.4, %11:gr64, %bb.6
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %54:gr64 = LEA64r $rip, 1, $noreg, @.str.1, $noreg
  %55:gr32 = MOV32r0 implicit-def dead $eflags
  %56:gr8 = COPY %55.sub_8bit:gr32
  $rdi = COPY %54:gr64
  $rsi = COPY %14:gr64
  $al = COPY %56:gr8
  CALL64pcrel32 target-flags(x86-plt) @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $eax = MOV32r0 implicit-def dead $eflags
  RET 0, $eax

bb.8 (%ir-block.34):
; predecessors: %bb.2, %bb.8
  successors: %bb.3(0x04000000), %bb.8(0x7c000000); %bb.3(3.12%), %bb.8(96.88%)

  %15:gr64_nosp = PHI %33:gr64, %bb.2, %18:gr64, %bb.8
  %16:gr64 = PHI %34:gr64, %bb.2, %17:gr64, %bb.8
  %38:gr64 = ADD64ri32 %15:gr64_nosp(tied-def 0), -7, implicit-def dead $eflags
  %39:gr64 = IMUL64rr %16:gr64(tied-def 0), killed %38:gr64, implicit-def dead $eflags
  %40:gr64 = ADD64ri32 %15:gr64_nosp(tied-def 0), -6, implicit-def dead $eflags
  %42:gr64 = ADD64ri32 %15:gr64_nosp(tied-def 0), -5, implicit-def dead $eflags
  %60:gr64 = IMUL64rr killed %40:gr64(tied-def 0), killed %42:gr64, implicit-def dead $eflags
  %43:gr64 = IMUL64rr %39:gr64(tied-def 0), killed %60:gr64, implicit-def dead $eflags
  %44:gr64 = ADD64ri32 %15:gr64_nosp(tied-def 0), -4, implicit-def dead $eflags
  %46:gr64 = ADD64ri32 %15:gr64_nosp(tied-def 0), -3, implicit-def dead $eflags
  %63:gr64 = IMUL64rr killed %44:gr64(tied-def 0), killed %46:gr64, implicit-def dead $eflags
  %48:gr64 = ADD64ri32 %15:gr64_nosp(tied-def 0), -2, implicit-def dead $eflags
  %64:gr64 = IMUL64rr killed %63:gr64(tied-def 0), killed %48:gr64, implicit-def dead $eflags
  %49:gr64 = IMUL64rr %43:gr64(tied-def 0), killed %64:gr64, implicit-def dead $eflags
  %50:gr64 = DEC64r %15:gr64_nosp(tied-def 0), implicit-def dead $eflags
  %67:gr64 = IMUL64rr killed %50:gr64(tied-def 0), %15:gr64_nosp, implicit-def dead $eflags
  %17:gr64 = IMUL64rr %49:gr64(tied-def 0), killed %67:gr64, implicit-def dead $eflags
  %18:gr64 = ADD64ri32 %15:gr64_nosp(tied-def 0), 8, implicit-def dead $eflags
  %52:gr64 = LEA64r %3:gr64, 1, %15:gr64_nosp, 8, $noreg
  CMP64ri32 %52:gr64, 8, implicit-def $eflags
  JCC_1 %bb.3, 4, implicit $eflags
  JMP_1 %bb.8

# End machine code for function main.

# *** IR Dump After Process Implicit Definitions (processimpdefs) ***:
# Machine code for function main: IsSSA, TracksLiveness
Frame Objects:
  fi#0: size=4, align=4, at location [SP+8]

bb.0 (%ir-block.0):
  successors: %bb.9(0x30000000), %bb.1(0x50000000); %bb.9(37.50%), %bb.1(62.50%)

  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %20:gr64 = LEA64r $rip, 1, $noreg, @.str, $noreg
  %21:gr32 = MOV32r0 implicit-def dead $eflags
  %22:gr8 = COPY %21.sub_8bit:gr32
  %23:gr64 = LEA64r %stack.0, 1, $noreg, 0, $noreg
  $rdi = COPY %20:gr64
  $rsi = COPY %23:gr64
  $al = COPY %22:gr8
  CALL64pcrel32 target-flags(x86-plt) @__isoc99_scanf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %25:gr32 = MOV32rm %stack.0, 1, $noreg, 0, $noreg :: (dereferenceable load (s32) from %ir.1, !tbaa !5)
  %0:gr64 = SUBREG_TO_REG 0, killed %25:gr32, %subreg.sub_32bit
  %26:gr32 = COPY %0.sub_32bit:gr64
  TEST32rr %26:gr32, %26:gr32, implicit-def $eflags
  JCC_1 %bb.1, 15, implicit $eflags

bb.9:
; predecessors: %bb.0
  successors: %bb.7(0x80000000); %bb.7(100.00%)

  %19:gr64 = MOV32ri64 1
  JMP_1 %bb.7

bb.1 (%ir-block.6):
; predecessors: %bb.0
  successors: %bb.10(0x40000000), %bb.2(0x40000000); %bb.10(50.00%), %bb.2(50.00%)

  %29:gr64 = DEC64r %0:gr64(tied-def 0), implicit-def dead $eflags
  %30:gr32 = COPY %0.sub_32bit:gr64
  %31:gr32 = AND32ri %30:gr32(tied-def 0), 7, implicit-def dead $eflags
  %2:gr64 = SUBREG_TO_REG 0, killed %31:gr32, %subreg.sub_32bit
  CMP64ri32 %29:gr64, 7, implicit-def $eflags
  JCC_1 %bb.2, 3, implicit $eflags

bb.10:
; predecessors: %bb.1
  successors: %bb.4(0x80000000); %bb.4(100.00%)

  %28:gr64 = MOV32ri64 1
  JMP_1 %bb.4

bb.2 (%ir-block.12):
; predecessors: %bb.1
  successors: %bb.8(0x80000000); %bb.8(100.00%)

  %1:gr64 = COPY %0:gr64
  %35:gr32 = COPY %1.sub_32bit:gr64
  %36:gr32 = AND32ri %35:gr32(tied-def 0), -8, implicit-def dead $eflags
  %37:gr64 = SUBREG_TO_REG 0, killed %36:gr32, %subreg.sub_32bit
  %3:gr64 = NEG64r %37:gr64(tied-def 0), implicit-def dead $eflags
  %34:gr64 = MOV32ri64 1
  %33:gr64 = MOV32ri64 8
  JMP_1 %bb.8

bb.3 (%ir-block.15):
; predecessors: %bb.8
  successors: %bb.4(0x80000000); %bb.4(100.00%)

  %4:gr64 = ADD64ri32 %18:gr64(tied-def 0), -7, implicit-def dead $eflags

bb.4 (%ir-block.17):
; predecessors: %bb.3, %bb.10
  successors: %bb.7(0x30000000), %bb.5(0x50000000); %bb.7(37.50%), %bb.5(62.50%)

  %5:gr64 = PHI undef %27:gr64, %bb.10, %17:gr64, %bb.3
  %6:gr64 = PHI %28:gr64, %bb.10, %4:gr64, %bb.3
  %7:gr64 = PHI %28:gr64, %bb.10, %17:gr64, %bb.3
  TEST64rr %2:gr64, %2:gr64, implicit-def $eflags
  JCC_1 %bb.7, 4, implicit $eflags
  JMP_1 %bb.5

bb.5 (%ir-block.22):
; predecessors: %bb.4
  successors: %bb.6(0x80000000); %bb.6(100.00%)


bb.6 (%ir-block.23):
; predecessors: %bb.5, %bb.6
  successors: %bb.7(0x04000000), %bb.6(0x7c000000); %bb.7(3.12%), %bb.6(96.88%)

  %8:gr64 = PHI %2:gr64, %bb.5, %13:gr64, %bb.6
  %9:gr64 = PHI %6:gr64, %bb.5, %12:gr64, %bb.6
  %10:gr64 = PHI %7:gr64, %bb.5, %11:gr64, %bb.6
  %11:gr64 = IMUL64rr %10:gr64(tied-def 0), %9:gr64, implicit-def dead $eflags
  %12:gr64 = nuw nsw INC64r %9:gr64(tied-def 0), implicit-def dead $eflags
  %13:gr64 = DEC64r %8:gr64(tied-def 0), implicit-def $eflags
  JCC_1 %bb.6, 5, implicit $eflags
  JMP_1 %bb.7

bb.7 (%ir-block.31):
; predecessors: %bb.4, %bb.6, %bb.9

  %14:gr64 = PHI %19:gr64, %bb.9, %5:gr64, %bb.4, %11:gr64, %bb.6
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %54:gr64 = LEA64r $rip, 1, $noreg, @.str.1, $noreg
  %55:gr32 = MOV32r0 implicit-def dead $eflags
  %56:gr8 = COPY %55.sub_8bit:gr32
  $rdi = COPY %54:gr64
  $rsi = COPY %14:gr64
  $al = COPY %56:gr8
  CALL64pcrel32 target-flags(x86-plt) @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $eax = MOV32r0 implicit-def dead $eflags
  RET 0, $eax

bb.8 (%ir-block.34):
; predecessors: %bb.2, %bb.8
  successors: %bb.3(0x04000000), %bb.8(0x7c000000); %bb.3(3.12%), %bb.8(96.88%)

  %15:gr64_nosp = PHI %33:gr64, %bb.2, %18:gr64, %bb.8
  %16:gr64 = PHI %34:gr64, %bb.2, %17:gr64, %bb.8
  %38:gr64 = ADD64ri32 %15:gr64_nosp(tied-def 0), -7, implicit-def dead $eflags
  %39:gr64 = IMUL64rr %16:gr64(tied-def 0), killed %38:gr64, implicit-def dead $eflags
  %40:gr64 = ADD64ri32 %15:gr64_nosp(tied-def 0), -6, implicit-def dead $eflags
  %42:gr64 = ADD64ri32 %15:gr64_nosp(tied-def 0), -5, implicit-def dead $eflags
  %60:gr64 = IMUL64rr killed %40:gr64(tied-def 0), killed %42:gr64, implicit-def dead $eflags
  %43:gr64 = IMUL64rr %39:gr64(tied-def 0), killed %60:gr64, implicit-def dead $eflags
  %44:gr64 = ADD64ri32 %15:gr64_nosp(tied-def 0), -4, implicit-def dead $eflags
  %46:gr64 = ADD64ri32 %15:gr64_nosp(tied-def 0), -3, implicit-def dead $eflags
  %63:gr64 = IMUL64rr killed %44:gr64(tied-def 0), killed %46:gr64, implicit-def dead $eflags
  %48:gr64 = ADD64ri32 %15:gr64_nosp(tied-def 0), -2, implicit-def dead $eflags
  %64:gr64 = IMUL64rr killed %63:gr64(tied-def 0), killed %48:gr64, implicit-def dead $eflags
  %49:gr64 = IMUL64rr %43:gr64(tied-def 0), killed %64:gr64, implicit-def dead $eflags
  %50:gr64 = DEC64r %15:gr64_nosp(tied-def 0), implicit-def dead $eflags
  %67:gr64 = IMUL64rr killed %50:gr64(tied-def 0), %15:gr64_nosp, implicit-def dead $eflags
  %17:gr64 = IMUL64rr %49:gr64(tied-def 0), killed %67:gr64, implicit-def dead $eflags
  %18:gr64 = ADD64ri32 %15:gr64_nosp(tied-def 0), 8, implicit-def dead $eflags
  %52:gr64 = LEA64r %3:gr64, 1, %15:gr64_nosp, 8, $noreg
  CMP64ri32 %52:gr64, 8, implicit-def $eflags
  JCC_1 %bb.3, 4, implicit $eflags
  JMP_1 %bb.8

# End machine code for function main.

# *** IR Dump After Remove unreachable machine basic blocks (unreachable-mbb-elimination) ***:
# Machine code for function main: IsSSA, TracksLiveness
Frame Objects:
  fi#0: size=4, align=4, at location [SP+8]

bb.0 (%ir-block.0):
  successors: %bb.1(0x30000000), %bb.2(0x50000000); %bb.1(37.50%), %bb.2(62.50%)

  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %20:gr64 = LEA64r $rip, 1, $noreg, @.str, $noreg
  %21:gr32 = MOV32r0 implicit-def dead $eflags
  %22:gr8 = COPY %21.sub_8bit:gr32
  %23:gr64 = LEA64r %stack.0, 1, $noreg, 0, $noreg
  $rdi = COPY %20:gr64
  $rsi = COPY %23:gr64
  $al = COPY %22:gr8
  CALL64pcrel32 target-flags(x86-plt) @__isoc99_scanf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %25:gr32 = MOV32rm %stack.0, 1, $noreg, 0, $noreg :: (dereferenceable load (s32) from %ir.1, !tbaa !5)
  %0:gr64 = SUBREG_TO_REG 0, killed %25:gr32, %subreg.sub_32bit
  %26:gr32 = COPY %0.sub_32bit:gr64
  TEST32rr %26:gr32, %26:gr32, implicit-def $eflags
  JCC_1 %bb.2, 15, implicit $eflags

bb.1:
; predecessors: %bb.0
  successors: %bb.9(0x80000000); %bb.9(100.00%)

  %19:gr64 = MOV32ri64 1
  JMP_1 %bb.9

bb.2 (%ir-block.6):
; predecessors: %bb.0
  successors: %bb.3(0x40000000), %bb.4(0x40000000); %bb.3(50.00%), %bb.4(50.00%)

  %29:gr64 = DEC64r %0:gr64(tied-def 0), implicit-def dead $eflags
  %30:gr32 = COPY %0.sub_32bit:gr64
  %31:gr32 = AND32ri %30:gr32(tied-def 0), 7, implicit-def dead $eflags
  %2:gr64 = SUBREG_TO_REG 0, killed %31:gr32, %subreg.sub_32bit
  CMP64ri32 %29:gr64, 7, implicit-def $eflags
  JCC_1 %bb.4, 3, implicit $eflags

bb.3:
; predecessors: %bb.2
  successors: %bb.6(0x80000000); %bb.6(100.00%)

  %28:gr64 = MOV32ri64 1
  JMP_1 %bb.6

bb.4 (%ir-block.12):
; predecessors: %bb.2
  successors: %bb.10(0x80000000); %bb.10(100.00%)

  %1:gr64 = COPY %0:gr64
  %35:gr32 = COPY %1.sub_32bit:gr64
  %36:gr32 = AND32ri %35:gr32(tied-def 0), -8, implicit-def dead $eflags
  %37:gr64 = SUBREG_TO_REG 0, killed %36:gr32, %subreg.sub_32bit
  %3:gr64 = NEG64r %37:gr64(tied-def 0), implicit-def dead $eflags
  %34:gr64 = MOV32ri64 1
  %33:gr64 = MOV32ri64 8
  JMP_1 %bb.10

bb.5 (%ir-block.15):
; predecessors: %bb.10
  successors: %bb.6(0x80000000); %bb.6(100.00%)

  %4:gr64 = ADD64ri32 %18:gr64(tied-def 0), -7, implicit-def dead $eflags

bb.6 (%ir-block.17):
; predecessors: %bb.5, %bb.3
  successors: %bb.9(0x30000000), %bb.7(0x50000000); %bb.9(37.50%), %bb.7(62.50%)

  %5:gr64 = PHI undef %27:gr64, %bb.3, %17:gr64, %bb.5
  %6:gr64 = PHI %28:gr64, %bb.3, %4:gr64, %bb.5
  %7:gr64 = PHI %28:gr64, %bb.3, %17:gr64, %bb.5
  TEST64rr %2:gr64, %2:gr64, implicit-def $eflags
  JCC_1 %bb.9, 4, implicit $eflags
  JMP_1 %bb.7

bb.7 (%ir-block.22):
; predecessors: %bb.6
  successors: %bb.8(0x80000000); %bb.8(100.00%)


bb.8 (%ir-block.23):
; predecessors: %bb.7, %bb.8
  successors: %bb.9(0x04000000), %bb.8(0x7c000000); %bb.9(3.12%), %bb.8(96.88%)

  %8:gr64 = PHI %2:gr64, %bb.7, %13:gr64, %bb.8
  %9:gr64 = PHI %6:gr64, %bb.7, %12:gr64, %bb.8
  %10:gr64 = PHI %7:gr64, %bb.7, %11:gr64, %bb.8
  %11:gr64 = IMUL64rr %10:gr64(tied-def 0), %9:gr64, implicit-def dead $eflags
  %12:gr64 = nuw nsw INC64r %9:gr64(tied-def 0), implicit-def dead $eflags
  %13:gr64 = DEC64r %8:gr64(tied-def 0), implicit-def $eflags
  JCC_1 %bb.8, 5, implicit $eflags
  JMP_1 %bb.9

bb.9 (%ir-block.31):
; predecessors: %bb.6, %bb.8, %bb.1

  %14:gr64 = PHI %19:gr64, %bb.1, %5:gr64, %bb.6, %11:gr64, %bb.8
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %54:gr64 = LEA64r $rip, 1, $noreg, @.str.1, $noreg
  %55:gr32 = MOV32r0 implicit-def dead $eflags
  %56:gr8 = COPY %55.sub_8bit:gr32
  $rdi = COPY %54:gr64
  $rsi = COPY %14:gr64
  $al = COPY %56:gr8
  CALL64pcrel32 target-flags(x86-plt) @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $eax = MOV32r0 implicit-def dead $eflags
  RET 0, $eax

bb.10 (%ir-block.34):
; predecessors: %bb.4, %bb.10
  successors: %bb.5(0x04000000), %bb.10(0x7c000000); %bb.5(3.12%), %bb.10(96.88%)

  %15:gr64_nosp = PHI %33:gr64, %bb.4, %18:gr64, %bb.10
  %16:gr64 = PHI %34:gr64, %bb.4, %17:gr64, %bb.10
  %38:gr64 = ADD64ri32 %15:gr64_nosp(tied-def 0), -7, implicit-def dead $eflags
  %39:gr64 = IMUL64rr %16:gr64(tied-def 0), killed %38:gr64, implicit-def dead $eflags
  %40:gr64 = ADD64ri32 %15:gr64_nosp(tied-def 0), -6, implicit-def dead $eflags
  %42:gr64 = ADD64ri32 %15:gr64_nosp(tied-def 0), -5, implicit-def dead $eflags
  %60:gr64 = IMUL64rr killed %40:gr64(tied-def 0), killed %42:gr64, implicit-def dead $eflags
  %43:gr64 = IMUL64rr %39:gr64(tied-def 0), killed %60:gr64, implicit-def dead $eflags
  %44:gr64 = ADD64ri32 %15:gr64_nosp(tied-def 0), -4, implicit-def dead $eflags
  %46:gr64 = ADD64ri32 %15:gr64_nosp(tied-def 0), -3, implicit-def dead $eflags
  %63:gr64 = IMUL64rr killed %44:gr64(tied-def 0), killed %46:gr64, implicit-def dead $eflags
  %48:gr64 = ADD64ri32 %15:gr64_nosp(tied-def 0), -2, implicit-def dead $eflags
  %64:gr64 = IMUL64rr killed %63:gr64(tied-def 0), killed %48:gr64, implicit-def dead $eflags
  %49:gr64 = IMUL64rr %43:gr64(tied-def 0), killed %64:gr64, implicit-def dead $eflags
  %50:gr64 = DEC64r %15:gr64_nosp(tied-def 0), implicit-def dead $eflags
  %67:gr64 = IMUL64rr killed %50:gr64(tied-def 0), %15:gr64_nosp, implicit-def dead $eflags
  %17:gr64 = IMUL64rr %49:gr64(tied-def 0), killed %67:gr64, implicit-def dead $eflags
  %18:gr64 = ADD64ri32 %15:gr64_nosp(tied-def 0), 8, implicit-def dead $eflags
  %52:gr64 = LEA64r %3:gr64, 1, %15:gr64_nosp, 8, $noreg
  CMP64ri32 %52:gr64, 8, implicit-def $eflags
  JCC_1 %bb.5, 4, implicit $eflags
  JMP_1 %bb.10

# End machine code for function main.

# *** IR Dump After Live Variable Analysis (livevars) ***:
# Machine code for function main: IsSSA, TracksLiveness
Frame Objects:
  fi#0: size=4, align=4, at location [SP+8]

bb.0 (%ir-block.0):
  successors: %bb.1(0x30000000), %bb.2(0x50000000); %bb.1(37.50%), %bb.2(62.50%)

  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %20:gr64 = LEA64r $rip, 1, $noreg, @.str, $noreg
  %21:gr32 = MOV32r0 implicit-def dead $eflags
  %22:gr8 = COPY killed %21.sub_8bit:gr32
  %23:gr64 = LEA64r %stack.0, 1, $noreg, 0, $noreg
  $rdi = COPY killed %20:gr64
  $rsi = COPY killed %23:gr64
  $al = COPY killed %22:gr8
  CALL64pcrel32 target-flags(x86-plt) @__isoc99_scanf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit killed $rsi, implicit killed $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %25:gr32 = MOV32rm %stack.0, 1, $noreg, 0, $noreg :: (dereferenceable load (s32) from %ir.1, !tbaa !5)
  %0:gr64 = SUBREG_TO_REG 0, killed %25:gr32, %subreg.sub_32bit
  %26:gr32 = COPY %0.sub_32bit:gr64
  TEST32rr killed %26:gr32, %26:gr32, implicit-def $eflags
  JCC_1 %bb.2, 15, implicit killed $eflags

bb.1:
; predecessors: %bb.0
  successors: %bb.9(0x80000000); %bb.9(100.00%)

  %19:gr64 = MOV32ri64 1
  JMP_1 %bb.9

bb.2 (%ir-block.6):
; predecessors: %bb.0
  successors: %bb.3(0x40000000), %bb.4(0x40000000); %bb.3(50.00%), %bb.4(50.00%)

  %29:gr64 = DEC64r %0:gr64(tied-def 0), implicit-def dead $eflags
  %30:gr32 = COPY %0.sub_32bit:gr64
  %31:gr32 = AND32ri killed %30:gr32(tied-def 0), 7, implicit-def dead $eflags
  %2:gr64 = SUBREG_TO_REG 0, killed %31:gr32, %subreg.sub_32bit
  CMP64ri32 killed %29:gr64, 7, implicit-def $eflags
  JCC_1 %bb.4, 3, implicit killed $eflags

bb.3:
; predecessors: %bb.2
  successors: %bb.6(0x80000000); %bb.6(100.00%)

  %28:gr64 = MOV32ri64 1
  JMP_1 %bb.6

bb.4 (%ir-block.12):
; predecessors: %bb.2
  successors: %bb.10(0x80000000); %bb.10(100.00%)

  %1:gr64 = COPY killed %0:gr64
  %35:gr32 = COPY killed %1.sub_32bit:gr64
  %36:gr32 = AND32ri killed %35:gr32(tied-def 0), -8, implicit-def dead $eflags
  %37:gr64 = SUBREG_TO_REG 0, killed %36:gr32, %subreg.sub_32bit
  %3:gr64 = NEG64r killed %37:gr64(tied-def 0), implicit-def dead $eflags
  %34:gr64 = MOV32ri64 1
  %33:gr64 = MOV32ri64 8
  JMP_1 %bb.10

bb.5 (%ir-block.15):
; predecessors: %bb.10
  successors: %bb.6(0x80000000); %bb.6(100.00%)

  %4:gr64 = ADD64ri32 killed %18:gr64(tied-def 0), -7, implicit-def dead $eflags

bb.6 (%ir-block.17):
; predecessors: %bb.5, %bb.3
  successors: %bb.9(0x30000000), %bb.7(0x50000000); %bb.9(37.50%), %bb.7(62.50%)

  %5:gr64 = PHI undef %27:gr64, %bb.3, %17:gr64, %bb.5
  %6:gr64 = PHI %28:gr64, %bb.3, %4:gr64, %bb.5
  %7:gr64 = PHI %28:gr64, %bb.3, %17:gr64, %bb.5
  TEST64rr %2:gr64, %2:gr64, implicit-def $eflags
  JCC_1 %bb.9, 4, implicit killed $eflags
  JMP_1 %bb.7

bb.7 (%ir-block.22):
; predecessors: %bb.6
  successors: %bb.8(0x80000000); %bb.8(100.00%)


bb.8 (%ir-block.23):
; predecessors: %bb.7, %bb.8
  successors: %bb.9(0x04000000), %bb.8(0x7c000000); %bb.9(3.12%), %bb.8(96.88%)

  %8:gr64 = PHI %2:gr64, %bb.7, %13:gr64, %bb.8
  %9:gr64 = PHI %6:gr64, %bb.7, %12:gr64, %bb.8
  %10:gr64 = PHI %7:gr64, %bb.7, %11:gr64, %bb.8
  %11:gr64 = IMUL64rr killed %10:gr64(tied-def 0), %9:gr64, implicit-def dead $eflags
  %12:gr64 = nuw nsw INC64r killed %9:gr64(tied-def 0), implicit-def dead $eflags
  %13:gr64 = DEC64r killed %8:gr64(tied-def 0), implicit-def $eflags
  JCC_1 %bb.8, 5, implicit killed $eflags
  JMP_1 %bb.9

bb.9 (%ir-block.31):
; predecessors: %bb.6, %bb.8, %bb.1

  %14:gr64 = PHI %19:gr64, %bb.1, %5:gr64, %bb.6, %11:gr64, %bb.8
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %54:gr64 = LEA64r $rip, 1, $noreg, @.str.1, $noreg
  %55:gr32 = MOV32r0 implicit-def dead $eflags
  %56:gr8 = COPY killed %55.sub_8bit:gr32
  $rdi = COPY killed %54:gr64
  $rsi = COPY killed %14:gr64
  $al = COPY killed %56:gr8
  CALL64pcrel32 target-flags(x86-plt) @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit killed $rsi, implicit killed $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $eax = MOV32r0 implicit-def dead $eflags
  RET 0, killed $eax

bb.10 (%ir-block.34):
; predecessors: %bb.4, %bb.10
  successors: %bb.5(0x04000000), %bb.10(0x7c000000); %bb.5(3.12%), %bb.10(96.88%)

  %15:gr64_nosp = PHI %33:gr64, %bb.4, %18:gr64, %bb.10
  %16:gr64 = PHI %34:gr64, %bb.4, %17:gr64, %bb.10
  %38:gr64 = ADD64ri32 %15:gr64_nosp(tied-def 0), -7, implicit-def dead $eflags
  %39:gr64 = IMUL64rr killed %16:gr64(tied-def 0), killed %38:gr64, implicit-def dead $eflags
  %40:gr64 = ADD64ri32 %15:gr64_nosp(tied-def 0), -6, implicit-def dead $eflags
  %42:gr64 = ADD64ri32 %15:gr64_nosp(tied-def 0), -5, implicit-def dead $eflags
  %60:gr64 = IMUL64rr killed %40:gr64(tied-def 0), killed %42:gr64, implicit-def dead $eflags
  %43:gr64 = IMUL64rr killed %39:gr64(tied-def 0), killed %60:gr64, implicit-def dead $eflags
  %44:gr64 = ADD64ri32 %15:gr64_nosp(tied-def 0), -4, implicit-def dead $eflags
  %46:gr64 = ADD64ri32 %15:gr64_nosp(tied-def 0), -3, implicit-def dead $eflags
  %63:gr64 = IMUL64rr killed %44:gr64(tied-def 0), killed %46:gr64, implicit-def dead $eflags
  %48:gr64 = ADD64ri32 %15:gr64_nosp(tied-def 0), -2, implicit-def dead $eflags
  %64:gr64 = IMUL64rr killed %63:gr64(tied-def 0), killed %48:gr64, implicit-def dead $eflags
  %49:gr64 = IMUL64rr killed %43:gr64(tied-def 0), killed %64:gr64, implicit-def dead $eflags
  %50:gr64 = DEC64r %15:gr64_nosp(tied-def 0), implicit-def dead $eflags
  %67:gr64 = IMUL64rr killed %50:gr64(tied-def 0), %15:gr64_nosp, implicit-def dead $eflags
  %17:gr64 = IMUL64rr killed %49:gr64(tied-def 0), killed %67:gr64, implicit-def dead $eflags
  %18:gr64 = ADD64ri32 %15:gr64_nosp(tied-def 0), 8, implicit-def dead $eflags
  %52:gr64 = LEA64r %3:gr64, 1, killed %15:gr64_nosp, 8, $noreg
  CMP64ri32 killed %52:gr64, 8, implicit-def $eflags
  JCC_1 %bb.5, 4, implicit killed $eflags
  JMP_1 %bb.10

# End machine code for function main.

# *** IR Dump After Eliminate PHI nodes for register allocation (phi-node-elimination) ***:
# Machine code for function main: NoPHIs, TracksLiveness
Frame Objects:
  fi#0: size=4, align=4, at location [SP+8]

bb.0 (%ir-block.0):
  successors: %bb.1(0x30000000), %bb.2(0x50000000); %bb.1(37.50%), %bb.2(62.50%)

  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %20:gr64 = LEA64r $rip, 1, $noreg, @.str, $noreg
  %21:gr32 = MOV32r0 implicit-def dead $eflags
  %22:gr8 = COPY killed %21.sub_8bit:gr32
  %23:gr64 = LEA64r %stack.0, 1, $noreg, 0, $noreg
  $rdi = COPY killed %20:gr64
  $rsi = COPY killed %23:gr64
  $al = COPY killed %22:gr8
  CALL64pcrel32 target-flags(x86-plt) @__isoc99_scanf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit killed $rsi, implicit killed $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %25:gr32 = MOV32rm %stack.0, 1, $noreg, 0, $noreg :: (dereferenceable load (s32) from %ir.1, !tbaa !5)
  %0:gr64 = SUBREG_TO_REG 0, killed %25:gr32, %subreg.sub_32bit
  %26:gr32 = COPY %0.sub_32bit:gr64
  TEST32rr killed %26:gr32, %26:gr32, implicit-def $eflags
  JCC_1 %bb.2, 15, implicit killed $eflags

bb.1:
; predecessors: %bb.0
  successors: %bb.9(0x80000000); %bb.9(100.00%)

  %19:gr64 = MOV32ri64 1
  %74:gr64 = COPY killed %19:gr64
  JMP_1 %bb.9

bb.2 (%ir-block.6):
; predecessors: %bb.0
  successors: %bb.3(0x40000000), %bb.4(0x40000000); %bb.3(50.00%), %bb.4(50.00%)

  %29:gr64 = DEC64r %0:gr64(tied-def 0), implicit-def dead $eflags
  %30:gr32 = COPY %0.sub_32bit:gr64
  %31:gr32 = AND32ri killed %30:gr32(tied-def 0), 7, implicit-def dead $eflags
  %2:gr64 = SUBREG_TO_REG 0, killed %31:gr32, %subreg.sub_32bit
  CMP64ri32 killed %29:gr64, 7, implicit-def $eflags
  JCC_1 %bb.4, 3, implicit killed $eflags

bb.3:
; predecessors: %bb.2
  successors: %bb.6(0x80000000); %bb.6(100.00%)

  %28:gr64 = MOV32ri64 1
  %68:gr64 = IMPLICIT_DEF
  %69:gr64 = COPY %28:gr64
  %70:gr64 = COPY killed %28:gr64
  JMP_1 %bb.6

bb.4 (%ir-block.12):
; predecessors: %bb.2
  successors: %bb.10(0x80000000); %bb.10(100.00%)

  %1:gr64 = COPY killed %0:gr64
  %35:gr32 = COPY killed %1.sub_32bit:gr64
  %36:gr32 = AND32ri killed %35:gr32(tied-def 0), -8, implicit-def dead $eflags
  %37:gr64 = SUBREG_TO_REG 0, killed %36:gr32, %subreg.sub_32bit
  %3:gr64 = NEG64r killed %37:gr64(tied-def 0), implicit-def dead $eflags
  %34:gr64 = MOV32ri64 1
  %33:gr64 = MOV32ri64 8
  %75:gr64_nosp = COPY killed %33:gr64
  %76:gr64 = COPY killed %34:gr64
  JMP_1 %bb.10

bb.5 (%ir-block.15):
; predecessors: %bb.10
  successors: %bb.6(0x80000000); %bb.6(100.00%)

  %4:gr64 = ADD64ri32 killed %18:gr64(tied-def 0), -7, implicit-def dead $eflags
  %68:gr64 = COPY %17:gr64
  %69:gr64 = COPY killed %4:gr64
  %70:gr64 = COPY killed %17:gr64

bb.6 (%ir-block.17):
; predecessors: %bb.5, %bb.3
  successors: %bb.9(0x30000000), %bb.7(0x50000000); %bb.9(37.50%), %bb.7(62.50%)

  %7:gr64 = COPY killed %70:gr64
  %6:gr64 = COPY killed %69:gr64
  %5:gr64 = COPY killed %68:gr64
  TEST64rr %2:gr64, %2:gr64, implicit-def $eflags
  %74:gr64 = COPY killed %5:gr64
  JCC_1 %bb.9, 4, implicit killed $eflags
  JMP_1 %bb.7

bb.7 (%ir-block.22):
; predecessors: %bb.6
  successors: %bb.8(0x80000000); %bb.8(100.00%)

  %71:gr64 = COPY killed %2:gr64
  %72:gr64 = COPY killed %6:gr64
  %73:gr64 = COPY killed %7:gr64

bb.8 (%ir-block.23):
; predecessors: %bb.7, %bb.8
  successors: %bb.9(0x04000000), %bb.8(0x7c000000); %bb.9(3.12%), %bb.8(96.88%)

  %10:gr64 = COPY killed %73:gr64
  %9:gr64 = COPY killed %72:gr64
  %8:gr64 = COPY killed %71:gr64
  %11:gr64 = IMUL64rr killed %10:gr64(tied-def 0), %9:gr64, implicit-def dead $eflags
  %12:gr64 = nuw nsw INC64r killed %9:gr64(tied-def 0), implicit-def dead $eflags
  %13:gr64 = DEC64r killed %8:gr64(tied-def 0), implicit-def $eflags
  %71:gr64 = COPY killed %13:gr64
  %72:gr64 = COPY killed %12:gr64
  %73:gr64 = COPY %11:gr64
  %74:gr64 = COPY killed %11:gr64
  JCC_1 %bb.8, 5, implicit killed $eflags
  JMP_1 %bb.9

bb.9 (%ir-block.31):
; predecessors: %bb.6, %bb.8, %bb.1

  %14:gr64 = COPY killed %74:gr64
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %54:gr64 = LEA64r $rip, 1, $noreg, @.str.1, $noreg
  %55:gr32 = MOV32r0 implicit-def dead $eflags
  %56:gr8 = COPY killed %55.sub_8bit:gr32
  $rdi = COPY killed %54:gr64
  $rsi = COPY killed %14:gr64
  $al = COPY killed %56:gr8
  CALL64pcrel32 target-flags(x86-plt) @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit killed $rsi, implicit killed $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $eax = MOV32r0 implicit-def dead $eflags
  RET 0, killed $eax

bb.10 (%ir-block.34):
; predecessors: %bb.4, %bb.10
  successors: %bb.5(0x04000000), %bb.10(0x7c000000); %bb.5(3.12%), %bb.10(96.88%)

  %16:gr64 = COPY killed %76:gr64
  %15:gr64_nosp = COPY killed %75:gr64_nosp
  %38:gr64 = ADD64ri32 %15:gr64_nosp(tied-def 0), -7, implicit-def dead $eflags
  %39:gr64 = IMUL64rr killed %16:gr64(tied-def 0), killed %38:gr64, implicit-def dead $eflags
  %40:gr64 = ADD64ri32 %15:gr64_nosp(tied-def 0), -6, implicit-def dead $eflags
  %42:gr64 = ADD64ri32 %15:gr64_nosp(tied-def 0), -5, implicit-def dead $eflags
  %60:gr64 = IMUL64rr killed %40:gr64(tied-def 0), killed %42:gr64, implicit-def dead $eflags
  %43:gr64 = IMUL64rr killed %39:gr64(tied-def 0), killed %60:gr64, implicit-def dead $eflags
  %44:gr64 = ADD64ri32 %15:gr64_nosp(tied-def 0), -4, implicit-def dead $eflags
  %46:gr64 = ADD64ri32 %15:gr64_nosp(tied-def 0), -3, implicit-def dead $eflags
  %63:gr64 = IMUL64rr killed %44:gr64(tied-def 0), killed %46:gr64, implicit-def dead $eflags
  %48:gr64 = ADD64ri32 %15:gr64_nosp(tied-def 0), -2, implicit-def dead $eflags
  %64:gr64 = IMUL64rr killed %63:gr64(tied-def 0), killed %48:gr64, implicit-def dead $eflags
  %49:gr64 = IMUL64rr killed %43:gr64(tied-def 0), killed %64:gr64, implicit-def dead $eflags
  %50:gr64 = DEC64r %15:gr64_nosp(tied-def 0), implicit-def dead $eflags
  %67:gr64 = IMUL64rr killed %50:gr64(tied-def 0), %15:gr64_nosp, implicit-def dead $eflags
  %17:gr64 = IMUL64rr killed %49:gr64(tied-def 0), killed %67:gr64, implicit-def dead $eflags
  %18:gr64 = ADD64ri32 %15:gr64_nosp(tied-def 0), 8, implicit-def dead $eflags
  %52:gr64 = LEA64r %3:gr64, 1, killed %15:gr64_nosp, 8, $noreg
  CMP64ri32 killed %52:gr64, 8, implicit-def $eflags
  %75:gr64_nosp = COPY %18:gr64
  %76:gr64 = COPY %17:gr64
  JCC_1 %bb.5, 4, implicit killed $eflags
  JMP_1 %bb.10

# End machine code for function main.

# *** IR Dump After Two-Address instruction pass (twoaddressinstruction) ***:
# Machine code for function main: NoPHIs, TracksLiveness, TiedOpsRewritten
Frame Objects:
  fi#0: size=4, align=4, at location [SP+8]

bb.0 (%ir-block.0):
  successors: %bb.1(0x30000000), %bb.2(0x50000000); %bb.1(37.50%), %bb.2(62.50%)

  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %20:gr64 = LEA64r $rip, 1, $noreg, @.str, $noreg
  %21:gr32 = MOV32r0 implicit-def dead $eflags
  %22:gr8 = COPY killed %21.sub_8bit:gr32
  %23:gr64 = LEA64r %stack.0, 1, $noreg, 0, $noreg
  $rdi = COPY killed %20:gr64
  $rsi = COPY killed %23:gr64
  $al = COPY killed %22:gr8
  CALL64pcrel32 target-flags(x86-plt) @__isoc99_scanf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit killed $rsi, implicit killed $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %25:gr32 = MOV32rm %stack.0, 1, $noreg, 0, $noreg :: (dereferenceable load (s32) from %ir.1, !tbaa !5)
  %0:gr64_nosp = SUBREG_TO_REG 0, killed %25:gr32, %subreg.sub_32bit
  %26:gr32 = COPY %0.sub_32bit:gr64_nosp
  TEST32rr killed %26:gr32, %26:gr32, implicit-def $eflags
  JCC_1 %bb.2, 15, implicit killed $eflags

bb.1:
; predecessors: %bb.0
  successors: %bb.9(0x80000000); %bb.9(100.00%)

  %19:gr64 = MOV32ri64 1
  %74:gr64 = COPY killed %19:gr64
  JMP_1 %bb.9

bb.2 (%ir-block.6):
; predecessors: %bb.0
  successors: %bb.3(0x40000000), %bb.4(0x40000000); %bb.3(50.00%), %bb.4(50.00%)

  %29:gr64 = LEA64r %0:gr64_nosp, 1, $noreg, -1, $noreg
  %30:gr32 = COPY %0.sub_32bit:gr64_nosp
  %31:gr32 = COPY killed %30:gr32
  %31:gr32 = AND32ri %31:gr32(tied-def 0), 7, implicit-def dead $eflags
  %2:gr64 = SUBREG_TO_REG 0, killed %31:gr32, %subreg.sub_32bit
  CMP64ri32 killed %29:gr64, 7, implicit-def $eflags
  JCC_1 %bb.4, 3, implicit killed $eflags

bb.3:
; predecessors: %bb.2
  successors: %bb.6(0x80000000); %bb.6(100.00%)

  %28:gr64 = MOV32ri64 1
  %68:gr64 = IMPLICIT_DEF
  %69:gr64 = COPY %28:gr64
  %70:gr64 = COPY killed %28:gr64
  JMP_1 %bb.6

bb.4 (%ir-block.12):
; predecessors: %bb.2
  successors: %bb.10(0x80000000); %bb.10(100.00%)

  %1:gr64 = COPY killed %0:gr64_nosp
  %35:gr32 = COPY killed %1.sub_32bit:gr64
  %36:gr32 = COPY killed %35:gr32
  %36:gr32 = AND32ri %36:gr32(tied-def 0), -8, implicit-def dead $eflags
  %37:gr64 = SUBREG_TO_REG 0, killed %36:gr32, %subreg.sub_32bit
  %3:gr64 = COPY killed %37:gr64
  %3:gr64 = NEG64r %3:gr64(tied-def 0), implicit-def dead $eflags
  %34:gr64 = MOV32ri64 1
  %33:gr64 = MOV32ri64 8
  %75:gr64_nosp = COPY killed %33:gr64
  %76:gr64 = COPY killed %34:gr64
  JMP_1 %bb.10

bb.5 (%ir-block.15):
; predecessors: %bb.10
  successors: %bb.6(0x80000000); %bb.6(100.00%)

  %4:gr64 = COPY killed %18:gr64_nosp
  %4:gr64 = ADD64ri32 %4:gr64(tied-def 0), -7, implicit-def dead $eflags
  %68:gr64 = COPY %17:gr64
  %69:gr64 = COPY killed %4:gr64
  %70:gr64 = COPY killed %17:gr64

bb.6 (%ir-block.17):
; predecessors: %bb.5, %bb.3
  successors: %bb.9(0x30000000), %bb.7(0x50000000); %bb.9(37.50%), %bb.7(62.50%)

  %7:gr64 = COPY killed %70:gr64
  %6:gr64 = COPY killed %69:gr64
  %5:gr64 = COPY killed %68:gr64
  TEST64rr %2:gr64, %2:gr64, implicit-def $eflags
  %74:gr64 = COPY killed %5:gr64
  JCC_1 %bb.9, 4, implicit killed $eflags
  JMP_1 %bb.7

bb.7 (%ir-block.22):
; predecessors: %bb.6
  successors: %bb.8(0x80000000); %bb.8(100.00%)

  %71:gr64 = COPY killed %2:gr64
  %72:gr64 = COPY killed %6:gr64
  %73:gr64 = COPY killed %7:gr64

bb.8 (%ir-block.23):
; predecessors: %bb.7, %bb.8
  successors: %bb.9(0x04000000), %bb.8(0x7c000000); %bb.9(3.12%), %bb.8(96.88%)

  %10:gr64 = COPY killed %73:gr64
  %9:gr64 = COPY killed %72:gr64
  %8:gr64 = COPY killed %71:gr64
  %11:gr64 = COPY killed %10:gr64
  %11:gr64 = IMUL64rr %11:gr64(tied-def 0), %9:gr64, implicit-def dead $eflags
  %12:gr64 = COPY killed %9:gr64
  %12:gr64 = nuw nsw INC64r %12:gr64(tied-def 0), implicit-def dead $eflags
  %13:gr64 = COPY killed %8:gr64
  %13:gr64 = DEC64r %13:gr64(tied-def 0), implicit-def $eflags
  %71:gr64 = COPY killed %13:gr64
  %72:gr64 = COPY killed %12:gr64
  %73:gr64 = COPY %11:gr64
  %74:gr64 = COPY killed %11:gr64
  JCC_1 %bb.8, 5, implicit killed $eflags
  JMP_1 %bb.9

bb.9 (%ir-block.31):
; predecessors: %bb.6, %bb.8, %bb.1

  %14:gr64 = COPY killed %74:gr64
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %54:gr64 = LEA64r $rip, 1, $noreg, @.str.1, $noreg
  %55:gr32 = MOV32r0 implicit-def dead $eflags
  %56:gr8 = COPY killed %55.sub_8bit:gr32
  $rdi = COPY killed %54:gr64
  $rsi = COPY killed %14:gr64
  $al = COPY killed %56:gr8
  CALL64pcrel32 target-flags(x86-plt) @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit killed $rsi, implicit killed $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $eax = MOV32r0 implicit-def dead $eflags
  RET 0, killed $eax

bb.10 (%ir-block.34):
; predecessors: %bb.4, %bb.10
  successors: %bb.5(0x04000000), %bb.10(0x7c000000); %bb.5(3.12%), %bb.10(96.88%)

  %16:gr64 = COPY killed %76:gr64
  %15:gr64_nosp = COPY killed %75:gr64_nosp
  %38:gr64 = LEA64r %15:gr64_nosp, 1, $noreg, -7, $noreg
  %39:gr64 = COPY killed %38:gr64
  %39:gr64 = IMUL64rr %39:gr64(tied-def 0), killed %16:gr64, implicit-def dead $eflags
  %40:gr64 = LEA64r %15:gr64_nosp, 1, $noreg, -6, $noreg
  %42:gr64 = LEA64r %15:gr64_nosp, 1, $noreg, -5, $noreg
  %60:gr64 = COPY killed %40:gr64
  %60:gr64 = IMUL64rr %60:gr64(tied-def 0), killed %42:gr64, implicit-def dead $eflags
  %43:gr64 = COPY killed %60:gr64
  %43:gr64 = IMUL64rr %43:gr64(tied-def 0), killed %39:gr64, implicit-def dead $eflags
  %44:gr64 = LEA64r %15:gr64_nosp, 1, $noreg, -4, $noreg
  %46:gr64 = LEA64r %15:gr64_nosp, 1, $noreg, -3, $noreg
  %63:gr64 = COPY killed %44:gr64
  %63:gr64 = IMUL64rr %63:gr64(tied-def 0), killed %46:gr64, implicit-def dead $eflags
  %48:gr64 = LEA64r %15:gr64_nosp, 1, $noreg, -2, $noreg
  %64:gr64 = COPY killed %48:gr64
  %64:gr64 = IMUL64rr %64:gr64(tied-def 0), killed %63:gr64, implicit-def dead $eflags
  %49:gr64 = COPY killed %64:gr64
  %49:gr64 = IMUL64rr %49:gr64(tied-def 0), killed %43:gr64, implicit-def dead $eflags
  %50:gr64 = LEA64r %15:gr64_nosp, 1, $noreg, -1, $noreg
  %67:gr64 = COPY killed %50:gr64
  %67:gr64 = IMUL64rr %67:gr64(tied-def 0), %15:gr64_nosp, implicit-def dead $eflags
  %17:gr64 = COPY killed %67:gr64
  %17:gr64 = IMUL64rr %17:gr64(tied-def 0), killed %49:gr64, implicit-def dead $eflags
  %52:gr64 = LEA64r %3:gr64, 1, %15:gr64_nosp, 8, $noreg
  %18:gr64_nosp = COPY killed %15:gr64_nosp
  %18:gr64_nosp = ADD64ri32 %18:gr64_nosp(tied-def 0), 8, implicit-def dead $eflags
  CMP64ri32 killed %52:gr64, 8, implicit-def $eflags
  %75:gr64_nosp = COPY %18:gr64_nosp
  %76:gr64 = COPY %17:gr64
  JCC_1 %bb.5, 4, implicit killed $eflags
  JMP_1 %bb.10

# End machine code for function main.

# *** IR Dump After Slot index numbering (slotindexes) ***:
# Machine code for function main: NoPHIs, TracksLiveness, TiedOpsRewritten
Frame Objects:
  fi#0: size=4, align=4, at location [SP+8]

0B	bb.0 (%ir-block.0):
	  successors: %bb.1(0x30000000), %bb.2(0x50000000); %bb.1(37.50%), %bb.2(62.50%)

16B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
32B	  %20:gr64 = LEA64r $rip, 1, $noreg, @.str, $noreg
48B	  %21:gr32 = MOV32r0 implicit-def dead $eflags
64B	  %22:gr8 = COPY killed %21.sub_8bit:gr32
80B	  %23:gr64 = LEA64r %stack.0, 1, $noreg, 0, $noreg
96B	  $rdi = COPY killed %20:gr64
112B	  $rsi = COPY killed %23:gr64
128B	  $al = COPY killed %22:gr8
144B	  CALL64pcrel32 target-flags(x86-plt) @__isoc99_scanf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit killed $rsi, implicit killed $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
160B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
176B	  %25:gr32 = MOV32rm %stack.0, 1, $noreg, 0, $noreg :: (dereferenceable load (s32) from %ir.1, !tbaa !5)
192B	  %0:gr64_nosp = SUBREG_TO_REG 0, killed %25:gr32, %subreg.sub_32bit
208B	  %26:gr32 = COPY %0.sub_32bit:gr64_nosp
224B	  TEST32rr killed %26:gr32, %26:gr32, implicit-def $eflags
240B	  JCC_1 %bb.2, 15, implicit killed $eflags

256B	bb.1:
	; predecessors: %bb.0
	  successors: %bb.9(0x80000000); %bb.9(100.00%)

272B	  %19:gr64 = MOV32ri64 1
288B	  %74:gr64 = COPY killed %19:gr64
304B	  JMP_1 %bb.9

320B	bb.2 (%ir-block.6):
	; predecessors: %bb.0
	  successors: %bb.3(0x40000000), %bb.4(0x40000000); %bb.3(50.00%), %bb.4(50.00%)

336B	  %29:gr64 = LEA64r %0:gr64_nosp, 1, $noreg, -1, $noreg
352B	  %30:gr32 = COPY %0.sub_32bit:gr64_nosp
368B	  %31:gr32 = COPY killed %30:gr32
384B	  %31:gr32 = AND32ri %31:gr32(tied-def 0), 7, implicit-def dead $eflags
400B	  %2:gr64 = SUBREG_TO_REG 0, killed %31:gr32, %subreg.sub_32bit
416B	  CMP64ri32 killed %29:gr64, 7, implicit-def $eflags
432B	  JCC_1 %bb.4, 3, implicit killed $eflags

448B	bb.3:
	; predecessors: %bb.2
	  successors: %bb.6(0x80000000); %bb.6(100.00%)

464B	  %28:gr64 = MOV32ri64 1
480B	  %68:gr64 = IMPLICIT_DEF
496B	  %69:gr64 = COPY %28:gr64
512B	  %70:gr64 = COPY killed %28:gr64
528B	  JMP_1 %bb.6

544B	bb.4 (%ir-block.12):
	; predecessors: %bb.2
	  successors: %bb.10(0x80000000); %bb.10(100.00%)

560B	  %1:gr64 = COPY killed %0:gr64_nosp
576B	  %35:gr32 = COPY killed %1.sub_32bit:gr64
592B	  %36:gr32 = COPY killed %35:gr32
608B	  %36:gr32 = AND32ri %36:gr32(tied-def 0), -8, implicit-def dead $eflags
624B	  %37:gr64 = SUBREG_TO_REG 0, killed %36:gr32, %subreg.sub_32bit
640B	  %3:gr64 = COPY killed %37:gr64
656B	  %3:gr64 = NEG64r %3:gr64(tied-def 0), implicit-def dead $eflags
672B	  %34:gr64 = MOV32ri64 1
688B	  %33:gr64 = MOV32ri64 8
704B	  %75:gr64_nosp = COPY killed %33:gr64
720B	  %76:gr64 = COPY killed %34:gr64
736B	  JMP_1 %bb.10

752B	bb.5 (%ir-block.15):
	; predecessors: %bb.10
	  successors: %bb.6(0x80000000); %bb.6(100.00%)

768B	  %4:gr64 = COPY killed %18:gr64_nosp
784B	  %4:gr64 = ADD64ri32 %4:gr64(tied-def 0), -7, implicit-def dead $eflags
800B	  %68:gr64 = COPY %17:gr64
816B	  %69:gr64 = COPY killed %4:gr64
832B	  %70:gr64 = COPY killed %17:gr64

848B	bb.6 (%ir-block.17):
	; predecessors: %bb.5, %bb.3
	  successors: %bb.9(0x30000000), %bb.7(0x50000000); %bb.9(37.50%), %bb.7(62.50%)

864B	  %7:gr64 = COPY killed %70:gr64
880B	  %6:gr64 = COPY killed %69:gr64
896B	  %5:gr64 = COPY killed %68:gr64
912B	  TEST64rr %2:gr64, %2:gr64, implicit-def $eflags
928B	  %74:gr64 = COPY killed %5:gr64
944B	  JCC_1 %bb.9, 4, implicit killed $eflags
960B	  JMP_1 %bb.7

976B	bb.7 (%ir-block.22):
	; predecessors: %bb.6
	  successors: %bb.8(0x80000000); %bb.8(100.00%)

992B	  %71:gr64 = COPY killed %2:gr64
1008B	  %72:gr64 = COPY killed %6:gr64
1024B	  %73:gr64 = COPY killed %7:gr64

1040B	bb.8 (%ir-block.23):
	; predecessors: %bb.7, %bb.8
	  successors: %bb.9(0x04000000), %bb.8(0x7c000000); %bb.9(3.12%), %bb.8(96.88%)

1056B	  %10:gr64 = COPY killed %73:gr64
1072B	  %9:gr64 = COPY killed %72:gr64
1088B	  %8:gr64 = COPY killed %71:gr64
1104B	  %11:gr64 = COPY killed %10:gr64
1120B	  %11:gr64 = IMUL64rr %11:gr64(tied-def 0), %9:gr64, implicit-def dead $eflags
1136B	  %12:gr64 = COPY killed %9:gr64
1152B	  %12:gr64 = nuw nsw INC64r %12:gr64(tied-def 0), implicit-def dead $eflags
1168B	  %13:gr64 = COPY killed %8:gr64
1184B	  %13:gr64 = DEC64r %13:gr64(tied-def 0), implicit-def $eflags
1200B	  %71:gr64 = COPY killed %13:gr64
1216B	  %72:gr64 = COPY killed %12:gr64
1232B	  %73:gr64 = COPY %11:gr64
1248B	  %74:gr64 = COPY killed %11:gr64
1264B	  JCC_1 %bb.8, 5, implicit killed $eflags
1280B	  JMP_1 %bb.9

1296B	bb.9 (%ir-block.31):
	; predecessors: %bb.6, %bb.8, %bb.1

1312B	  %14:gr64 = COPY killed %74:gr64
1328B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
1344B	  %54:gr64 = LEA64r $rip, 1, $noreg, @.str.1, $noreg
1360B	  %55:gr32 = MOV32r0 implicit-def dead $eflags
1376B	  %56:gr8 = COPY killed %55.sub_8bit:gr32
1392B	  $rdi = COPY killed %54:gr64
1408B	  $rsi = COPY killed %14:gr64
1424B	  $al = COPY killed %56:gr8
1440B	  CALL64pcrel32 target-flags(x86-plt) @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit killed $rsi, implicit killed $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
1456B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
1472B	  $eax = MOV32r0 implicit-def dead $eflags
1488B	  RET 0, killed $eax

1504B	bb.10 (%ir-block.34):
	; predecessors: %bb.4, %bb.10
	  successors: %bb.5(0x04000000), %bb.10(0x7c000000); %bb.5(3.12%), %bb.10(96.88%)

1520B	  %16:gr64 = COPY killed %76:gr64
1536B	  %15:gr64_nosp = COPY killed %75:gr64_nosp
1552B	  %38:gr64 = LEA64r %15:gr64_nosp, 1, $noreg, -7, $noreg
1568B	  %39:gr64 = COPY killed %38:gr64
1584B	  %39:gr64 = IMUL64rr %39:gr64(tied-def 0), killed %16:gr64, implicit-def dead $eflags
1600B	  %40:gr64 = LEA64r %15:gr64_nosp, 1, $noreg, -6, $noreg
1616B	  %42:gr64 = LEA64r %15:gr64_nosp, 1, $noreg, -5, $noreg
1632B	  %60:gr64 = COPY killed %40:gr64
1648B	  %60:gr64 = IMUL64rr %60:gr64(tied-def 0), killed %42:gr64, implicit-def dead $eflags
1664B	  %43:gr64 = COPY killed %60:gr64
1680B	  %43:gr64 = IMUL64rr %43:gr64(tied-def 0), killed %39:gr64, implicit-def dead $eflags
1696B	  %44:gr64 = LEA64r %15:gr64_nosp, 1, $noreg, -4, $noreg
1712B	  %46:gr64 = LEA64r %15:gr64_nosp, 1, $noreg, -3, $noreg
1728B	  %63:gr64 = COPY killed %44:gr64
1744B	  %63:gr64 = IMUL64rr %63:gr64(tied-def 0), killed %46:gr64, implicit-def dead $eflags
1760B	  %48:gr64 = LEA64r %15:gr64_nosp, 1, $noreg, -2, $noreg
1776B	  %64:gr64 = COPY killed %48:gr64
1792B	  %64:gr64 = IMUL64rr %64:gr64(tied-def 0), killed %63:gr64, implicit-def dead $eflags
1808B	  %49:gr64 = COPY killed %64:gr64
1824B	  %49:gr64 = IMUL64rr %49:gr64(tied-def 0), killed %43:gr64, implicit-def dead $eflags
1840B	  %50:gr64 = LEA64r %15:gr64_nosp, 1, $noreg, -1, $noreg
1856B	  %67:gr64 = COPY killed %50:gr64
1872B	  %67:gr64 = IMUL64rr %67:gr64(tied-def 0), %15:gr64_nosp, implicit-def dead $eflags
1888B	  %17:gr64 = COPY killed %67:gr64
1904B	  %17:gr64 = IMUL64rr %17:gr64(tied-def 0), killed %49:gr64, implicit-def dead $eflags
1920B	  %52:gr64 = LEA64r %3:gr64, 1, %15:gr64_nosp, 8, $noreg
1936B	  %18:gr64_nosp = COPY killed %15:gr64_nosp
1952B	  %18:gr64_nosp = ADD64ri32 %18:gr64_nosp(tied-def 0), 8, implicit-def dead $eflags
1968B	  CMP64ri32 killed %52:gr64, 8, implicit-def $eflags
1984B	  %75:gr64_nosp = COPY %18:gr64_nosp
2000B	  %76:gr64 = COPY %17:gr64
2016B	  JCC_1 %bb.5, 4, implicit killed $eflags
2032B	  JMP_1 %bb.10

# End machine code for function main.

# *** IR Dump After Live Interval Analysis (liveintervals) ***:
# Machine code for function main: NoPHIs, TracksLiveness, TiedOpsRewritten
Frame Objects:
  fi#0: size=4, align=4, at location [SP+8]

0B	bb.0 (%ir-block.0):
	  successors: %bb.1(0x30000000), %bb.2(0x50000000); %bb.1(37.50%), %bb.2(62.50%)

16B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
32B	  %20:gr64 = LEA64r $rip, 1, $noreg, @.str, $noreg
48B	  %21:gr32 = MOV32r0 implicit-def dead $eflags
64B	  %22:gr8 = COPY %21.sub_8bit:gr32
80B	  %23:gr64 = LEA64r %stack.0, 1, $noreg, 0, $noreg
96B	  $rdi = COPY %20:gr64
112B	  $rsi = COPY %23:gr64
128B	  $al = COPY %22:gr8
144B	  CALL64pcrel32 target-flags(x86-plt) @__isoc99_scanf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit killed $rsi, implicit killed $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
160B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
176B	  %25:gr32 = MOV32rm %stack.0, 1, $noreg, 0, $noreg :: (dereferenceable load (s32) from %ir.1, !tbaa !5)
192B	  %0:gr64_nosp = SUBREG_TO_REG 0, %25:gr32, %subreg.sub_32bit
208B	  %26:gr32 = COPY %0.sub_32bit:gr64_nosp
224B	  TEST32rr %26:gr32, %26:gr32, implicit-def $eflags
240B	  JCC_1 %bb.2, 15, implicit killed $eflags

256B	bb.1:
	; predecessors: %bb.0
	  successors: %bb.9(0x80000000); %bb.9(100.00%)

272B	  %19:gr64 = MOV32ri64 1
288B	  %74:gr64 = COPY %19:gr64
304B	  JMP_1 %bb.9

320B	bb.2 (%ir-block.6):
	; predecessors: %bb.0
	  successors: %bb.3(0x40000000), %bb.4(0x40000000); %bb.3(50.00%), %bb.4(50.00%)

336B	  %29:gr64 = LEA64r %0:gr64_nosp, 1, $noreg, -1, $noreg
352B	  %30:gr32 = COPY %0.sub_32bit:gr64_nosp
368B	  %31:gr32 = COPY %30:gr32
384B	  %31:gr32 = AND32ri %31:gr32(tied-def 0), 7, implicit-def dead $eflags
400B	  %2:gr64 = SUBREG_TO_REG 0, %31:gr32, %subreg.sub_32bit
416B	  CMP64ri32 %29:gr64, 7, implicit-def $eflags
432B	  JCC_1 %bb.4, 3, implicit killed $eflags

448B	bb.3:
	; predecessors: %bb.2
	  successors: %bb.6(0x80000000); %bb.6(100.00%)

464B	  %28:gr64 = MOV32ri64 1
480B	  %68:gr64 = IMPLICIT_DEF
496B	  %69:gr64 = COPY %28:gr64
512B	  %70:gr64 = COPY %28:gr64
528B	  JMP_1 %bb.6

544B	bb.4 (%ir-block.12):
	; predecessors: %bb.2
	  successors: %bb.10(0x80000000); %bb.10(100.00%)

560B	  %1:gr64 = COPY %0:gr64_nosp
576B	  %35:gr32 = COPY %1.sub_32bit:gr64
592B	  %36:gr32 = COPY %35:gr32
608B	  %36:gr32 = AND32ri %36:gr32(tied-def 0), -8, implicit-def dead $eflags
624B	  %37:gr64 = SUBREG_TO_REG 0, %36:gr32, %subreg.sub_32bit
640B	  %3:gr64 = COPY %37:gr64
656B	  %3:gr64 = NEG64r %3:gr64(tied-def 0), implicit-def dead $eflags
672B	  %34:gr64 = MOV32ri64 1
688B	  %33:gr64 = MOV32ri64 8
704B	  %75:gr64_nosp = COPY %33:gr64
720B	  %76:gr64 = COPY %34:gr64
736B	  JMP_1 %bb.10

752B	bb.5 (%ir-block.15):
	; predecessors: %bb.10
	  successors: %bb.6(0x80000000); %bb.6(100.00%)

768B	  %4:gr64 = COPY %18:gr64_nosp
784B	  %4:gr64 = ADD64ri32 %4:gr64(tied-def 0), -7, implicit-def dead $eflags
800B	  %68:gr64 = COPY %17:gr64
816B	  %69:gr64 = COPY %4:gr64
832B	  %70:gr64 = COPY %17:gr64

848B	bb.6 (%ir-block.17):
	; predecessors: %bb.5, %bb.3
	  successors: %bb.9(0x30000000), %bb.7(0x50000000); %bb.9(37.50%), %bb.7(62.50%)

864B	  %7:gr64 = COPY %70:gr64
880B	  %6:gr64 = COPY %69:gr64
896B	  %5:gr64 = COPY %68:gr64
912B	  TEST64rr %2:gr64, %2:gr64, implicit-def $eflags
928B	  %74:gr64 = COPY %5:gr64
944B	  JCC_1 %bb.9, 4, implicit killed $eflags
960B	  JMP_1 %bb.7

976B	bb.7 (%ir-block.22):
	; predecessors: %bb.6
	  successors: %bb.8(0x80000000); %bb.8(100.00%)

992B	  %71:gr64 = COPY %2:gr64
1008B	  %72:gr64 = COPY %6:gr64
1024B	  %73:gr64 = COPY %7:gr64

1040B	bb.8 (%ir-block.23):
	; predecessors: %bb.7, %bb.8
	  successors: %bb.9(0x04000000), %bb.8(0x7c000000); %bb.9(3.12%), %bb.8(96.88%)

1056B	  %10:gr64 = COPY %73:gr64
1072B	  %9:gr64 = COPY %72:gr64
1088B	  %8:gr64 = COPY %71:gr64
1104B	  %11:gr64 = COPY %10:gr64
1120B	  %11:gr64 = IMUL64rr %11:gr64(tied-def 0), %9:gr64, implicit-def dead $eflags
1136B	  %12:gr64 = COPY %9:gr64
1152B	  %12:gr64 = nuw nsw INC64r %12:gr64(tied-def 0), implicit-def dead $eflags
1168B	  %13:gr64 = COPY %8:gr64
1184B	  %13:gr64 = DEC64r %13:gr64(tied-def 0), implicit-def $eflags
1200B	  %71:gr64 = COPY %13:gr64
1216B	  %72:gr64 = COPY %12:gr64
1232B	  %73:gr64 = COPY %11:gr64
1248B	  %74:gr64 = COPY %11:gr64
1264B	  JCC_1 %bb.8, 5, implicit killed $eflags
1280B	  JMP_1 %bb.9

1296B	bb.9 (%ir-block.31):
	; predecessors: %bb.6, %bb.8, %bb.1

1312B	  %14:gr64 = COPY %74:gr64
1328B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
1344B	  %54:gr64 = LEA64r $rip, 1, $noreg, @.str.1, $noreg
1360B	  %55:gr32 = MOV32r0 implicit-def dead $eflags
1376B	  %56:gr8 = COPY %55.sub_8bit:gr32
1392B	  $rdi = COPY %54:gr64
1408B	  $rsi = COPY %14:gr64
1424B	  $al = COPY %56:gr8
1440B	  CALL64pcrel32 target-flags(x86-plt) @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit killed $rsi, implicit killed $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
1456B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
1472B	  $eax = MOV32r0 implicit-def dead $eflags
1488B	  RET 0, killed $eax

1504B	bb.10 (%ir-block.34):
	; predecessors: %bb.4, %bb.10
	  successors: %bb.5(0x04000000), %bb.10(0x7c000000); %bb.5(3.12%), %bb.10(96.88%)

1520B	  %16:gr64 = COPY %76:gr64
1536B	  %15:gr64_nosp = COPY %75:gr64_nosp
1552B	  %38:gr64 = LEA64r %15:gr64_nosp, 1, $noreg, -7, $noreg
1568B	  %39:gr64 = COPY %38:gr64
1584B	  %39:gr64 = IMUL64rr %39:gr64(tied-def 0), %16:gr64, implicit-def dead $eflags
1600B	  %40:gr64 = LEA64r %15:gr64_nosp, 1, $noreg, -6, $noreg
1616B	  %42:gr64 = LEA64r %15:gr64_nosp, 1, $noreg, -5, $noreg
1632B	  %60:gr64 = COPY %40:gr64
1648B	  %60:gr64 = IMUL64rr %60:gr64(tied-def 0), %42:gr64, implicit-def dead $eflags
1664B	  %43:gr64 = COPY %60:gr64
1680B	  %43:gr64 = IMUL64rr %43:gr64(tied-def 0), %39:gr64, implicit-def dead $eflags
1696B	  %44:gr64 = LEA64r %15:gr64_nosp, 1, $noreg, -4, $noreg
1712B	  %46:gr64 = LEA64r %15:gr64_nosp, 1, $noreg, -3, $noreg
1728B	  %63:gr64 = COPY %44:gr64
1744B	  %63:gr64 = IMUL64rr %63:gr64(tied-def 0), %46:gr64, implicit-def dead $eflags
1760B	  %48:gr64 = LEA64r %15:gr64_nosp, 1, $noreg, -2, $noreg
1776B	  %64:gr64 = COPY %48:gr64
1792B	  %64:gr64 = IMUL64rr %64:gr64(tied-def 0), %63:gr64, implicit-def dead $eflags
1808B	  %49:gr64 = COPY %64:gr64
1824B	  %49:gr64 = IMUL64rr %49:gr64(tied-def 0), %43:gr64, implicit-def dead $eflags
1840B	  %50:gr64 = LEA64r %15:gr64_nosp, 1, $noreg, -1, $noreg
1856B	  %67:gr64 = COPY %50:gr64
1872B	  %67:gr64 = IMUL64rr %67:gr64(tied-def 0), %15:gr64_nosp, implicit-def dead $eflags
1888B	  %17:gr64 = COPY %67:gr64
1904B	  %17:gr64 = IMUL64rr %17:gr64(tied-def 0), %49:gr64, implicit-def dead $eflags
1920B	  %52:gr64 = LEA64r %3:gr64, 1, %15:gr64_nosp, 8, $noreg
1936B	  %18:gr64_nosp = COPY %15:gr64_nosp
1952B	  %18:gr64_nosp = ADD64ri32 %18:gr64_nosp(tied-def 0), 8, implicit-def dead $eflags
1968B	  CMP64ri32 %52:gr64, 8, implicit-def $eflags
1984B	  %75:gr64_nosp = COPY %18:gr64_nosp
2000B	  %76:gr64 = COPY %17:gr64
2016B	  JCC_1 %bb.5, 4, implicit killed $eflags
2032B	  JMP_1 %bb.10

# End machine code for function main.

# *** IR Dump After Register Coalescer (register-coalescer) ***:
# Machine code for function main: NoPHIs, TracksLiveness, TiedOpsRewritten
Frame Objects:
  fi#0: size=4, align=4, at location [SP+8]

0B	bb.0 (%ir-block.0):
	  successors: %bb.1(0x30000000), %bb.2(0x50000000); %bb.1(37.50%), %bb.2(62.50%)

16B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
32B	  %20:gr64 = LEA64r $rip, 1, $noreg, @.str, $noreg
80B	  %23:gr64 = LEA64r %stack.0, 1, $noreg, 0, $noreg
96B	  $rdi = COPY %20:gr64
112B	  $rsi = COPY %23:gr64
128B	  dead $eax = MOV32r0 implicit-def dead $eflags, implicit-def $al
144B	  CALL64pcrel32 target-flags(x86-plt) @__isoc99_scanf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit killed $rsi, implicit killed $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
160B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
176B	  undef %37.sub_32bit:gr64_nosp = MOV32rm %stack.0, 1, $noreg, 0, $noreg :: (dereferenceable load (s32) from %ir.1, !tbaa !5)
224B	  TEST32rr %37.sub_32bit:gr64_nosp, %37.sub_32bit:gr64_nosp, implicit-def $eflags
240B	  JCC_1 %bb.2, 15, implicit killed $eflags

256B	bb.1:
	; predecessors: %bb.0
	  successors: %bb.9(0x80000000); %bb.9(100.00%)

272B	  %76:gr64 = MOV32ri64 1
304B	  JMP_1 %bb.9

320B	bb.2 (%ir-block.6):
	; predecessors: %bb.0
	  successors: %bb.3(0x40000000), %bb.4(0x40000000); %bb.3(50.00%), %bb.4(50.00%)

336B	  %29:gr64 = LEA64r %37:gr64_nosp, 1, $noreg, -1, $noreg
368B	  undef %71.sub_32bit:gr64_with_sub_8bit = COPY %37.sub_32bit:gr64_nosp
384B	  %71.sub_32bit:gr64_with_sub_8bit = AND32ri %71.sub_32bit:gr64_with_sub_8bit(tied-def 0), 7, implicit-def dead $eflags
416B	  CMP64ri32 %29:gr64, 7, implicit-def $eflags
432B	  JCC_1 %bb.4, 3, implicit killed $eflags

448B	bb.3:
	; predecessors: %bb.2
	  successors: %bb.6(0x80000000); %bb.6(100.00%)

464B	  %72:gr64_nosp = MOV32ri64 1
512B	  %76:gr64 = MOV32ri64 1
528B	  JMP_1 %bb.6

544B	bb.4 (%ir-block.12):
	; predecessors: %bb.2
	  successors: %bb.10(0x80000000); %bb.10(100.00%)

608B	  %37.sub_32bit:gr64_nosp = AND32ri %37.sub_32bit:gr64_nosp(tied-def 0), -8, implicit-def dead $eflags
656B	  %37:gr64_nosp = NEG64r %37:gr64_nosp(tied-def 0), implicit-def dead $eflags
672B	  %76:gr64 = MOV32ri64 1
688B	  %72:gr64_nosp = MOV32ri64 8
736B	  JMP_1 %bb.10

752B	bb.5 (%ir-block.15):
	; predecessors: %bb.10
	  successors: %bb.6(0x80000000); %bb.6(100.00%)

784B	  %72:gr64_nosp = ADD64ri32 %72:gr64_nosp(tied-def 0), -7, implicit-def dead $eflags

848B	bb.6 (%ir-block.17):
	; predecessors: %bb.5, %bb.3
	  successors: %bb.9(0x30000000), %bb.7(0x50000000); %bb.9(37.50%), %bb.7(62.50%)

912B	  TEST64rr %71:gr64_with_sub_8bit, %71:gr64_with_sub_8bit, implicit-def $eflags
944B	  JCC_1 %bb.9, 4, implicit killed $eflags
960B	  JMP_1 %bb.7

976B	bb.7 (%ir-block.22):
	; predecessors: %bb.6
	  successors: %bb.8(0x80000000); %bb.8(100.00%)


1040B	bb.8 (%ir-block.23):
	; predecessors: %bb.7, %bb.8
	  successors: %bb.9(0x04000000), %bb.8(0x7c000000); %bb.9(3.12%), %bb.8(96.88%)

1120B	  %76:gr64 = IMUL64rr %76:gr64(tied-def 0), %72:gr64_nosp, implicit-def dead $eflags
1152B	  %72:gr64_nosp = nuw nsw INC64r %72:gr64_nosp(tied-def 0), implicit-def dead $eflags
1184B	  %71:gr64_with_sub_8bit = DEC64r %71:gr64_with_sub_8bit(tied-def 0), implicit-def $eflags
1264B	  JCC_1 %bb.8, 5, implicit killed $eflags
1280B	  JMP_1 %bb.9

1296B	bb.9 (%ir-block.31):
	; predecessors: %bb.6, %bb.8, %bb.1

1328B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
1344B	  %54:gr64 = LEA64r $rip, 1, $noreg, @.str.1, $noreg
1392B	  $rdi = COPY %54:gr64
1408B	  $rsi = COPY %76:gr64
1424B	  dead $eax = MOV32r0 implicit-def dead $eflags, implicit-def $al
1440B	  CALL64pcrel32 target-flags(x86-plt) @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit killed $rsi, implicit killed $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
1456B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
1472B	  $eax = MOV32r0 implicit-def dead $eflags
1488B	  RET 0, killed $eax

1504B	bb.10 (%ir-block.34):
	; predecessors: %bb.4, %bb.10
	  successors: %bb.5(0x04000000), %bb.10(0x7c000000); %bb.5(3.12%), %bb.10(96.88%)

1552B	  %39:gr64 = LEA64r %72:gr64_nosp, 1, $noreg, -7, $noreg
1584B	  %39:gr64 = IMUL64rr %39:gr64(tied-def 0), %76:gr64, implicit-def dead $eflags
1600B	  %43:gr64 = LEA64r %72:gr64_nosp, 1, $noreg, -6, $noreg
1616B	  %42:gr64 = LEA64r %72:gr64_nosp, 1, $noreg, -5, $noreg
1648B	  %43:gr64 = IMUL64rr %43:gr64(tied-def 0), %42:gr64, implicit-def dead $eflags
1680B	  %43:gr64 = IMUL64rr %43:gr64(tied-def 0), %39:gr64, implicit-def dead $eflags
1696B	  %63:gr64 = LEA64r %72:gr64_nosp, 1, $noreg, -4, $noreg
1712B	  %46:gr64 = LEA64r %72:gr64_nosp, 1, $noreg, -3, $noreg
1744B	  %63:gr64 = IMUL64rr %63:gr64(tied-def 0), %46:gr64, implicit-def dead $eflags
1760B	  %49:gr64 = LEA64r %72:gr64_nosp, 1, $noreg, -2, $noreg
1792B	  %49:gr64 = IMUL64rr %49:gr64(tied-def 0), %63:gr64, implicit-def dead $eflags
1824B	  %49:gr64 = IMUL64rr %49:gr64(tied-def 0), %43:gr64, implicit-def dead $eflags
1840B	  %76:gr64 = LEA64r %72:gr64_nosp, 1, $noreg, -1, $noreg
1872B	  %76:gr64 = IMUL64rr %76:gr64(tied-def 0), %72:gr64_nosp, implicit-def dead $eflags
1904B	  %76:gr64 = IMUL64rr %76:gr64(tied-def 0), %49:gr64, implicit-def dead $eflags
1920B	  %52:gr64 = LEA64r %37:gr64_nosp, 1, %72:gr64_nosp, 8, $noreg
1952B	  %72:gr64_nosp = ADD64ri32 %72:gr64_nosp(tied-def 0), 8, implicit-def dead $eflags
1968B	  CMP64ri32 %52:gr64, 8, implicit-def $eflags
2016B	  JCC_1 %bb.5, 4, implicit killed $eflags
2032B	  JMP_1 %bb.10

# End machine code for function main.

# *** IR Dump After Rename Disconnected Subregister Components (rename-independent-subregs) ***:
# Machine code for function main: NoPHIs, TracksLiveness, TiedOpsRewritten
Frame Objects:
  fi#0: size=4, align=4, at location [SP+8]

0B	bb.0 (%ir-block.0):
	  successors: %bb.1(0x30000000), %bb.2(0x50000000); %bb.1(37.50%), %bb.2(62.50%)

16B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
32B	  %20:gr64 = LEA64r $rip, 1, $noreg, @.str, $noreg
80B	  %23:gr64 = LEA64r %stack.0, 1, $noreg, 0, $noreg
96B	  $rdi = COPY %20:gr64
112B	  $rsi = COPY %23:gr64
128B	  dead $eax = MOV32r0 implicit-def dead $eflags, implicit-def $al
144B	  CALL64pcrel32 target-flags(x86-plt) @__isoc99_scanf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit killed $rsi, implicit killed $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
160B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
176B	  undef %37.sub_32bit:gr64_nosp = MOV32rm %stack.0, 1, $noreg, 0, $noreg :: (dereferenceable load (s32) from %ir.1, !tbaa !5)
224B	  TEST32rr %37.sub_32bit:gr64_nosp, %37.sub_32bit:gr64_nosp, implicit-def $eflags
240B	  JCC_1 %bb.2, 15, implicit killed $eflags

256B	bb.1:
	; predecessors: %bb.0
	  successors: %bb.9(0x80000000); %bb.9(100.00%)

272B	  %76:gr64 = MOV32ri64 1
304B	  JMP_1 %bb.9

320B	bb.2 (%ir-block.6):
	; predecessors: %bb.0
	  successors: %bb.3(0x40000000), %bb.4(0x40000000); %bb.3(50.00%), %bb.4(50.00%)

336B	  %29:gr64 = LEA64r %37:gr64_nosp, 1, $noreg, -1, $noreg
368B	  undef %71.sub_32bit:gr64_with_sub_8bit = COPY %37.sub_32bit:gr64_nosp
384B	  %71.sub_32bit:gr64_with_sub_8bit = AND32ri %71.sub_32bit:gr64_with_sub_8bit(tied-def 0), 7, implicit-def dead $eflags
416B	  CMP64ri32 %29:gr64, 7, implicit-def $eflags
432B	  JCC_1 %bb.4, 3, implicit killed $eflags

448B	bb.3:
	; predecessors: %bb.2
	  successors: %bb.6(0x80000000); %bb.6(100.00%)

464B	  %72:gr64_nosp = MOV32ri64 1
512B	  %76:gr64 = MOV32ri64 1
528B	  JMP_1 %bb.6

544B	bb.4 (%ir-block.12):
	; predecessors: %bb.2
	  successors: %bb.10(0x80000000); %bb.10(100.00%)

608B	  %37.sub_32bit:gr64_nosp = AND32ri %37.sub_32bit:gr64_nosp(tied-def 0), -8, implicit-def dead $eflags
656B	  %37:gr64_nosp = NEG64r %37:gr64_nosp(tied-def 0), implicit-def dead $eflags
672B	  %76:gr64 = MOV32ri64 1
688B	  %72:gr64_nosp = MOV32ri64 8
736B	  JMP_1 %bb.10

752B	bb.5 (%ir-block.15):
	; predecessors: %bb.10
	  successors: %bb.6(0x80000000); %bb.6(100.00%)

784B	  %72:gr64_nosp = ADD64ri32 %72:gr64_nosp(tied-def 0), -7, implicit-def dead $eflags

848B	bb.6 (%ir-block.17):
	; predecessors: %bb.5, %bb.3
	  successors: %bb.9(0x30000000), %bb.7(0x50000000); %bb.9(37.50%), %bb.7(62.50%)

912B	  TEST64rr %71:gr64_with_sub_8bit, %71:gr64_with_sub_8bit, implicit-def $eflags
944B	  JCC_1 %bb.9, 4, implicit killed $eflags
960B	  JMP_1 %bb.7

976B	bb.7 (%ir-block.22):
	; predecessors: %bb.6
	  successors: %bb.8(0x80000000); %bb.8(100.00%)


1040B	bb.8 (%ir-block.23):
	; predecessors: %bb.7, %bb.8
	  successors: %bb.9(0x04000000), %bb.8(0x7c000000); %bb.9(3.12%), %bb.8(96.88%)

1120B	  %76:gr64 = IMUL64rr %76:gr64(tied-def 0), %72:gr64_nosp, implicit-def dead $eflags
1152B	  %72:gr64_nosp = nuw nsw INC64r %72:gr64_nosp(tied-def 0), implicit-def dead $eflags
1184B	  %71:gr64_with_sub_8bit = DEC64r %71:gr64_with_sub_8bit(tied-def 0), implicit-def $eflags
1264B	  JCC_1 %bb.8, 5, implicit killed $eflags
1280B	  JMP_1 %bb.9

1296B	bb.9 (%ir-block.31):
	; predecessors: %bb.6, %bb.8, %bb.1

1328B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
1344B	  %54:gr64 = LEA64r $rip, 1, $noreg, @.str.1, $noreg
1392B	  $rdi = COPY %54:gr64
1408B	  $rsi = COPY %76:gr64
1424B	  dead $eax = MOV32r0 implicit-def dead $eflags, implicit-def $al
1440B	  CALL64pcrel32 target-flags(x86-plt) @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit killed $rsi, implicit killed $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
1456B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
1472B	  $eax = MOV32r0 implicit-def dead $eflags
1488B	  RET 0, killed $eax

1504B	bb.10 (%ir-block.34):
	; predecessors: %bb.4, %bb.10
	  successors: %bb.5(0x04000000), %bb.10(0x7c000000); %bb.5(3.12%), %bb.10(96.88%)

1552B	  %39:gr64 = LEA64r %72:gr64_nosp, 1, $noreg, -7, $noreg
1584B	  %39:gr64 = IMUL64rr %39:gr64(tied-def 0), %76:gr64, implicit-def dead $eflags
1600B	  %43:gr64 = LEA64r %72:gr64_nosp, 1, $noreg, -6, $noreg
1616B	  %42:gr64 = LEA64r %72:gr64_nosp, 1, $noreg, -5, $noreg
1648B	  %43:gr64 = IMUL64rr %43:gr64(tied-def 0), %42:gr64, implicit-def dead $eflags
1680B	  %43:gr64 = IMUL64rr %43:gr64(tied-def 0), %39:gr64, implicit-def dead $eflags
1696B	  %63:gr64 = LEA64r %72:gr64_nosp, 1, $noreg, -4, $noreg
1712B	  %46:gr64 = LEA64r %72:gr64_nosp, 1, $noreg, -3, $noreg
1744B	  %63:gr64 = IMUL64rr %63:gr64(tied-def 0), %46:gr64, implicit-def dead $eflags
1760B	  %49:gr64 = LEA64r %72:gr64_nosp, 1, $noreg, -2, $noreg
1792B	  %49:gr64 = IMUL64rr %49:gr64(tied-def 0), %63:gr64, implicit-def dead $eflags
1824B	  %49:gr64 = IMUL64rr %49:gr64(tied-def 0), %43:gr64, implicit-def dead $eflags
1840B	  %76:gr64 = LEA64r %72:gr64_nosp, 1, $noreg, -1, $noreg
1872B	  %76:gr64 = IMUL64rr %76:gr64(tied-def 0), %72:gr64_nosp, implicit-def dead $eflags
1904B	  %76:gr64 = IMUL64rr %76:gr64(tied-def 0), %49:gr64, implicit-def dead $eflags
1920B	  %52:gr64 = LEA64r %37:gr64_nosp, 1, %72:gr64_nosp, 8, $noreg
1952B	  %72:gr64_nosp = ADD64ri32 %72:gr64_nosp(tied-def 0), 8, implicit-def dead $eflags
1968B	  CMP64ri32 %52:gr64, 8, implicit-def $eflags
2016B	  JCC_1 %bb.5, 4, implicit killed $eflags
2032B	  JMP_1 %bb.10

# End machine code for function main.

# *** IR Dump After Machine Instruction Scheduler (machine-scheduler) ***:
# Machine code for function main: NoPHIs, TracksLiveness, TiedOpsRewritten
Frame Objects:
  fi#0: size=4, align=4, at location [SP+8]

0B	bb.0 (%ir-block.0):
	  successors: %bb.1(0x30000000), %bb.2(0x50000000); %bb.1(37.50%), %bb.2(62.50%)

16B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
32B	  %20:gr64 = LEA64r $rip, 1, $noreg, @.str, $noreg
80B	  %23:gr64 = LEA64r %stack.0, 1, $noreg, 0, $noreg
96B	  $rdi = COPY %20:gr64
112B	  $rsi = COPY %23:gr64
128B	  dead $eax = MOV32r0 implicit-def dead $eflags, implicit-def $al
144B	  CALL64pcrel32 target-flags(x86-plt) @__isoc99_scanf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit killed $rsi, implicit killed $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
160B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
176B	  undef %37.sub_32bit:gr64_nosp = MOV32rm %stack.0, 1, $noreg, 0, $noreg :: (dereferenceable load (s32) from %ir.1, !tbaa !5)
224B	  TEST32rr %37.sub_32bit:gr64_nosp, %37.sub_32bit:gr64_nosp, implicit-def $eflags
240B	  JCC_1 %bb.2, 15, implicit killed $eflags

256B	bb.1:
	; predecessors: %bb.0
	  successors: %bb.9(0x80000000); %bb.9(100.00%)

272B	  %76:gr64 = MOV32ri64 1
304B	  JMP_1 %bb.9

320B	bb.2 (%ir-block.6):
	; predecessors: %bb.0
	  successors: %bb.3(0x40000000), %bb.4(0x40000000); %bb.3(50.00%), %bb.4(50.00%)

336B	  %29:gr64 = LEA64r %37:gr64_nosp, 1, $noreg, -1, $noreg
368B	  undef %71.sub_32bit:gr64_with_sub_8bit = COPY %37.sub_32bit:gr64_nosp
384B	  %71.sub_32bit:gr64_with_sub_8bit = AND32ri %71.sub_32bit:gr64_with_sub_8bit(tied-def 0), 7, implicit-def dead $eflags
416B	  CMP64ri32 %29:gr64, 7, implicit-def $eflags
432B	  JCC_1 %bb.4, 3, implicit killed $eflags

448B	bb.3:
	; predecessors: %bb.2
	  successors: %bb.6(0x80000000); %bb.6(100.00%)

464B	  %72:gr64_nosp = MOV32ri64 1
512B	  %76:gr64 = MOV32ri64 1
528B	  JMP_1 %bb.6

544B	bb.4 (%ir-block.12):
	; predecessors: %bb.2
	  successors: %bb.10(0x80000000); %bb.10(100.00%)

608B	  %37.sub_32bit:gr64_nosp = AND32ri %37.sub_32bit:gr64_nosp(tied-def 0), -8, implicit-def dead $eflags
656B	  %37:gr64_nosp = NEG64r %37:gr64_nosp(tied-def 0), implicit-def dead $eflags
672B	  %76:gr64 = MOV32ri64 1
688B	  %72:gr64_nosp = MOV32ri64 8
736B	  JMP_1 %bb.10

752B	bb.5 (%ir-block.15):
	; predecessors: %bb.10
	  successors: %bb.6(0x80000000); %bb.6(100.00%)

784B	  %72:gr64_nosp = ADD64ri32 %72:gr64_nosp(tied-def 0), -7, implicit-def dead $eflags

848B	bb.6 (%ir-block.17):
	; predecessors: %bb.5, %bb.3
	  successors: %bb.9(0x30000000), %bb.7(0x50000000); %bb.9(37.50%), %bb.7(62.50%)

912B	  TEST64rr %71:gr64_with_sub_8bit, %71:gr64_with_sub_8bit, implicit-def $eflags
944B	  JCC_1 %bb.9, 4, implicit killed $eflags
960B	  JMP_1 %bb.7

976B	bb.7 (%ir-block.22):
	; predecessors: %bb.6
	  successors: %bb.8(0x80000000); %bb.8(100.00%)


1040B	bb.8 (%ir-block.23):
	; predecessors: %bb.7, %bb.8
	  successors: %bb.9(0x04000000), %bb.8(0x7c000000); %bb.9(3.12%), %bb.8(96.88%)

1120B	  %76:gr64 = IMUL64rr %76:gr64(tied-def 0), %72:gr64_nosp, implicit-def dead $eflags
1152B	  %72:gr64_nosp = nuw nsw INC64r %72:gr64_nosp(tied-def 0), implicit-def dead $eflags
1184B	  %71:gr64_with_sub_8bit = DEC64r %71:gr64_with_sub_8bit(tied-def 0), implicit-def $eflags
1264B	  JCC_1 %bb.8, 5, implicit killed $eflags
1280B	  JMP_1 %bb.9

1296B	bb.9 (%ir-block.31):
	; predecessors: %bb.6, %bb.8, %bb.1

1328B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
1344B	  %54:gr64 = LEA64r $rip, 1, $noreg, @.str.1, $noreg
1392B	  $rdi = COPY %54:gr64
1408B	  $rsi = COPY %76:gr64
1424B	  dead $eax = MOV32r0 implicit-def dead $eflags, implicit-def $al
1440B	  CALL64pcrel32 target-flags(x86-plt) @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit killed $rsi, implicit killed $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
1456B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
1472B	  $eax = MOV32r0 implicit-def dead $eflags
1488B	  RET 0, killed $eax

1504B	bb.10 (%ir-block.34):
	; predecessors: %bb.4, %bb.10
	  successors: %bb.5(0x04000000), %bb.10(0x7c000000); %bb.5(3.12%), %bb.10(96.88%)

1552B	  %39:gr64 = LEA64r %72:gr64_nosp, 1, $noreg, -7, $noreg
1584B	  %39:gr64 = IMUL64rr %39:gr64(tied-def 0), %76:gr64, implicit-def dead $eflags
1600B	  %43:gr64 = LEA64r %72:gr64_nosp, 1, $noreg, -6, $noreg
1616B	  %42:gr64 = LEA64r %72:gr64_nosp, 1, $noreg, -5, $noreg
1648B	  %43:gr64 = IMUL64rr %43:gr64(tied-def 0), %42:gr64, implicit-def dead $eflags
1680B	  %43:gr64 = IMUL64rr %43:gr64(tied-def 0), %39:gr64, implicit-def dead $eflags
1696B	  %63:gr64 = LEA64r %72:gr64_nosp, 1, $noreg, -4, $noreg
1712B	  %46:gr64 = LEA64r %72:gr64_nosp, 1, $noreg, -3, $noreg
1744B	  %63:gr64 = IMUL64rr %63:gr64(tied-def 0), %46:gr64, implicit-def dead $eflags
1760B	  %49:gr64 = LEA64r %72:gr64_nosp, 1, $noreg, -2, $noreg
1792B	  %49:gr64 = IMUL64rr %49:gr64(tied-def 0), %63:gr64, implicit-def dead $eflags
1824B	  %49:gr64 = IMUL64rr %49:gr64(tied-def 0), %43:gr64, implicit-def dead $eflags
1840B	  %76:gr64 = LEA64r %72:gr64_nosp, 1, $noreg, -1, $noreg
1872B	  %76:gr64 = IMUL64rr %76:gr64(tied-def 0), %72:gr64_nosp, implicit-def dead $eflags
1904B	  %76:gr64 = IMUL64rr %76:gr64(tied-def 0), %49:gr64, implicit-def dead $eflags
1920B	  %52:gr64 = LEA64r %37:gr64_nosp, 1, %72:gr64_nosp, 8, $noreg
1952B	  %72:gr64_nosp = ADD64ri32 %72:gr64_nosp(tied-def 0), 8, implicit-def dead $eflags
1968B	  CMP64ri32 %52:gr64, 8, implicit-def $eflags
2016B	  JCC_1 %bb.5, 4, implicit killed $eflags
2032B	  JMP_1 %bb.10

# End machine code for function main.

# *** IR Dump After Debug Variable Analysis (livedebugvars) ***:
# Machine code for function main: NoPHIs, TracksLiveness, TiedOpsRewritten, TracksDebugUserValues
Frame Objects:
  fi#0: size=4, align=4, at location [SP+8]

0B	bb.0 (%ir-block.0):
	  successors: %bb.1(0x30000000), %bb.2(0x50000000); %bb.1(37.50%), %bb.2(62.50%)

16B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
32B	  %20:gr64 = LEA64r $rip, 1, $noreg, @.str, $noreg
80B	  %23:gr64 = LEA64r %stack.0, 1, $noreg, 0, $noreg
96B	  $rdi = COPY %20:gr64
112B	  $rsi = COPY %23:gr64
128B	  dead $eax = MOV32r0 implicit-def dead $eflags, implicit-def $al
144B	  CALL64pcrel32 target-flags(x86-plt) @__isoc99_scanf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit killed $rsi, implicit killed $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
160B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
176B	  undef %37.sub_32bit:gr64_nosp = MOV32rm %stack.0, 1, $noreg, 0, $noreg :: (dereferenceable load (s32) from %ir.1, !tbaa !5)
224B	  TEST32rr %37.sub_32bit:gr64_nosp, %37.sub_32bit:gr64_nosp, implicit-def $eflags
240B	  JCC_1 %bb.2, 15, implicit killed $eflags

256B	bb.1:
	; predecessors: %bb.0
	  successors: %bb.9(0x80000000); %bb.9(100.00%)

272B	  %76:gr64 = MOV32ri64 1
304B	  JMP_1 %bb.9

320B	bb.2 (%ir-block.6):
	; predecessors: %bb.0
	  successors: %bb.3(0x40000000), %bb.4(0x40000000); %bb.3(50.00%), %bb.4(50.00%)

336B	  %29:gr64 = LEA64r %37:gr64_nosp, 1, $noreg, -1, $noreg
368B	  undef %71.sub_32bit:gr64_with_sub_8bit = COPY %37.sub_32bit:gr64_nosp
384B	  %71.sub_32bit:gr64_with_sub_8bit = AND32ri %71.sub_32bit:gr64_with_sub_8bit(tied-def 0), 7, implicit-def dead $eflags
416B	  CMP64ri32 %29:gr64, 7, implicit-def $eflags
432B	  JCC_1 %bb.4, 3, implicit killed $eflags

448B	bb.3:
	; predecessors: %bb.2
	  successors: %bb.6(0x80000000); %bb.6(100.00%)

464B	  %72:gr64_nosp = MOV32ri64 1
512B	  %76:gr64 = MOV32ri64 1
528B	  JMP_1 %bb.6

544B	bb.4 (%ir-block.12):
	; predecessors: %bb.2
	  successors: %bb.10(0x80000000); %bb.10(100.00%)

608B	  %37.sub_32bit:gr64_nosp = AND32ri %37.sub_32bit:gr64_nosp(tied-def 0), -8, implicit-def dead $eflags
656B	  %37:gr64_nosp = NEG64r %37:gr64_nosp(tied-def 0), implicit-def dead $eflags
672B	  %76:gr64 = MOV32ri64 1
688B	  %72:gr64_nosp = MOV32ri64 8
736B	  JMP_1 %bb.10

752B	bb.5 (%ir-block.15):
	; predecessors: %bb.10
	  successors: %bb.6(0x80000000); %bb.6(100.00%)

784B	  %72:gr64_nosp = ADD64ri32 %72:gr64_nosp(tied-def 0), -7, implicit-def dead $eflags

848B	bb.6 (%ir-block.17):
	; predecessors: %bb.5, %bb.3
	  successors: %bb.9(0x30000000), %bb.7(0x50000000); %bb.9(37.50%), %bb.7(62.50%)

912B	  TEST64rr %71:gr64_with_sub_8bit, %71:gr64_with_sub_8bit, implicit-def $eflags
944B	  JCC_1 %bb.9, 4, implicit killed $eflags
960B	  JMP_1 %bb.7

976B	bb.7 (%ir-block.22):
	; predecessors: %bb.6
	  successors: %bb.8(0x80000000); %bb.8(100.00%)


1040B	bb.8 (%ir-block.23):
	; predecessors: %bb.7, %bb.8
	  successors: %bb.9(0x04000000), %bb.8(0x7c000000); %bb.9(3.12%), %bb.8(96.88%)

1120B	  %76:gr64 = IMUL64rr %76:gr64(tied-def 0), %72:gr64_nosp, implicit-def dead $eflags
1152B	  %72:gr64_nosp = nuw nsw INC64r %72:gr64_nosp(tied-def 0), implicit-def dead $eflags
1184B	  %71:gr64_with_sub_8bit = DEC64r %71:gr64_with_sub_8bit(tied-def 0), implicit-def $eflags
1264B	  JCC_1 %bb.8, 5, implicit killed $eflags
1280B	  JMP_1 %bb.9

1296B	bb.9 (%ir-block.31):
	; predecessors: %bb.6, %bb.8, %bb.1

1328B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
1344B	  %54:gr64 = LEA64r $rip, 1, $noreg, @.str.1, $noreg
1392B	  $rdi = COPY %54:gr64
1408B	  $rsi = COPY %76:gr64
1424B	  dead $eax = MOV32r0 implicit-def dead $eflags, implicit-def $al
1440B	  CALL64pcrel32 target-flags(x86-plt) @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit killed $rsi, implicit killed $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
1456B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
1472B	  $eax = MOV32r0 implicit-def dead $eflags
1488B	  RET 0, killed $eax

1504B	bb.10 (%ir-block.34):
	; predecessors: %bb.4, %bb.10
	  successors: %bb.5(0x04000000), %bb.10(0x7c000000); %bb.5(3.12%), %bb.10(96.88%)

1552B	  %39:gr64 = LEA64r %72:gr64_nosp, 1, $noreg, -7, $noreg
1584B	  %39:gr64 = IMUL64rr %39:gr64(tied-def 0), %76:gr64, implicit-def dead $eflags
1600B	  %43:gr64 = LEA64r %72:gr64_nosp, 1, $noreg, -6, $noreg
1616B	  %42:gr64 = LEA64r %72:gr64_nosp, 1, $noreg, -5, $noreg
1648B	  %43:gr64 = IMUL64rr %43:gr64(tied-def 0), %42:gr64, implicit-def dead $eflags
1680B	  %43:gr64 = IMUL64rr %43:gr64(tied-def 0), %39:gr64, implicit-def dead $eflags
1696B	  %63:gr64 = LEA64r %72:gr64_nosp, 1, $noreg, -4, $noreg
1712B	  %46:gr64 = LEA64r %72:gr64_nosp, 1, $noreg, -3, $noreg
1744B	  %63:gr64 = IMUL64rr %63:gr64(tied-def 0), %46:gr64, implicit-def dead $eflags
1760B	  %49:gr64 = LEA64r %72:gr64_nosp, 1, $noreg, -2, $noreg
1792B	  %49:gr64 = IMUL64rr %49:gr64(tied-def 0), %63:gr64, implicit-def dead $eflags
1824B	  %49:gr64 = IMUL64rr %49:gr64(tied-def 0), %43:gr64, implicit-def dead $eflags
1840B	  %76:gr64 = LEA64r %72:gr64_nosp, 1, $noreg, -1, $noreg
1872B	  %76:gr64 = IMUL64rr %76:gr64(tied-def 0), %72:gr64_nosp, implicit-def dead $eflags
1904B	  %76:gr64 = IMUL64rr %76:gr64(tied-def 0), %49:gr64, implicit-def dead $eflags
1920B	  %52:gr64 = LEA64r %37:gr64_nosp, 1, %72:gr64_nosp, 8, $noreg
1952B	  %72:gr64_nosp = ADD64ri32 %72:gr64_nosp(tied-def 0), 8, implicit-def dead $eflags
1968B	  CMP64ri32 %52:gr64, 8, implicit-def $eflags
2016B	  JCC_1 %bb.5, 4, implicit killed $eflags
2032B	  JMP_1 %bb.10

# End machine code for function main.

# *** IR Dump After Live Stack Slot Analysis (livestacks) ***:
# Machine code for function main: NoPHIs, TracksLiveness, TiedOpsRewritten, TracksDebugUserValues
Frame Objects:
  fi#0: size=4, align=4, at location [SP+8]

0B	bb.0 (%ir-block.0):
	  successors: %bb.1(0x30000000), %bb.2(0x50000000); %bb.1(37.50%), %bb.2(62.50%)

16B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
32B	  %20:gr64 = LEA64r $rip, 1, $noreg, @.str, $noreg
80B	  %23:gr64 = LEA64r %stack.0, 1, $noreg, 0, $noreg
96B	  $rdi = COPY %20:gr64
112B	  $rsi = COPY %23:gr64
128B	  dead $eax = MOV32r0 implicit-def dead $eflags, implicit-def $al
144B	  CALL64pcrel32 target-flags(x86-plt) @__isoc99_scanf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit killed $rsi, implicit killed $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
160B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
176B	  undef %37.sub_32bit:gr64_nosp = MOV32rm %stack.0, 1, $noreg, 0, $noreg :: (dereferenceable load (s32) from %ir.1, !tbaa !5)
224B	  TEST32rr %37.sub_32bit:gr64_nosp, %37.sub_32bit:gr64_nosp, implicit-def $eflags
240B	  JCC_1 %bb.2, 15, implicit killed $eflags

256B	bb.1:
	; predecessors: %bb.0
	  successors: %bb.9(0x80000000); %bb.9(100.00%)

272B	  %76:gr64 = MOV32ri64 1
304B	  JMP_1 %bb.9

320B	bb.2 (%ir-block.6):
	; predecessors: %bb.0
	  successors: %bb.3(0x40000000), %bb.4(0x40000000); %bb.3(50.00%), %bb.4(50.00%)

336B	  %29:gr64 = LEA64r %37:gr64_nosp, 1, $noreg, -1, $noreg
368B	  undef %71.sub_32bit:gr64_with_sub_8bit = COPY %37.sub_32bit:gr64_nosp
384B	  %71.sub_32bit:gr64_with_sub_8bit = AND32ri %71.sub_32bit:gr64_with_sub_8bit(tied-def 0), 7, implicit-def dead $eflags
416B	  CMP64ri32 %29:gr64, 7, implicit-def $eflags
432B	  JCC_1 %bb.4, 3, implicit killed $eflags

448B	bb.3:
	; predecessors: %bb.2
	  successors: %bb.6(0x80000000); %bb.6(100.00%)

464B	  %72:gr64_nosp = MOV32ri64 1
512B	  %76:gr64 = MOV32ri64 1
528B	  JMP_1 %bb.6

544B	bb.4 (%ir-block.12):
	; predecessors: %bb.2
	  successors: %bb.10(0x80000000); %bb.10(100.00%)

608B	  %37.sub_32bit:gr64_nosp = AND32ri %37.sub_32bit:gr64_nosp(tied-def 0), -8, implicit-def dead $eflags
656B	  %37:gr64_nosp = NEG64r %37:gr64_nosp(tied-def 0), implicit-def dead $eflags
672B	  %76:gr64 = MOV32ri64 1
688B	  %72:gr64_nosp = MOV32ri64 8
736B	  JMP_1 %bb.10

752B	bb.5 (%ir-block.15):
	; predecessors: %bb.10
	  successors: %bb.6(0x80000000); %bb.6(100.00%)

784B	  %72:gr64_nosp = ADD64ri32 %72:gr64_nosp(tied-def 0), -7, implicit-def dead $eflags

848B	bb.6 (%ir-block.17):
	; predecessors: %bb.5, %bb.3
	  successors: %bb.9(0x30000000), %bb.7(0x50000000); %bb.9(37.50%), %bb.7(62.50%)

912B	  TEST64rr %71:gr64_with_sub_8bit, %71:gr64_with_sub_8bit, implicit-def $eflags
944B	  JCC_1 %bb.9, 4, implicit killed $eflags
960B	  JMP_1 %bb.7

976B	bb.7 (%ir-block.22):
	; predecessors: %bb.6
	  successors: %bb.8(0x80000000); %bb.8(100.00%)


1040B	bb.8 (%ir-block.23):
	; predecessors: %bb.7, %bb.8
	  successors: %bb.9(0x04000000), %bb.8(0x7c000000); %bb.9(3.12%), %bb.8(96.88%)

1120B	  %76:gr64 = IMUL64rr %76:gr64(tied-def 0), %72:gr64_nosp, implicit-def dead $eflags
1152B	  %72:gr64_nosp = nuw nsw INC64r %72:gr64_nosp(tied-def 0), implicit-def dead $eflags
1184B	  %71:gr64_with_sub_8bit = DEC64r %71:gr64_with_sub_8bit(tied-def 0), implicit-def $eflags
1264B	  JCC_1 %bb.8, 5, implicit killed $eflags
1280B	  JMP_1 %bb.9

1296B	bb.9 (%ir-block.31):
	; predecessors: %bb.6, %bb.8, %bb.1

1328B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
1344B	  %54:gr64 = LEA64r $rip, 1, $noreg, @.str.1, $noreg
1392B	  $rdi = COPY %54:gr64
1408B	  $rsi = COPY %76:gr64
1424B	  dead $eax = MOV32r0 implicit-def dead $eflags, implicit-def $al
1440B	  CALL64pcrel32 target-flags(x86-plt) @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit killed $rsi, implicit killed $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
1456B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
1472B	  $eax = MOV32r0 implicit-def dead $eflags
1488B	  RET 0, killed $eax

1504B	bb.10 (%ir-block.34):
	; predecessors: %bb.4, %bb.10
	  successors: %bb.5(0x04000000), %bb.10(0x7c000000); %bb.5(3.12%), %bb.10(96.88%)

1552B	  %39:gr64 = LEA64r %72:gr64_nosp, 1, $noreg, -7, $noreg
1584B	  %39:gr64 = IMUL64rr %39:gr64(tied-def 0), %76:gr64, implicit-def dead $eflags
1600B	  %43:gr64 = LEA64r %72:gr64_nosp, 1, $noreg, -6, $noreg
1616B	  %42:gr64 = LEA64r %72:gr64_nosp, 1, $noreg, -5, $noreg
1648B	  %43:gr64 = IMUL64rr %43:gr64(tied-def 0), %42:gr64, implicit-def dead $eflags
1680B	  %43:gr64 = IMUL64rr %43:gr64(tied-def 0), %39:gr64, implicit-def dead $eflags
1696B	  %63:gr64 = LEA64r %72:gr64_nosp, 1, $noreg, -4, $noreg
1712B	  %46:gr64 = LEA64r %72:gr64_nosp, 1, $noreg, -3, $noreg
1744B	  %63:gr64 = IMUL64rr %63:gr64(tied-def 0), %46:gr64, implicit-def dead $eflags
1760B	  %49:gr64 = LEA64r %72:gr64_nosp, 1, $noreg, -2, $noreg
1792B	  %49:gr64 = IMUL64rr %49:gr64(tied-def 0), %63:gr64, implicit-def dead $eflags
1824B	  %49:gr64 = IMUL64rr %49:gr64(tied-def 0), %43:gr64, implicit-def dead $eflags
1840B	  %76:gr64 = LEA64r %72:gr64_nosp, 1, $noreg, -1, $noreg
1872B	  %76:gr64 = IMUL64rr %76:gr64(tied-def 0), %72:gr64_nosp, implicit-def dead $eflags
1904B	  %76:gr64 = IMUL64rr %76:gr64(tied-def 0), %49:gr64, implicit-def dead $eflags
1920B	  %52:gr64 = LEA64r %37:gr64_nosp, 1, %72:gr64_nosp, 8, $noreg
1952B	  %72:gr64_nosp = ADD64ri32 %72:gr64_nosp(tied-def 0), 8, implicit-def dead $eflags
1968B	  CMP64ri32 %52:gr64, 8, implicit-def $eflags
2016B	  JCC_1 %bb.5, 4, implicit killed $eflags
2032B	  JMP_1 %bb.10

# End machine code for function main.

# *** IR Dump After Virtual Register Map (virtregmap) ***:
# Machine code for function main: NoPHIs, TracksLiveness, TiedOpsRewritten, TracksDebugUserValues
Frame Objects:
  fi#0: size=4, align=4, at location [SP+8]

0B	bb.0 (%ir-block.0):
	  successors: %bb.1(0x30000000), %bb.2(0x50000000); %bb.1(37.50%), %bb.2(62.50%)

16B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
32B	  %20:gr64 = LEA64r $rip, 1, $noreg, @.str, $noreg
80B	  %23:gr64 = LEA64r %stack.0, 1, $noreg, 0, $noreg
96B	  $rdi = COPY %20:gr64
112B	  $rsi = COPY %23:gr64
128B	  dead $eax = MOV32r0 implicit-def dead $eflags, implicit-def $al
144B	  CALL64pcrel32 target-flags(x86-plt) @__isoc99_scanf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit killed $rsi, implicit killed $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
160B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
176B	  undef %37.sub_32bit:gr64_nosp = MOV32rm %stack.0, 1, $noreg, 0, $noreg :: (dereferenceable load (s32) from %ir.1, !tbaa !5)
224B	  TEST32rr %37.sub_32bit:gr64_nosp, %37.sub_32bit:gr64_nosp, implicit-def $eflags
240B	  JCC_1 %bb.2, 15, implicit killed $eflags

256B	bb.1:
	; predecessors: %bb.0
	  successors: %bb.9(0x80000000); %bb.9(100.00%)

272B	  %76:gr64 = MOV32ri64 1
304B	  JMP_1 %bb.9

320B	bb.2 (%ir-block.6):
	; predecessors: %bb.0
	  successors: %bb.3(0x40000000), %bb.4(0x40000000); %bb.3(50.00%), %bb.4(50.00%)

336B	  %29:gr64 = LEA64r %37:gr64_nosp, 1, $noreg, -1, $noreg
368B	  undef %71.sub_32bit:gr64_with_sub_8bit = COPY %37.sub_32bit:gr64_nosp
384B	  %71.sub_32bit:gr64_with_sub_8bit = AND32ri %71.sub_32bit:gr64_with_sub_8bit(tied-def 0), 7, implicit-def dead $eflags
416B	  CMP64ri32 %29:gr64, 7, implicit-def $eflags
432B	  JCC_1 %bb.4, 3, implicit killed $eflags

448B	bb.3:
	; predecessors: %bb.2
	  successors: %bb.6(0x80000000); %bb.6(100.00%)

464B	  %72:gr64_nosp = MOV32ri64 1
512B	  %76:gr64 = MOV32ri64 1
528B	  JMP_1 %bb.6

544B	bb.4 (%ir-block.12):
	; predecessors: %bb.2
	  successors: %bb.10(0x80000000); %bb.10(100.00%)

608B	  %37.sub_32bit:gr64_nosp = AND32ri %37.sub_32bit:gr64_nosp(tied-def 0), -8, implicit-def dead $eflags
656B	  %37:gr64_nosp = NEG64r %37:gr64_nosp(tied-def 0), implicit-def dead $eflags
672B	  %76:gr64 = MOV32ri64 1
688B	  %72:gr64_nosp = MOV32ri64 8
736B	  JMP_1 %bb.10

752B	bb.5 (%ir-block.15):
	; predecessors: %bb.10
	  successors: %bb.6(0x80000000); %bb.6(100.00%)

784B	  %72:gr64_nosp = ADD64ri32 %72:gr64_nosp(tied-def 0), -7, implicit-def dead $eflags

848B	bb.6 (%ir-block.17):
	; predecessors: %bb.5, %bb.3
	  successors: %bb.9(0x30000000), %bb.7(0x50000000); %bb.9(37.50%), %bb.7(62.50%)

912B	  TEST64rr %71:gr64_with_sub_8bit, %71:gr64_with_sub_8bit, implicit-def $eflags
944B	  JCC_1 %bb.9, 4, implicit killed $eflags
960B	  JMP_1 %bb.7

976B	bb.7 (%ir-block.22):
	; predecessors: %bb.6
	  successors: %bb.8(0x80000000); %bb.8(100.00%)


1040B	bb.8 (%ir-block.23):
	; predecessors: %bb.7, %bb.8
	  successors: %bb.9(0x04000000), %bb.8(0x7c000000); %bb.9(3.12%), %bb.8(96.88%)

1120B	  %76:gr64 = IMUL64rr %76:gr64(tied-def 0), %72:gr64_nosp, implicit-def dead $eflags
1152B	  %72:gr64_nosp = nuw nsw INC64r %72:gr64_nosp(tied-def 0), implicit-def dead $eflags
1184B	  %71:gr64_with_sub_8bit = DEC64r %71:gr64_with_sub_8bit(tied-def 0), implicit-def $eflags
1264B	  JCC_1 %bb.8, 5, implicit killed $eflags
1280B	  JMP_1 %bb.9

1296B	bb.9 (%ir-block.31):
	; predecessors: %bb.6, %bb.8, %bb.1

1328B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
1344B	  %54:gr64 = LEA64r $rip, 1, $noreg, @.str.1, $noreg
1392B	  $rdi = COPY %54:gr64
1408B	  $rsi = COPY %76:gr64
1424B	  dead $eax = MOV32r0 implicit-def dead $eflags, implicit-def $al
1440B	  CALL64pcrel32 target-flags(x86-plt) @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit killed $rsi, implicit killed $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
1456B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
1472B	  $eax = MOV32r0 implicit-def dead $eflags
1488B	  RET 0, killed $eax

1504B	bb.10 (%ir-block.34):
	; predecessors: %bb.4, %bb.10
	  successors: %bb.5(0x04000000), %bb.10(0x7c000000); %bb.5(3.12%), %bb.10(96.88%)

1552B	  %39:gr64 = LEA64r %72:gr64_nosp, 1, $noreg, -7, $noreg
1584B	  %39:gr64 = IMUL64rr %39:gr64(tied-def 0), %76:gr64, implicit-def dead $eflags
1600B	  %43:gr64 = LEA64r %72:gr64_nosp, 1, $noreg, -6, $noreg
1616B	  %42:gr64 = LEA64r %72:gr64_nosp, 1, $noreg, -5, $noreg
1648B	  %43:gr64 = IMUL64rr %43:gr64(tied-def 0), %42:gr64, implicit-def dead $eflags
1680B	  %43:gr64 = IMUL64rr %43:gr64(tied-def 0), %39:gr64, implicit-def dead $eflags
1696B	  %63:gr64 = LEA64r %72:gr64_nosp, 1, $noreg, -4, $noreg
1712B	  %46:gr64 = LEA64r %72:gr64_nosp, 1, $noreg, -3, $noreg
1744B	  %63:gr64 = IMUL64rr %63:gr64(tied-def 0), %46:gr64, implicit-def dead $eflags
1760B	  %49:gr64 = LEA64r %72:gr64_nosp, 1, $noreg, -2, $noreg
1792B	  %49:gr64 = IMUL64rr %49:gr64(tied-def 0), %63:gr64, implicit-def dead $eflags
1824B	  %49:gr64 = IMUL64rr %49:gr64(tied-def 0), %43:gr64, implicit-def dead $eflags
1840B	  %76:gr64 = LEA64r %72:gr64_nosp, 1, $noreg, -1, $noreg
1872B	  %76:gr64 = IMUL64rr %76:gr64(tied-def 0), %72:gr64_nosp, implicit-def dead $eflags
1904B	  %76:gr64 = IMUL64rr %76:gr64(tied-def 0), %49:gr64, implicit-def dead $eflags
1920B	  %52:gr64 = LEA64r %37:gr64_nosp, 1, %72:gr64_nosp, 8, $noreg
1952B	  %72:gr64_nosp = ADD64ri32 %72:gr64_nosp(tied-def 0), 8, implicit-def dead $eflags
1968B	  CMP64ri32 %52:gr64, 8, implicit-def $eflags
2016B	  JCC_1 %bb.5, 4, implicit killed $eflags
2032B	  JMP_1 %bb.10

# End machine code for function main.

# *** IR Dump After Live Register Matrix (liveregmatrix) ***:
# Machine code for function main: NoPHIs, TracksLiveness, TiedOpsRewritten, TracksDebugUserValues
Frame Objects:
  fi#0: size=4, align=4, at location [SP+8]

0B	bb.0 (%ir-block.0):
	  successors: %bb.1(0x30000000), %bb.2(0x50000000); %bb.1(37.50%), %bb.2(62.50%)

16B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
32B	  %20:gr64 = LEA64r $rip, 1, $noreg, @.str, $noreg
80B	  %23:gr64 = LEA64r %stack.0, 1, $noreg, 0, $noreg
96B	  $rdi = COPY %20:gr64
112B	  $rsi = COPY %23:gr64
128B	  dead $eax = MOV32r0 implicit-def dead $eflags, implicit-def $al
144B	  CALL64pcrel32 target-flags(x86-plt) @__isoc99_scanf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit killed $rsi, implicit killed $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
160B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
176B	  undef %37.sub_32bit:gr64_nosp = MOV32rm %stack.0, 1, $noreg, 0, $noreg :: (dereferenceable load (s32) from %ir.1, !tbaa !5)
224B	  TEST32rr %37.sub_32bit:gr64_nosp, %37.sub_32bit:gr64_nosp, implicit-def $eflags
240B	  JCC_1 %bb.2, 15, implicit killed $eflags

256B	bb.1:
	; predecessors: %bb.0
	  successors: %bb.9(0x80000000); %bb.9(100.00%)

272B	  %76:gr64 = MOV32ri64 1
304B	  JMP_1 %bb.9

320B	bb.2 (%ir-block.6):
	; predecessors: %bb.0
	  successors: %bb.3(0x40000000), %bb.4(0x40000000); %bb.3(50.00%), %bb.4(50.00%)

336B	  %29:gr64 = LEA64r %37:gr64_nosp, 1, $noreg, -1, $noreg
368B	  undef %71.sub_32bit:gr64_with_sub_8bit = COPY %37.sub_32bit:gr64_nosp
384B	  %71.sub_32bit:gr64_with_sub_8bit = AND32ri %71.sub_32bit:gr64_with_sub_8bit(tied-def 0), 7, implicit-def dead $eflags
416B	  CMP64ri32 %29:gr64, 7, implicit-def $eflags
432B	  JCC_1 %bb.4, 3, implicit killed $eflags

448B	bb.3:
	; predecessors: %bb.2
	  successors: %bb.6(0x80000000); %bb.6(100.00%)

464B	  %72:gr64_nosp = MOV32ri64 1
512B	  %76:gr64 = MOV32ri64 1
528B	  JMP_1 %bb.6

544B	bb.4 (%ir-block.12):
	; predecessors: %bb.2
	  successors: %bb.10(0x80000000); %bb.10(100.00%)

608B	  %37.sub_32bit:gr64_nosp = AND32ri %37.sub_32bit:gr64_nosp(tied-def 0), -8, implicit-def dead $eflags
656B	  %37:gr64_nosp = NEG64r %37:gr64_nosp(tied-def 0), implicit-def dead $eflags
672B	  %76:gr64 = MOV32ri64 1
688B	  %72:gr64_nosp = MOV32ri64 8
736B	  JMP_1 %bb.10

752B	bb.5 (%ir-block.15):
	; predecessors: %bb.10
	  successors: %bb.6(0x80000000); %bb.6(100.00%)

784B	  %72:gr64_nosp = ADD64ri32 %72:gr64_nosp(tied-def 0), -7, implicit-def dead $eflags

848B	bb.6 (%ir-block.17):
	; predecessors: %bb.5, %bb.3
	  successors: %bb.9(0x30000000), %bb.7(0x50000000); %bb.9(37.50%), %bb.7(62.50%)

912B	  TEST64rr %71:gr64_with_sub_8bit, %71:gr64_with_sub_8bit, implicit-def $eflags
944B	  JCC_1 %bb.9, 4, implicit killed $eflags
960B	  JMP_1 %bb.7

976B	bb.7 (%ir-block.22):
	; predecessors: %bb.6
	  successors: %bb.8(0x80000000); %bb.8(100.00%)


1040B	bb.8 (%ir-block.23):
	; predecessors: %bb.7, %bb.8
	  successors: %bb.9(0x04000000), %bb.8(0x7c000000); %bb.9(3.12%), %bb.8(96.88%)

1120B	  %76:gr64 = IMUL64rr %76:gr64(tied-def 0), %72:gr64_nosp, implicit-def dead $eflags
1152B	  %72:gr64_nosp = nuw nsw INC64r %72:gr64_nosp(tied-def 0), implicit-def dead $eflags
1184B	  %71:gr64_with_sub_8bit = DEC64r %71:gr64_with_sub_8bit(tied-def 0), implicit-def $eflags
1264B	  JCC_1 %bb.8, 5, implicit killed $eflags
1280B	  JMP_1 %bb.9

1296B	bb.9 (%ir-block.31):
	; predecessors: %bb.6, %bb.8, %bb.1

1328B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
1344B	  %54:gr64 = LEA64r $rip, 1, $noreg, @.str.1, $noreg
1392B	  $rdi = COPY %54:gr64
1408B	  $rsi = COPY %76:gr64
1424B	  dead $eax = MOV32r0 implicit-def dead $eflags, implicit-def $al
1440B	  CALL64pcrel32 target-flags(x86-plt) @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit killed $rsi, implicit killed $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
1456B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
1472B	  $eax = MOV32r0 implicit-def dead $eflags
1488B	  RET 0, killed $eax

1504B	bb.10 (%ir-block.34):
	; predecessors: %bb.4, %bb.10
	  successors: %bb.5(0x04000000), %bb.10(0x7c000000); %bb.5(3.12%), %bb.10(96.88%)

1552B	  %39:gr64 = LEA64r %72:gr64_nosp, 1, $noreg, -7, $noreg
1584B	  %39:gr64 = IMUL64rr %39:gr64(tied-def 0), %76:gr64, implicit-def dead $eflags
1600B	  %43:gr64 = LEA64r %72:gr64_nosp, 1, $noreg, -6, $noreg
1616B	  %42:gr64 = LEA64r %72:gr64_nosp, 1, $noreg, -5, $noreg
1648B	  %43:gr64 = IMUL64rr %43:gr64(tied-def 0), %42:gr64, implicit-def dead $eflags
1680B	  %43:gr64 = IMUL64rr %43:gr64(tied-def 0), %39:gr64, implicit-def dead $eflags
1696B	  %63:gr64 = LEA64r %72:gr64_nosp, 1, $noreg, -4, $noreg
1712B	  %46:gr64 = LEA64r %72:gr64_nosp, 1, $noreg, -3, $noreg
1744B	  %63:gr64 = IMUL64rr %63:gr64(tied-def 0), %46:gr64, implicit-def dead $eflags
1760B	  %49:gr64 = LEA64r %72:gr64_nosp, 1, $noreg, -2, $noreg
1792B	  %49:gr64 = IMUL64rr %49:gr64(tied-def 0), %63:gr64, implicit-def dead $eflags
1824B	  %49:gr64 = IMUL64rr %49:gr64(tied-def 0), %43:gr64, implicit-def dead $eflags
1840B	  %76:gr64 = LEA64r %72:gr64_nosp, 1, $noreg, -1, $noreg
1872B	  %76:gr64 = IMUL64rr %76:gr64(tied-def 0), %72:gr64_nosp, implicit-def dead $eflags
1904B	  %76:gr64 = IMUL64rr %76:gr64(tied-def 0), %49:gr64, implicit-def dead $eflags
1920B	  %52:gr64 = LEA64r %37:gr64_nosp, 1, %72:gr64_nosp, 8, $noreg
1952B	  %72:gr64_nosp = ADD64ri32 %72:gr64_nosp(tied-def 0), 8, implicit-def dead $eflags
1968B	  CMP64ri32 %52:gr64, 8, implicit-def $eflags
2016B	  JCC_1 %bb.5, 4, implicit killed $eflags
2032B	  JMP_1 %bb.10

# End machine code for function main.

# *** IR Dump After Greedy Register Allocator (greedy) ***:
# Machine code for function main: NoPHIs, TracksLiveness, TiedOpsRewritten, TracksDebugUserValues
Frame Objects:
  fi#0: size=4, align=4, at location [SP+8]

0B	bb.0 (%ir-block.0):
	  successors: %bb.1(0x30000000), %bb.2(0x50000000); %bb.1(37.50%), %bb.2(62.50%)

16B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
32B	  %20:gr64 = LEA64r $rip, 1, $noreg, @.str, $noreg
80B	  %23:gr64 = LEA64r %stack.0, 1, $noreg, 0, $noreg
96B	  $rdi = COPY %20:gr64
112B	  $rsi = COPY %23:gr64
128B	  dead $eax = MOV32r0 implicit-def dead $eflags, implicit-def $al
144B	  CALL64pcrel32 target-flags(x86-plt) @__isoc99_scanf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit killed $rsi, implicit killed $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
160B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
176B	  undef %37.sub_32bit:gr64_nosp = MOV32rm %stack.0, 1, $noreg, 0, $noreg :: (dereferenceable load (s32) from %ir.1, !tbaa !5)
224B	  TEST32rr %37.sub_32bit:gr64_nosp, %37.sub_32bit:gr64_nosp, implicit-def $eflags
240B	  JCC_1 %bb.2, 15, implicit killed $eflags

256B	bb.1:
	; predecessors: %bb.0
	  successors: %bb.9(0x80000000); %bb.9(100.00%)

272B	  %76:gr64 = MOV32ri64 1
304B	  JMP_1 %bb.9

320B	bb.2 (%ir-block.6):
	; predecessors: %bb.0
	  successors: %bb.3(0x40000000), %bb.4(0x40000000); %bb.3(50.00%), %bb.4(50.00%)

336B	  %29:gr64 = LEA64r %37:gr64_nosp, 1, $noreg, -1, $noreg
368B	  undef %71.sub_32bit:gr64_with_sub_8bit = COPY %37.sub_32bit:gr64_nosp
384B	  %71.sub_32bit:gr64_with_sub_8bit = AND32ri %71.sub_32bit:gr64_with_sub_8bit(tied-def 0), 7, implicit-def dead $eflags
416B	  CMP64ri32 %29:gr64, 7, implicit-def $eflags
432B	  JCC_1 %bb.4, 3, implicit killed $eflags

448B	bb.3:
	; predecessors: %bb.2
	  successors: %bb.6(0x80000000); %bb.6(100.00%)

464B	  %72:gr64_nosp = MOV32ri64 1
512B	  %76:gr64 = MOV32ri64 1
528B	  JMP_1 %bb.6

544B	bb.4 (%ir-block.12):
	; predecessors: %bb.2
	  successors: %bb.10(0x80000000); %bb.10(100.00%)

608B	  %37.sub_32bit:gr64_nosp = AND32ri %37.sub_32bit:gr64_nosp(tied-def 0), -8, implicit-def dead $eflags
656B	  %37:gr64_nosp = NEG64r %37:gr64_nosp(tied-def 0), implicit-def dead $eflags
672B	  %76:gr64 = MOV32ri64 1
688B	  %72:gr64_nosp = MOV32ri64 8
736B	  JMP_1 %bb.10

752B	bb.5 (%ir-block.15):
	; predecessors: %bb.10
	  successors: %bb.6(0x80000000); %bb.6(100.00%)

784B	  %72:gr64_nosp = ADD64ri32 %72:gr64_nosp(tied-def 0), -7, implicit-def dead $eflags

848B	bb.6 (%ir-block.17):
	; predecessors: %bb.5, %bb.3
	  successors: %bb.9(0x30000000), %bb.7(0x50000000); %bb.9(37.50%), %bb.7(62.50%)

912B	  TEST64rr %71:gr64_with_sub_8bit, %71:gr64_with_sub_8bit, implicit-def $eflags
944B	  JCC_1 %bb.9, 4, implicit killed $eflags
960B	  JMP_1 %bb.7

976B	bb.7 (%ir-block.22):
	; predecessors: %bb.6
	  successors: %bb.8(0x80000000); %bb.8(100.00%)


1040B	bb.8 (%ir-block.23):
	; predecessors: %bb.7, %bb.8
	  successors: %bb.9(0x04000000), %bb.8(0x7c000000); %bb.9(3.12%), %bb.8(96.88%)

1120B	  %76:gr64 = IMUL64rr %76:gr64(tied-def 0), %72:gr64_nosp, implicit-def dead $eflags
1152B	  %72:gr64_nosp = nuw nsw INC64r %72:gr64_nosp(tied-def 0), implicit-def dead $eflags
1184B	  %71:gr64_with_sub_8bit = DEC64r %71:gr64_with_sub_8bit(tied-def 0), implicit-def $eflags
1264B	  JCC_1 %bb.8, 5, implicit killed $eflags
1280B	  JMP_1 %bb.9

1296B	bb.9 (%ir-block.31):
	; predecessors: %bb.6, %bb.8, %bb.1

1328B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
1344B	  %54:gr64 = LEA64r $rip, 1, $noreg, @.str.1, $noreg
1392B	  $rdi = COPY %54:gr64
1408B	  $rsi = COPY %76:gr64
1424B	  dead $eax = MOV32r0 implicit-def dead $eflags, implicit-def $al
1440B	  CALL64pcrel32 target-flags(x86-plt) @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit killed $rsi, implicit killed $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
1456B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
1472B	  $eax = MOV32r0 implicit-def dead $eflags
1488B	  RET 0, killed $eax

1504B	bb.10 (%ir-block.34):
	; predecessors: %bb.4, %bb.10
	  successors: %bb.5(0x04000000), %bb.10(0x7c000000); %bb.5(3.12%), %bb.10(96.88%)

1552B	  %39:gr64 = LEA64r %72:gr64_nosp, 1, $noreg, -7, $noreg
1584B	  %39:gr64 = IMUL64rr %39:gr64(tied-def 0), %76:gr64, implicit-def dead $eflags
1600B	  %43:gr64 = LEA64r %72:gr64_nosp, 1, $noreg, -6, $noreg
1616B	  %42:gr64 = LEA64r %72:gr64_nosp, 1, $noreg, -5, $noreg
1648B	  %43:gr64 = IMUL64rr %43:gr64(tied-def 0), %42:gr64, implicit-def dead $eflags
1680B	  %43:gr64 = IMUL64rr %43:gr64(tied-def 0), %39:gr64, implicit-def dead $eflags
1696B	  %63:gr64 = LEA64r %72:gr64_nosp, 1, $noreg, -4, $noreg
1712B	  %46:gr64 = LEA64r %72:gr64_nosp, 1, $noreg, -3, $noreg
1744B	  %63:gr64 = IMUL64rr %63:gr64(tied-def 0), %46:gr64, implicit-def dead $eflags
1760B	  %49:gr64 = LEA64r %72:gr64_nosp, 1, $noreg, -2, $noreg
1792B	  %49:gr64 = IMUL64rr %49:gr64(tied-def 0), %63:gr64, implicit-def dead $eflags
1824B	  %49:gr64 = IMUL64rr %49:gr64(tied-def 0), %43:gr64, implicit-def dead $eflags
1840B	  %76:gr64 = LEA64r %72:gr64_nosp, 1, $noreg, -1, $noreg
1872B	  %76:gr64 = IMUL64rr %76:gr64(tied-def 0), %72:gr64_nosp, implicit-def dead $eflags
1904B	  %76:gr64 = IMUL64rr %76:gr64(tied-def 0), %49:gr64, implicit-def dead $eflags
1920B	  %52:gr64 = LEA64r %37:gr64_nosp, 1, %72:gr64_nosp, 8, $noreg
1952B	  %72:gr64_nosp = ADD64ri32 %72:gr64_nosp(tied-def 0), 8, implicit-def dead $eflags
1968B	  CMP64ri32 %52:gr64, 8, implicit-def $eflags
2016B	  JCC_1 %bb.5, 4, implicit killed $eflags
2032B	  JMP_1 %bb.10

# End machine code for function main.

# *** IR Dump After Tile Register Configure (tileconfig) ***:
# Machine code for function main: NoPHIs, TracksLiveness, TiedOpsRewritten, TracksDebugUserValues
Frame Objects:
  fi#0: size=4, align=4, at location [SP+8]

0B	bb.0 (%ir-block.0):
	  successors: %bb.1(0x30000000), %bb.2(0x50000000); %bb.1(37.50%), %bb.2(62.50%)

16B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
32B	  %20:gr64 = LEA64r $rip, 1, $noreg, @.str, $noreg
80B	  %23:gr64 = LEA64r %stack.0, 1, $noreg, 0, $noreg
96B	  $rdi = COPY %20:gr64
112B	  $rsi = COPY %23:gr64
128B	  dead $eax = MOV32r0 implicit-def dead $eflags, implicit-def $al
144B	  CALL64pcrel32 target-flags(x86-plt) @__isoc99_scanf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit killed $rsi, implicit killed $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
160B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
176B	  undef %37.sub_32bit:gr64_nosp = MOV32rm %stack.0, 1, $noreg, 0, $noreg :: (dereferenceable load (s32) from %ir.1, !tbaa !5)
224B	  TEST32rr %37.sub_32bit:gr64_nosp, %37.sub_32bit:gr64_nosp, implicit-def $eflags
240B	  JCC_1 %bb.2, 15, implicit killed $eflags

256B	bb.1:
	; predecessors: %bb.0
	  successors: %bb.9(0x80000000); %bb.9(100.00%)

272B	  %76:gr64 = MOV32ri64 1
304B	  JMP_1 %bb.9

320B	bb.2 (%ir-block.6):
	; predecessors: %bb.0
	  successors: %bb.3(0x40000000), %bb.4(0x40000000); %bb.3(50.00%), %bb.4(50.00%)

336B	  %29:gr64 = LEA64r %37:gr64_nosp, 1, $noreg, -1, $noreg
368B	  undef %71.sub_32bit:gr64_with_sub_8bit = COPY %37.sub_32bit:gr64_nosp
384B	  %71.sub_32bit:gr64_with_sub_8bit = AND32ri %71.sub_32bit:gr64_with_sub_8bit(tied-def 0), 7, implicit-def dead $eflags
416B	  CMP64ri32 %29:gr64, 7, implicit-def $eflags
432B	  JCC_1 %bb.4, 3, implicit killed $eflags

448B	bb.3:
	; predecessors: %bb.2
	  successors: %bb.6(0x80000000); %bb.6(100.00%)

464B	  %72:gr64_nosp = MOV32ri64 1
512B	  %76:gr64 = MOV32ri64 1
528B	  JMP_1 %bb.6

544B	bb.4 (%ir-block.12):
	; predecessors: %bb.2
	  successors: %bb.10(0x80000000); %bb.10(100.00%)

608B	  %37.sub_32bit:gr64_nosp = AND32ri %37.sub_32bit:gr64_nosp(tied-def 0), -8, implicit-def dead $eflags
656B	  %37:gr64_nosp = NEG64r %37:gr64_nosp(tied-def 0), implicit-def dead $eflags
672B	  %76:gr64 = MOV32ri64 1
688B	  %72:gr64_nosp = MOV32ri64 8
736B	  JMP_1 %bb.10

752B	bb.5 (%ir-block.15):
	; predecessors: %bb.10
	  successors: %bb.6(0x80000000); %bb.6(100.00%)

784B	  %72:gr64_nosp = ADD64ri32 %72:gr64_nosp(tied-def 0), -7, implicit-def dead $eflags

848B	bb.6 (%ir-block.17):
	; predecessors: %bb.5, %bb.3
	  successors: %bb.9(0x30000000), %bb.7(0x50000000); %bb.9(37.50%), %bb.7(62.50%)

912B	  TEST64rr %71:gr64_with_sub_8bit, %71:gr64_with_sub_8bit, implicit-def $eflags
944B	  JCC_1 %bb.9, 4, implicit killed $eflags
960B	  JMP_1 %bb.7

976B	bb.7 (%ir-block.22):
	; predecessors: %bb.6
	  successors: %bb.8(0x80000000); %bb.8(100.00%)


1040B	bb.8 (%ir-block.23):
	; predecessors: %bb.7, %bb.8
	  successors: %bb.9(0x04000000), %bb.8(0x7c000000); %bb.9(3.12%), %bb.8(96.88%)

1120B	  %76:gr64 = IMUL64rr %76:gr64(tied-def 0), %72:gr64_nosp, implicit-def dead $eflags
1152B	  %72:gr64_nosp = nuw nsw INC64r %72:gr64_nosp(tied-def 0), implicit-def dead $eflags
1184B	  %71:gr64_with_sub_8bit = DEC64r %71:gr64_with_sub_8bit(tied-def 0), implicit-def $eflags
1264B	  JCC_1 %bb.8, 5, implicit killed $eflags
1280B	  JMP_1 %bb.9

1296B	bb.9 (%ir-block.31):
	; predecessors: %bb.6, %bb.8, %bb.1

1328B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
1344B	  %54:gr64 = LEA64r $rip, 1, $noreg, @.str.1, $noreg
1392B	  $rdi = COPY %54:gr64
1408B	  $rsi = COPY %76:gr64
1424B	  dead $eax = MOV32r0 implicit-def dead $eflags, implicit-def $al
1440B	  CALL64pcrel32 target-flags(x86-plt) @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit killed $rsi, implicit killed $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
1456B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
1472B	  $eax = MOV32r0 implicit-def dead $eflags
1488B	  RET 0, killed $eax

1504B	bb.10 (%ir-block.34):
	; predecessors: %bb.4, %bb.10
	  successors: %bb.5(0x04000000), %bb.10(0x7c000000); %bb.5(3.12%), %bb.10(96.88%)

1552B	  %39:gr64 = LEA64r %72:gr64_nosp, 1, $noreg, -7, $noreg
1584B	  %39:gr64 = IMUL64rr %39:gr64(tied-def 0), %76:gr64, implicit-def dead $eflags
1600B	  %43:gr64 = LEA64r %72:gr64_nosp, 1, $noreg, -6, $noreg
1616B	  %42:gr64 = LEA64r %72:gr64_nosp, 1, $noreg, -5, $noreg
1648B	  %43:gr64 = IMUL64rr %43:gr64(tied-def 0), %42:gr64, implicit-def dead $eflags
1680B	  %43:gr64 = IMUL64rr %43:gr64(tied-def 0), %39:gr64, implicit-def dead $eflags
1696B	  %63:gr64 = LEA64r %72:gr64_nosp, 1, $noreg, -4, $noreg
1712B	  %46:gr64 = LEA64r %72:gr64_nosp, 1, $noreg, -3, $noreg
1744B	  %63:gr64 = IMUL64rr %63:gr64(tied-def 0), %46:gr64, implicit-def dead $eflags
1760B	  %49:gr64 = LEA64r %72:gr64_nosp, 1, $noreg, -2, $noreg
1792B	  %49:gr64 = IMUL64rr %49:gr64(tied-def 0), %63:gr64, implicit-def dead $eflags
1824B	  %49:gr64 = IMUL64rr %49:gr64(tied-def 0), %43:gr64, implicit-def dead $eflags
1840B	  %76:gr64 = LEA64r %72:gr64_nosp, 1, $noreg, -1, $noreg
1872B	  %76:gr64 = IMUL64rr %76:gr64(tied-def 0), %72:gr64_nosp, implicit-def dead $eflags
1904B	  %76:gr64 = IMUL64rr %76:gr64(tied-def 0), %49:gr64, implicit-def dead $eflags
1920B	  %52:gr64 = LEA64r %37:gr64_nosp, 1, %72:gr64_nosp, 8, $noreg
1952B	  %72:gr64_nosp = ADD64ri32 %72:gr64_nosp(tied-def 0), 8, implicit-def dead $eflags
1968B	  CMP64ri32 %52:gr64, 8, implicit-def $eflags
2016B	  JCC_1 %bb.5, 4, implicit killed $eflags
2032B	  JMP_1 %bb.10

# End machine code for function main.

# *** IR Dump After Greedy Register Allocator (greedy) ***:
# Machine code for function main: NoPHIs, TracksLiveness, TiedOpsRewritten, TracksDebugUserValues
Frame Objects:
  fi#0: size=4, align=4, at location [SP+8]

0B	bb.0 (%ir-block.0):
	  successors: %bb.1(0x30000000), %bb.2(0x50000000); %bb.1(37.50%), %bb.2(62.50%)

16B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
32B	  %20:gr64 = LEA64r $rip, 1, $noreg, @.str, $noreg
80B	  %23:gr64 = LEA64r %stack.0, 1, $noreg, 0, $noreg
96B	  $rdi = COPY %20:gr64
112B	  $rsi = COPY %23:gr64
128B	  dead $eax = MOV32r0 implicit-def dead $eflags, implicit-def $al
144B	  CALL64pcrel32 target-flags(x86-plt) @__isoc99_scanf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
160B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
176B	  undef %37.sub_32bit:gr64_nosp = MOV32rm %stack.0, 1, $noreg, 0, $noreg :: (dereferenceable load (s32) from %ir.1, !tbaa !5)
224B	  TEST32rr %37.sub_32bit:gr64_nosp, %37.sub_32bit:gr64_nosp, implicit-def $eflags
240B	  JCC_1 %bb.2, 15, implicit killed $eflags

256B	bb.1:
	; predecessors: %bb.0
	  successors: %bb.9(0x80000000); %bb.9(100.00%)

272B	  %76:gr64 = MOV32ri64 1
304B	  JMP_1 %bb.9

320B	bb.2 (%ir-block.6):
	; predecessors: %bb.0
	  successors: %bb.3(0x40000000), %bb.4(0x40000000); %bb.3(50.00%), %bb.4(50.00%)

336B	  %29:gr64 = LEA64r %37:gr64_nosp, 1, $noreg, -1, $noreg
368B	  undef %71.sub_32bit:gr64_with_sub_8bit = COPY %37.sub_32bit:gr64_nosp
384B	  %71.sub_32bit:gr64_with_sub_8bit = AND32ri %71.sub_32bit:gr64_with_sub_8bit(tied-def 0), 7, implicit-def dead $eflags
416B	  CMP64ri32 %29:gr64, 7, implicit-def $eflags
432B	  JCC_1 %bb.4, 3, implicit killed $eflags

448B	bb.3:
	; predecessors: %bb.2
	  successors: %bb.6(0x80000000); %bb.6(100.00%)

464B	  %72:gr64_nosp = MOV32ri64 1
512B	  %76:gr64 = MOV32ri64 1
528B	  JMP_1 %bb.6

544B	bb.4 (%ir-block.12):
	; predecessors: %bb.2
	  successors: %bb.10(0x80000000); %bb.10(100.00%)

608B	  %37.sub_32bit:gr64_nosp = AND32ri %37.sub_32bit:gr64_nosp(tied-def 0), -8, implicit-def dead $eflags
656B	  %37:gr64_nosp = NEG64r %37:gr64_nosp(tied-def 0), implicit-def dead $eflags
672B	  %76:gr64 = MOV32ri64 1
688B	  %72:gr64_nosp = MOV32ri64 8
736B	  JMP_1 %bb.10

752B	bb.5 (%ir-block.15):
	; predecessors: %bb.10
	  successors: %bb.6(0x80000000); %bb.6(100.00%)

784B	  %72:gr64_nosp = ADD64ri32 %72:gr64_nosp(tied-def 0), -7, implicit-def dead $eflags

848B	bb.6 (%ir-block.17):
	; predecessors: %bb.5, %bb.3
	  successors: %bb.9(0x30000000), %bb.7(0x50000000); %bb.9(37.50%), %bb.7(62.50%)

912B	  TEST64rr %71:gr64_with_sub_8bit, %71:gr64_with_sub_8bit, implicit-def $eflags
944B	  JCC_1 %bb.9, 4, implicit killed $eflags
960B	  JMP_1 %bb.7

976B	bb.7 (%ir-block.22):
	; predecessors: %bb.6
	  successors: %bb.8(0x80000000); %bb.8(100.00%)


1040B	bb.8 (%ir-block.23):
	; predecessors: %bb.7, %bb.8
	  successors: %bb.9(0x04000000), %bb.8(0x7c000000); %bb.9(3.12%), %bb.8(96.88%)

1120B	  %76:gr64 = IMUL64rr %76:gr64(tied-def 0), %72:gr64_nosp, implicit-def dead $eflags
1152B	  %72:gr64_nosp = nuw nsw INC64r %72:gr64_nosp(tied-def 0), implicit-def dead $eflags
1184B	  %71:gr64_with_sub_8bit = DEC64r %71:gr64_with_sub_8bit(tied-def 0), implicit-def $eflags
1264B	  JCC_1 %bb.8, 5, implicit killed $eflags
1280B	  JMP_1 %bb.9

1296B	bb.9 (%ir-block.31):
	; predecessors: %bb.6, %bb.8, %bb.1

1328B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
1344B	  %54:gr64 = LEA64r $rip, 1, $noreg, @.str.1, $noreg
1392B	  $rdi = COPY %54:gr64
1408B	  $rsi = COPY %76:gr64
1424B	  dead $eax = MOV32r0 implicit-def dead $eflags, implicit-def $al
1440B	  CALL64pcrel32 target-flags(x86-plt) @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
1456B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
1472B	  $eax = MOV32r0 implicit-def dead $eflags
1488B	  RET 0, $eax

1504B	bb.10 (%ir-block.34):
	; predecessors: %bb.4, %bb.10
	  successors: %bb.5(0x04000000), %bb.10(0x7c000000); %bb.5(3.12%), %bb.10(96.88%)

1552B	  %39:gr64 = LEA64r %72:gr64_nosp, 1, $noreg, -7, $noreg
1584B	  %39:gr64 = IMUL64rr %39:gr64(tied-def 0), %76:gr64, implicit-def dead $eflags
1600B	  %43:gr64 = LEA64r %72:gr64_nosp, 1, $noreg, -6, $noreg
1616B	  %42:gr64 = LEA64r %72:gr64_nosp, 1, $noreg, -5, $noreg
1648B	  %43:gr64 = IMUL64rr %43:gr64(tied-def 0), %42:gr64, implicit-def dead $eflags
1680B	  %43:gr64 = IMUL64rr %43:gr64(tied-def 0), %39:gr64, implicit-def dead $eflags
1696B	  %63:gr64 = LEA64r %72:gr64_nosp, 1, $noreg, -4, $noreg
1712B	  %46:gr64 = LEA64r %72:gr64_nosp, 1, $noreg, -3, $noreg
1744B	  %63:gr64 = IMUL64rr %63:gr64(tied-def 0), %46:gr64, implicit-def dead $eflags
1760B	  %49:gr64 = LEA64r %72:gr64_nosp, 1, $noreg, -2, $noreg
1792B	  %49:gr64 = IMUL64rr %49:gr64(tied-def 0), %63:gr64, implicit-def dead $eflags
1824B	  %49:gr64 = IMUL64rr %49:gr64(tied-def 0), %43:gr64, implicit-def dead $eflags
1840B	  %76:gr64 = LEA64r %72:gr64_nosp, 1, $noreg, -1, $noreg
1872B	  %76:gr64 = IMUL64rr %76:gr64(tied-def 0), %72:gr64_nosp, implicit-def dead $eflags
1904B	  %76:gr64 = IMUL64rr %76:gr64(tied-def 0), %49:gr64, implicit-def dead $eflags
1920B	  %52:gr64 = LEA64r %37:gr64_nosp, 1, %72:gr64_nosp, 8, $noreg
1952B	  %72:gr64_nosp = ADD64ri32 %72:gr64_nosp(tied-def 0), 8, implicit-def dead $eflags
1968B	  CMP64ri32 %52:gr64, 8, implicit-def $eflags
2016B	  JCC_1 %bb.5, 4, implicit killed $eflags
2032B	  JMP_1 %bb.10

# End machine code for function main.

# *** IR Dump After Virtual Register Rewriter (virtregrewriter) ***:
# Machine code for function main: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
Frame Objects:
  fi#0: size=4, align=4, at location [SP+8]

0B	bb.0 (%ir-block.0):
	  successors: %bb.1(0x30000000), %bb.2(0x50000000); %bb.1(37.50%), %bb.2(62.50%)

16B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
32B	  renamable $rdi = LEA64r $rip, 1, $noreg, @.str, $noreg
80B	  renamable $rsi = LEA64r %stack.0, 1, $noreg, 0, $noreg
128B	  dead $eax = MOV32r0 implicit-def dead $eflags, implicit-def $al
144B	  CALL64pcrel32 target-flags(x86-plt) @__isoc99_scanf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
160B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
176B	  renamable $edx = MOV32rm %stack.0, 1, $noreg, 0, $noreg, implicit-def $rdx :: (dereferenceable load (s32) from %ir.1, !tbaa !5)
224B	  TEST32rr renamable $edx, renamable $edx, implicit-def $eflags
240B	  JCC_1 %bb.2, 15, implicit killed $eflags

256B	bb.1:
	; predecessors: %bb.0
	  successors: %bb.9(0x80000000); %bb.9(100.00%)

272B	  renamable $rsi = MOV32ri64 1
304B	  JMP_1 %bb.9

320B	bb.2 (%ir-block.6):
	; predecessors: %bb.0
	  successors: %bb.3(0x40000000), %bb.4(0x40000000); %bb.3(50.00%), %bb.4(50.00%)
	  liveins: $rdx
336B	  renamable $rcx = LEA64r renamable $rdx, 1, $noreg, -1, $noreg
368B	  renamable $eax = COPY renamable $edx, implicit-def $rax
384B	  renamable $eax = AND32ri renamable $eax(tied-def 0), 7, implicit-def dead $eflags, implicit killed $rax, implicit-def $rax
416B	  CMP64ri32 killed renamable $rcx, 7, implicit-def $eflags
432B	  JCC_1 %bb.4, 3, implicit killed $eflags

448B	bb.3:
	; predecessors: %bb.2
	  successors: %bb.6(0x80000000); %bb.6(100.00%)
	  liveins: $rax
464B	  renamable $rcx = MOV32ri64 1
512B	  renamable $rsi = MOV32ri64 1
528B	  JMP_1 %bb.6

544B	bb.4 (%ir-block.12):
	; predecessors: %bb.2
	  successors: %bb.10(0x80000000); %bb.10(100.00%)
	  liveins: $rax, $rdx
608B	  renamable $edx = AND32ri renamable $edx(tied-def 0), -8, implicit-def dead $eflags, implicit killed $rdx, implicit-def $rdx
656B	  renamable $rdx = NEG64r killed renamable $rdx(tied-def 0), implicit-def dead $eflags
672B	  renamable $rsi = MOV32ri64 1
688B	  renamable $rcx = MOV32ri64 8
736B	  JMP_1 %bb.10

752B	bb.5 (%ir-block.15):
	; predecessors: %bb.10
	  successors: %bb.6(0x80000000); %bb.6(100.00%)
	  liveins: $rax, $rcx, $rsi
784B	  renamable $rcx = ADD64ri32 killed renamable $rcx(tied-def 0), -7, implicit-def dead $eflags

848B	bb.6 (%ir-block.17):
	; predecessors: %bb.5, %bb.3
	  successors: %bb.9(0x30000000), %bb.7(0x50000000); %bb.9(37.50%), %bb.7(62.50%)
	  liveins: $rax, $rcx, $rsi
912B	  TEST64rr renamable $rax, renamable $rax, implicit-def $eflags
944B	  JCC_1 %bb.9, 4, implicit killed $eflags
960B	  JMP_1 %bb.7

976B	bb.7 (%ir-block.22):
	; predecessors: %bb.6
	  successors: %bb.8(0x80000000); %bb.8(100.00%)
	  liveins: $rax, $rcx, $rsi

1040B	bb.8 (%ir-block.23):
	; predecessors: %bb.7, %bb.8
	  successors: %bb.9(0x04000000), %bb.8(0x7c000000); %bb.9(3.12%), %bb.8(96.88%)
	  liveins: $rax, $rcx, $rsi
1120B	  renamable $rsi = IMUL64rr killed renamable $rsi(tied-def 0), renamable $rcx, implicit-def dead $eflags
1152B	  renamable $rcx = nuw nsw INC64r killed renamable $rcx(tied-def 0), implicit-def dead $eflags
1184B	  renamable $rax = DEC64r killed renamable $rax(tied-def 0), implicit-def $eflags
1264B	  JCC_1 %bb.8, 5, implicit killed $eflags
1280B	  JMP_1 %bb.9

1296B	bb.9 (%ir-block.31):
	; predecessors: %bb.6, %bb.8, %bb.1
	  liveins: $rsi
1328B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
1344B	  renamable $rdi = LEA64r $rip, 1, $noreg, @.str.1, $noreg
1424B	  dead $eax = MOV32r0 implicit-def dead $eflags, implicit-def $al
1440B	  CALL64pcrel32 target-flags(x86-plt) @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
1456B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
1472B	  $eax = MOV32r0 implicit-def dead $eflags
1488B	  RET 0, $eax

1504B	bb.10 (%ir-block.34):
	; predecessors: %bb.4, %bb.10
	  successors: %bb.5(0x04000000), %bb.10(0x7c000000); %bb.5(3.12%), %bb.10(96.88%)
	  liveins: $rax, $rcx, $rdx, $rsi
1552B	  renamable $rdi = LEA64r renamable $rcx, 1, $noreg, -7, $noreg
1584B	  renamable $rdi = IMUL64rr killed renamable $rdi(tied-def 0), killed renamable $rsi, implicit-def dead $eflags
1600B	  renamable $rsi = LEA64r renamable $rcx, 1, $noreg, -6, $noreg
1616B	  renamable $r8 = LEA64r renamable $rcx, 1, $noreg, -5, $noreg
1648B	  renamable $rsi = IMUL64rr killed renamable $rsi(tied-def 0), killed renamable $r8, implicit-def dead $eflags
1680B	  renamable $rsi = IMUL64rr killed renamable $rsi(tied-def 0), killed renamable $rdi, implicit-def dead $eflags
1696B	  renamable $rdi = LEA64r renamable $rcx, 1, $noreg, -4, $noreg
1712B	  renamable $r8 = LEA64r renamable $rcx, 1, $noreg, -3, $noreg
1744B	  renamable $rdi = IMUL64rr killed renamable $rdi(tied-def 0), killed renamable $r8, implicit-def dead $eflags
1760B	  renamable $r8 = LEA64r renamable $rcx, 1, $noreg, -2, $noreg
1792B	  renamable $r8 = IMUL64rr killed renamable $r8(tied-def 0), killed renamable $rdi, implicit-def dead $eflags
1824B	  renamable $r8 = IMUL64rr killed renamable $r8(tied-def 0), killed renamable $rsi, implicit-def dead $eflags
1840B	  renamable $rsi = LEA64r renamable $rcx, 1, $noreg, -1, $noreg
1872B	  renamable $rsi = IMUL64rr killed renamable $rsi(tied-def 0), renamable $rcx, implicit-def dead $eflags
1904B	  renamable $rsi = IMUL64rr killed renamable $rsi(tied-def 0), killed renamable $r8, implicit-def dead $eflags
1920B	  renamable $rdi = LEA64r renamable $rdx, 1, renamable $rcx, 8, $noreg
1952B	  renamable $rcx = ADD64ri32 killed renamable $rcx(tied-def 0), 8, implicit-def dead $eflags
1968B	  CMP64ri32 killed renamable $rdi, 8, implicit-def $eflags
2016B	  JCC_1 %bb.5, 4, implicit killed $eflags
2032B	  JMP_1 %bb.10

# End machine code for function main.

# *** IR Dump After Register Allocation Pass Scoring (regallocscoringpass) ***:
# Machine code for function main: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
Frame Objects:
  fi#0: size=4, align=4, at location [SP+8]

0B	bb.0 (%ir-block.0):
	  successors: %bb.1(0x30000000), %bb.2(0x50000000); %bb.1(37.50%), %bb.2(62.50%)

16B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
32B	  renamable $rdi = LEA64r $rip, 1, $noreg, @.str, $noreg
80B	  renamable $rsi = LEA64r %stack.0, 1, $noreg, 0, $noreg
128B	  dead $eax = MOV32r0 implicit-def dead $eflags, implicit-def $al
144B	  CALL64pcrel32 target-flags(x86-plt) @__isoc99_scanf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
160B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
176B	  renamable $edx = MOV32rm %stack.0, 1, $noreg, 0, $noreg, implicit-def $rdx :: (dereferenceable load (s32) from %ir.1, !tbaa !5)
224B	  TEST32rr renamable $edx, renamable $edx, implicit-def $eflags
240B	  JCC_1 %bb.2, 15, implicit killed $eflags

256B	bb.1:
	; predecessors: %bb.0
	  successors: %bb.9(0x80000000); %bb.9(100.00%)

272B	  renamable $rsi = MOV32ri64 1
304B	  JMP_1 %bb.9

320B	bb.2 (%ir-block.6):
	; predecessors: %bb.0
	  successors: %bb.3(0x40000000), %bb.4(0x40000000); %bb.3(50.00%), %bb.4(50.00%)
	  liveins: $rdx
336B	  renamable $rcx = LEA64r renamable $rdx, 1, $noreg, -1, $noreg
368B	  renamable $eax = COPY renamable $edx, implicit-def $rax
384B	  renamable $eax = AND32ri renamable $eax(tied-def 0), 7, implicit-def dead $eflags, implicit killed $rax, implicit-def $rax
416B	  CMP64ri32 killed renamable $rcx, 7, implicit-def $eflags
432B	  JCC_1 %bb.4, 3, implicit killed $eflags

448B	bb.3:
	; predecessors: %bb.2
	  successors: %bb.6(0x80000000); %bb.6(100.00%)
	  liveins: $rax
464B	  renamable $rcx = MOV32ri64 1
512B	  renamable $rsi = MOV32ri64 1
528B	  JMP_1 %bb.6

544B	bb.4 (%ir-block.12):
	; predecessors: %bb.2
	  successors: %bb.10(0x80000000); %bb.10(100.00%)
	  liveins: $rax, $rdx
608B	  renamable $edx = AND32ri renamable $edx(tied-def 0), -8, implicit-def dead $eflags, implicit killed $rdx, implicit-def $rdx
656B	  renamable $rdx = NEG64r killed renamable $rdx(tied-def 0), implicit-def dead $eflags
672B	  renamable $rsi = MOV32ri64 1
688B	  renamable $rcx = MOV32ri64 8
736B	  JMP_1 %bb.10

752B	bb.5 (%ir-block.15):
	; predecessors: %bb.10
	  successors: %bb.6(0x80000000); %bb.6(100.00%)
	  liveins: $rax, $rcx, $rsi
784B	  renamable $rcx = ADD64ri32 killed renamable $rcx(tied-def 0), -7, implicit-def dead $eflags

848B	bb.6 (%ir-block.17):
	; predecessors: %bb.5, %bb.3
	  successors: %bb.9(0x30000000), %bb.7(0x50000000); %bb.9(37.50%), %bb.7(62.50%)
	  liveins: $rax, $rcx, $rsi
912B	  TEST64rr renamable $rax, renamable $rax, implicit-def $eflags
944B	  JCC_1 %bb.9, 4, implicit killed $eflags
960B	  JMP_1 %bb.7

976B	bb.7 (%ir-block.22):
	; predecessors: %bb.6
	  successors: %bb.8(0x80000000); %bb.8(100.00%)
	  liveins: $rax, $rcx, $rsi

1040B	bb.8 (%ir-block.23):
	; predecessors: %bb.7, %bb.8
	  successors: %bb.9(0x04000000), %bb.8(0x7c000000); %bb.9(3.12%), %bb.8(96.88%)
	  liveins: $rax, $rcx, $rsi
1120B	  renamable $rsi = IMUL64rr killed renamable $rsi(tied-def 0), renamable $rcx, implicit-def dead $eflags
1152B	  renamable $rcx = nuw nsw INC64r killed renamable $rcx(tied-def 0), implicit-def dead $eflags
1184B	  renamable $rax = DEC64r killed renamable $rax(tied-def 0), implicit-def $eflags
1264B	  JCC_1 %bb.8, 5, implicit killed $eflags
1280B	  JMP_1 %bb.9

1296B	bb.9 (%ir-block.31):
	; predecessors: %bb.6, %bb.8, %bb.1
	  liveins: $rsi
1328B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
1344B	  renamable $rdi = LEA64r $rip, 1, $noreg, @.str.1, $noreg
1424B	  dead $eax = MOV32r0 implicit-def dead $eflags, implicit-def $al
1440B	  CALL64pcrel32 target-flags(x86-plt) @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
1456B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
1472B	  $eax = MOV32r0 implicit-def dead $eflags
1488B	  RET 0, $eax

1504B	bb.10 (%ir-block.34):
	; predecessors: %bb.4, %bb.10
	  successors: %bb.5(0x04000000), %bb.10(0x7c000000); %bb.5(3.12%), %bb.10(96.88%)
	  liveins: $rax, $rcx, $rdx, $rsi
1552B	  renamable $rdi = LEA64r renamable $rcx, 1, $noreg, -7, $noreg
1584B	  renamable $rdi = IMUL64rr killed renamable $rdi(tied-def 0), killed renamable $rsi, implicit-def dead $eflags
1600B	  renamable $rsi = LEA64r renamable $rcx, 1, $noreg, -6, $noreg
1616B	  renamable $r8 = LEA64r renamable $rcx, 1, $noreg, -5, $noreg
1648B	  renamable $rsi = IMUL64rr killed renamable $rsi(tied-def 0), killed renamable $r8, implicit-def dead $eflags
1680B	  renamable $rsi = IMUL64rr killed renamable $rsi(tied-def 0), killed renamable $rdi, implicit-def dead $eflags
1696B	  renamable $rdi = LEA64r renamable $rcx, 1, $noreg, -4, $noreg
1712B	  renamable $r8 = LEA64r renamable $rcx, 1, $noreg, -3, $noreg
1744B	  renamable $rdi = IMUL64rr killed renamable $rdi(tied-def 0), killed renamable $r8, implicit-def dead $eflags
1760B	  renamable $r8 = LEA64r renamable $rcx, 1, $noreg, -2, $noreg
1792B	  renamable $r8 = IMUL64rr killed renamable $r8(tied-def 0), killed renamable $rdi, implicit-def dead $eflags
1824B	  renamable $r8 = IMUL64rr killed renamable $r8(tied-def 0), killed renamable $rsi, implicit-def dead $eflags
1840B	  renamable $rsi = LEA64r renamable $rcx, 1, $noreg, -1, $noreg
1872B	  renamable $rsi = IMUL64rr killed renamable $rsi(tied-def 0), renamable $rcx, implicit-def dead $eflags
1904B	  renamable $rsi = IMUL64rr killed renamable $rsi(tied-def 0), killed renamable $r8, implicit-def dead $eflags
1920B	  renamable $rdi = LEA64r renamable $rdx, 1, renamable $rcx, 8, $noreg
1952B	  renamable $rcx = ADD64ri32 killed renamable $rcx(tied-def 0), 8, implicit-def dead $eflags
1968B	  CMP64ri32 killed renamable $rdi, 8, implicit-def $eflags
2016B	  JCC_1 %bb.5, 4, implicit killed $eflags
2032B	  JMP_1 %bb.10

# End machine code for function main.

# *** IR Dump After Stack Slot Coloring (stack-slot-coloring) ***:
# Machine code for function main: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
Frame Objects:
  fi#0: size=4, align=4, at location [SP+8]

0B	bb.0 (%ir-block.0):
	  successors: %bb.1(0x30000000), %bb.2(0x50000000); %bb.1(37.50%), %bb.2(62.50%)

16B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
32B	  renamable $rdi = LEA64r $rip, 1, $noreg, @.str, $noreg
80B	  renamable $rsi = LEA64r %stack.0, 1, $noreg, 0, $noreg
128B	  dead $eax = MOV32r0 implicit-def dead $eflags, implicit-def $al
144B	  CALL64pcrel32 target-flags(x86-plt) @__isoc99_scanf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
160B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
176B	  renamable $edx = MOV32rm %stack.0, 1, $noreg, 0, $noreg, implicit-def $rdx :: (dereferenceable load (s32) from %ir.1, !tbaa !5)
224B	  TEST32rr renamable $edx, renamable $edx, implicit-def $eflags
240B	  JCC_1 %bb.2, 15, implicit killed $eflags

256B	bb.1:
	; predecessors: %bb.0
	  successors: %bb.9(0x80000000); %bb.9(100.00%)

272B	  renamable $rsi = MOV32ri64 1
304B	  JMP_1 %bb.9

320B	bb.2 (%ir-block.6):
	; predecessors: %bb.0
	  successors: %bb.3(0x40000000), %bb.4(0x40000000); %bb.3(50.00%), %bb.4(50.00%)
	  liveins: $rdx
336B	  renamable $rcx = LEA64r renamable $rdx, 1, $noreg, -1, $noreg
368B	  renamable $eax = COPY renamable $edx, implicit-def $rax
384B	  renamable $eax = AND32ri renamable $eax(tied-def 0), 7, implicit-def dead $eflags, implicit killed $rax, implicit-def $rax
416B	  CMP64ri32 killed renamable $rcx, 7, implicit-def $eflags
432B	  JCC_1 %bb.4, 3, implicit killed $eflags

448B	bb.3:
	; predecessors: %bb.2
	  successors: %bb.6(0x80000000); %bb.6(100.00%)
	  liveins: $rax
464B	  renamable $rcx = MOV32ri64 1
512B	  renamable $rsi = MOV32ri64 1
528B	  JMP_1 %bb.6

544B	bb.4 (%ir-block.12):
	; predecessors: %bb.2
	  successors: %bb.10(0x80000000); %bb.10(100.00%)
	  liveins: $rax, $rdx
608B	  renamable $edx = AND32ri renamable $edx(tied-def 0), -8, implicit-def dead $eflags, implicit killed $rdx, implicit-def $rdx
656B	  renamable $rdx = NEG64r killed renamable $rdx(tied-def 0), implicit-def dead $eflags
672B	  renamable $rsi = MOV32ri64 1
688B	  renamable $rcx = MOV32ri64 8
736B	  JMP_1 %bb.10

752B	bb.5 (%ir-block.15):
	; predecessors: %bb.10
	  successors: %bb.6(0x80000000); %bb.6(100.00%)
	  liveins: $rax, $rcx, $rsi
784B	  renamable $rcx = ADD64ri32 killed renamable $rcx(tied-def 0), -7, implicit-def dead $eflags

848B	bb.6 (%ir-block.17):
	; predecessors: %bb.5, %bb.3
	  successors: %bb.9(0x30000000), %bb.7(0x50000000); %bb.9(37.50%), %bb.7(62.50%)
	  liveins: $rax, $rcx, $rsi
912B	  TEST64rr renamable $rax, renamable $rax, implicit-def $eflags
944B	  JCC_1 %bb.9, 4, implicit killed $eflags
960B	  JMP_1 %bb.7

976B	bb.7 (%ir-block.22):
	; predecessors: %bb.6
	  successors: %bb.8(0x80000000); %bb.8(100.00%)
	  liveins: $rax, $rcx, $rsi

1040B	bb.8 (%ir-block.23):
	; predecessors: %bb.7, %bb.8
	  successors: %bb.9(0x04000000), %bb.8(0x7c000000); %bb.9(3.12%), %bb.8(96.88%)
	  liveins: $rax, $rcx, $rsi
1120B	  renamable $rsi = IMUL64rr killed renamable $rsi(tied-def 0), renamable $rcx, implicit-def dead $eflags
1152B	  renamable $rcx = nuw nsw INC64r killed renamable $rcx(tied-def 0), implicit-def dead $eflags
1184B	  renamable $rax = DEC64r killed renamable $rax(tied-def 0), implicit-def $eflags
1264B	  JCC_1 %bb.8, 5, implicit killed $eflags
1280B	  JMP_1 %bb.9

1296B	bb.9 (%ir-block.31):
	; predecessors: %bb.6, %bb.8, %bb.1
	  liveins: $rsi
1328B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
1344B	  renamable $rdi = LEA64r $rip, 1, $noreg, @.str.1, $noreg
1424B	  dead $eax = MOV32r0 implicit-def dead $eflags, implicit-def $al
1440B	  CALL64pcrel32 target-flags(x86-plt) @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
1456B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
1472B	  $eax = MOV32r0 implicit-def dead $eflags
1488B	  RET 0, $eax

1504B	bb.10 (%ir-block.34):
	; predecessors: %bb.4, %bb.10
	  successors: %bb.5(0x04000000), %bb.10(0x7c000000); %bb.5(3.12%), %bb.10(96.88%)
	  liveins: $rax, $rcx, $rdx, $rsi
1552B	  renamable $rdi = LEA64r renamable $rcx, 1, $noreg, -7, $noreg
1584B	  renamable $rdi = IMUL64rr killed renamable $rdi(tied-def 0), killed renamable $rsi, implicit-def dead $eflags
1600B	  renamable $rsi = LEA64r renamable $rcx, 1, $noreg, -6, $noreg
1616B	  renamable $r8 = LEA64r renamable $rcx, 1, $noreg, -5, $noreg
1648B	  renamable $rsi = IMUL64rr killed renamable $rsi(tied-def 0), killed renamable $r8, implicit-def dead $eflags
1680B	  renamable $rsi = IMUL64rr killed renamable $rsi(tied-def 0), killed renamable $rdi, implicit-def dead $eflags
1696B	  renamable $rdi = LEA64r renamable $rcx, 1, $noreg, -4, $noreg
1712B	  renamable $r8 = LEA64r renamable $rcx, 1, $noreg, -3, $noreg
1744B	  renamable $rdi = IMUL64rr killed renamable $rdi(tied-def 0), killed renamable $r8, implicit-def dead $eflags
1760B	  renamable $r8 = LEA64r renamable $rcx, 1, $noreg, -2, $noreg
1792B	  renamable $r8 = IMUL64rr killed renamable $r8(tied-def 0), killed renamable $rdi, implicit-def dead $eflags
1824B	  renamable $r8 = IMUL64rr killed renamable $r8(tied-def 0), killed renamable $rsi, implicit-def dead $eflags
1840B	  renamable $rsi = LEA64r renamable $rcx, 1, $noreg, -1, $noreg
1872B	  renamable $rsi = IMUL64rr killed renamable $rsi(tied-def 0), renamable $rcx, implicit-def dead $eflags
1904B	  renamable $rsi = IMUL64rr killed renamable $rsi(tied-def 0), killed renamable $r8, implicit-def dead $eflags
1920B	  renamable $rdi = LEA64r renamable $rdx, 1, renamable $rcx, 8, $noreg
1952B	  renamable $rcx = ADD64ri32 killed renamable $rcx(tied-def 0), 8, implicit-def dead $eflags
1968B	  CMP64ri32 killed renamable $rdi, 8, implicit-def $eflags
2016B	  JCC_1 %bb.5, 4, implicit killed $eflags
2032B	  JMP_1 %bb.10

# End machine code for function main.

# *** IR Dump After Machine Copy Propagation Pass (machine-cp) ***:
# Machine code for function main: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
Frame Objects:
  fi#0: size=4, align=4, at location [SP+8]

bb.0 (%ir-block.0):
  successors: %bb.1(0x30000000), %bb.2(0x50000000); %bb.1(37.50%), %bb.2(62.50%)

  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  renamable $rdi = LEA64r $rip, 1, $noreg, @.str, $noreg
  renamable $rsi = LEA64r %stack.0, 1, $noreg, 0, $noreg
  dead $eax = MOV32r0 implicit-def dead $eflags, implicit-def $al
  CALL64pcrel32 target-flags(x86-plt) @__isoc99_scanf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  renamable $edx = MOV32rm %stack.0, 1, $noreg, 0, $noreg, implicit-def $rdx :: (dereferenceable load (s32) from %ir.1, !tbaa !5)
  TEST32rr renamable $edx, renamable $edx, implicit-def $eflags
  JCC_1 %bb.2, 15, implicit killed $eflags

bb.1:
; predecessors: %bb.0
  successors: %bb.9(0x80000000); %bb.9(100.00%)

  renamable $rsi = MOV32ri64 1
  JMP_1 %bb.9

bb.2 (%ir-block.6):
; predecessors: %bb.0
  successors: %bb.3(0x40000000), %bb.4(0x40000000); %bb.3(50.00%), %bb.4(50.00%)
  liveins: $rdx
  renamable $rcx = LEA64r renamable $rdx, 1, $noreg, -1, $noreg
  renamable $eax = COPY renamable $edx, implicit-def $rax
  renamable $eax = AND32ri renamable $eax(tied-def 0), 7, implicit-def dead $eflags, implicit killed $rax, implicit-def $rax
  CMP64ri32 killed renamable $rcx, 7, implicit-def $eflags
  JCC_1 %bb.4, 3, implicit killed $eflags

bb.3:
; predecessors: %bb.2
  successors: %bb.6(0x80000000); %bb.6(100.00%)
  liveins: $rax
  renamable $rcx = MOV32ri64 1
  renamable $rsi = MOV32ri64 1
  JMP_1 %bb.6

bb.4 (%ir-block.12):
; predecessors: %bb.2
  successors: %bb.10(0x80000000); %bb.10(100.00%)
  liveins: $rax, $rdx
  renamable $edx = AND32ri renamable $edx(tied-def 0), -8, implicit-def dead $eflags, implicit killed $rdx, implicit-def $rdx
  renamable $rdx = NEG64r killed renamable $rdx(tied-def 0), implicit-def dead $eflags
  renamable $rsi = MOV32ri64 1
  renamable $rcx = MOV32ri64 8
  JMP_1 %bb.10

bb.5 (%ir-block.15):
; predecessors: %bb.10
  successors: %bb.6(0x80000000); %bb.6(100.00%)
  liveins: $rax, $rcx, $rsi
  renamable $rcx = ADD64ri32 killed renamable $rcx(tied-def 0), -7, implicit-def dead $eflags

bb.6 (%ir-block.17):
; predecessors: %bb.5, %bb.3
  successors: %bb.9(0x30000000), %bb.7(0x50000000); %bb.9(37.50%), %bb.7(62.50%)
  liveins: $rax, $rcx, $rsi
  TEST64rr renamable $rax, renamable $rax, implicit-def $eflags
  JCC_1 %bb.9, 4, implicit killed $eflags
  JMP_1 %bb.7

bb.7 (%ir-block.22):
; predecessors: %bb.6
  successors: %bb.8(0x80000000); %bb.8(100.00%)
  liveins: $rax, $rcx, $rsi

bb.8 (%ir-block.23):
; predecessors: %bb.7, %bb.8
  successors: %bb.9(0x04000000), %bb.8(0x7c000000); %bb.9(3.12%), %bb.8(96.88%)
  liveins: $rax, $rcx, $rsi
  renamable $rsi = IMUL64rr killed renamable $rsi(tied-def 0), renamable $rcx, implicit-def dead $eflags
  renamable $rcx = nuw nsw INC64r killed renamable $rcx(tied-def 0), implicit-def dead $eflags
  renamable $rax = DEC64r killed renamable $rax(tied-def 0), implicit-def $eflags
  JCC_1 %bb.8, 5, implicit killed $eflags
  JMP_1 %bb.9

bb.9 (%ir-block.31):
; predecessors: %bb.6, %bb.8, %bb.1
  liveins: $rsi
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  renamable $rdi = LEA64r $rip, 1, $noreg, @.str.1, $noreg
  dead $eax = MOV32r0 implicit-def dead $eflags, implicit-def $al
  CALL64pcrel32 target-flags(x86-plt) @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $eax = MOV32r0 implicit-def dead $eflags
  RET 0, $eax

bb.10 (%ir-block.34):
; predecessors: %bb.4, %bb.10
  successors: %bb.5(0x04000000), %bb.10(0x7c000000); %bb.5(3.12%), %bb.10(96.88%)
  liveins: $rax, $rcx, $rdx, $rsi
  renamable $rdi = LEA64r renamable $rcx, 1, $noreg, -7, $noreg
  renamable $rdi = IMUL64rr killed renamable $rdi(tied-def 0), killed renamable $rsi, implicit-def dead $eflags
  renamable $rsi = LEA64r renamable $rcx, 1, $noreg, -6, $noreg
  renamable $r8 = LEA64r renamable $rcx, 1, $noreg, -5, $noreg
  renamable $rsi = IMUL64rr killed renamable $rsi(tied-def 0), killed renamable $r8, implicit-def dead $eflags
  renamable $rsi = IMUL64rr killed renamable $rsi(tied-def 0), killed renamable $rdi, implicit-def dead $eflags
  renamable $rdi = LEA64r renamable $rcx, 1, $noreg, -4, $noreg
  renamable $r8 = LEA64r renamable $rcx, 1, $noreg, -3, $noreg
  renamable $rdi = IMUL64rr killed renamable $rdi(tied-def 0), killed renamable $r8, implicit-def dead $eflags
  renamable $r8 = LEA64r renamable $rcx, 1, $noreg, -2, $noreg
  renamable $r8 = IMUL64rr killed renamable $r8(tied-def 0), killed renamable $rdi, implicit-def dead $eflags
  renamable $r8 = IMUL64rr killed renamable $r8(tied-def 0), killed renamable $rsi, implicit-def dead $eflags
  renamable $rsi = LEA64r renamable $rcx, 1, $noreg, -1, $noreg
  renamable $rsi = IMUL64rr killed renamable $rsi(tied-def 0), renamable $rcx, implicit-def dead $eflags
  renamable $rsi = IMUL64rr killed renamable $rsi(tied-def 0), killed renamable $r8, implicit-def dead $eflags
  renamable $rdi = LEA64r renamable $rdx, 1, renamable $rcx, 8, $noreg
  renamable $rcx = ADD64ri32 killed renamable $rcx(tied-def 0), 8, implicit-def dead $eflags
  CMP64ri32 killed renamable $rdi, 8, implicit-def $eflags
  JCC_1 %bb.5, 4, implicit killed $eflags
  JMP_1 %bb.10

# End machine code for function main.

# *** IR Dump After Machine Loop Invariant Code Motion (machinelicm) ***:
# Machine code for function main: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
Frame Objects:
  fi#0: size=4, align=4, at location [SP+8]

bb.0 (%ir-block.0):
  successors: %bb.1(0x30000000), %bb.2(0x50000000); %bb.1(37.50%), %bb.2(62.50%)

  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  renamable $rdi = LEA64r $rip, 1, $noreg, @.str, $noreg
  renamable $rsi = LEA64r %stack.0, 1, $noreg, 0, $noreg
  dead $eax = MOV32r0 implicit-def dead $eflags, implicit-def $al
  CALL64pcrel32 target-flags(x86-plt) @__isoc99_scanf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  renamable $edx = MOV32rm %stack.0, 1, $noreg, 0, $noreg, implicit-def $rdx :: (dereferenceable load (s32) from %ir.1, !tbaa !5)
  TEST32rr renamable $edx, renamable $edx, implicit-def $eflags
  JCC_1 %bb.2, 15, implicit killed $eflags

bb.1:
; predecessors: %bb.0
  successors: %bb.9(0x80000000); %bb.9(100.00%)

  renamable $rsi = MOV32ri64 1
  JMP_1 %bb.9

bb.2 (%ir-block.6):
; predecessors: %bb.0
  successors: %bb.3(0x40000000), %bb.4(0x40000000); %bb.3(50.00%), %bb.4(50.00%)
  liveins: $rdx
  renamable $rcx = LEA64r renamable $rdx, 1, $noreg, -1, $noreg
  renamable $eax = COPY renamable $edx, implicit-def $rax
  renamable $eax = AND32ri renamable $eax(tied-def 0), 7, implicit-def dead $eflags, implicit killed $rax, implicit-def $rax
  CMP64ri32 killed renamable $rcx, 7, implicit-def $eflags
  JCC_1 %bb.4, 3, implicit killed $eflags

bb.3:
; predecessors: %bb.2
  successors: %bb.6(0x80000000); %bb.6(100.00%)
  liveins: $rax
  renamable $rcx = MOV32ri64 1
  renamable $rsi = MOV32ri64 1
  JMP_1 %bb.6

bb.4 (%ir-block.12):
; predecessors: %bb.2
  successors: %bb.10(0x80000000); %bb.10(100.00%)
  liveins: $rax, $rdx
  renamable $edx = AND32ri renamable $edx(tied-def 0), -8, implicit-def dead $eflags, implicit killed $rdx, implicit-def $rdx
  renamable $rdx = NEG64r killed renamable $rdx(tied-def 0), implicit-def dead $eflags
  renamable $rsi = MOV32ri64 1
  renamable $rcx = MOV32ri64 8
  JMP_1 %bb.10

bb.5 (%ir-block.15):
; predecessors: %bb.10
  successors: %bb.6(0x80000000); %bb.6(100.00%)
  liveins: $rax, $rcx, $rsi
  renamable $rcx = ADD64ri32 killed renamable $rcx(tied-def 0), -7, implicit-def dead $eflags

bb.6 (%ir-block.17):
; predecessors: %bb.5, %bb.3
  successors: %bb.9(0x30000000), %bb.7(0x50000000); %bb.9(37.50%), %bb.7(62.50%)
  liveins: $rax, $rcx, $rsi
  TEST64rr renamable $rax, renamable $rax, implicit-def $eflags
  JCC_1 %bb.9, 4, implicit killed $eflags
  JMP_1 %bb.7

bb.7 (%ir-block.22):
; predecessors: %bb.6
  successors: %bb.8(0x80000000); %bb.8(100.00%)
  liveins: $rax, $rcx, $rsi

bb.8 (%ir-block.23):
; predecessors: %bb.7, %bb.8
  successors: %bb.9(0x04000000), %bb.8(0x7c000000); %bb.9(3.12%), %bb.8(96.88%)
  liveins: $rax, $rcx, $rsi
  renamable $rsi = IMUL64rr killed renamable $rsi(tied-def 0), renamable $rcx, implicit-def dead $eflags
  renamable $rcx = nuw nsw INC64r killed renamable $rcx(tied-def 0), implicit-def dead $eflags
  renamable $rax = DEC64r killed renamable $rax(tied-def 0), implicit-def $eflags
  JCC_1 %bb.8, 5, implicit killed $eflags
  JMP_1 %bb.9

bb.9 (%ir-block.31):
; predecessors: %bb.6, %bb.8, %bb.1
  liveins: $rsi
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  renamable $rdi = LEA64r $rip, 1, $noreg, @.str.1, $noreg
  dead $eax = MOV32r0 implicit-def dead $eflags, implicit-def $al
  CALL64pcrel32 target-flags(x86-plt) @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $eax = MOV32r0 implicit-def dead $eflags
  RET 0, $eax

bb.10 (%ir-block.34):
; predecessors: %bb.4, %bb.10
  successors: %bb.5(0x04000000), %bb.10(0x7c000000); %bb.5(3.12%), %bb.10(96.88%)
  liveins: $rax, $rcx, $rdx, $rsi
  renamable $rdi = LEA64r renamable $rcx, 1, $noreg, -7, $noreg
  renamable $rdi = IMUL64rr killed renamable $rdi(tied-def 0), killed renamable $rsi, implicit-def dead $eflags
  renamable $rsi = LEA64r renamable $rcx, 1, $noreg, -6, $noreg
  renamable $r8 = LEA64r renamable $rcx, 1, $noreg, -5, $noreg
  renamable $rsi = IMUL64rr killed renamable $rsi(tied-def 0), killed renamable $r8, implicit-def dead $eflags
  renamable $rsi = IMUL64rr killed renamable $rsi(tied-def 0), killed renamable $rdi, implicit-def dead $eflags
  renamable $rdi = LEA64r renamable $rcx, 1, $noreg, -4, $noreg
  renamable $r8 = LEA64r renamable $rcx, 1, $noreg, -3, $noreg
  renamable $rdi = IMUL64rr killed renamable $rdi(tied-def 0), killed renamable $r8, implicit-def dead $eflags
  renamable $r8 = LEA64r renamable $rcx, 1, $noreg, -2, $noreg
  renamable $r8 = IMUL64rr killed renamable $r8(tied-def 0), killed renamable $rdi, implicit-def dead $eflags
  renamable $r8 = IMUL64rr killed renamable $r8(tied-def 0), killed renamable $rsi, implicit-def dead $eflags
  renamable $rsi = LEA64r renamable $rcx, 1, $noreg, -1, $noreg
  renamable $rsi = IMUL64rr killed renamable $rsi(tied-def 0), renamable $rcx, implicit-def dead $eflags
  renamable $rsi = IMUL64rr killed renamable $rsi(tied-def 0), killed renamable $r8, implicit-def dead $eflags
  renamable $rdi = LEA64r renamable $rdx, 1, renamable $rcx, 8, $noreg
  renamable $rcx = ADD64ri32 killed renamable $rcx(tied-def 0), 8, implicit-def dead $eflags
  CMP64ri32 killed renamable $rdi, 8, implicit-def $eflags
  JCC_1 %bb.5, 4, implicit killed $eflags
  JMP_1 %bb.10

# End machine code for function main.

# *** IR Dump After X86 Lower Tile Copy (lowertilecopy) ***:
# Machine code for function main: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
Frame Objects:
  fi#0: size=4, align=4, at location [SP+8]

bb.0 (%ir-block.0):
  successors: %bb.1(0x30000000), %bb.2(0x50000000); %bb.1(37.50%), %bb.2(62.50%)

  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  renamable $rdi = LEA64r $rip, 1, $noreg, @.str, $noreg
  renamable $rsi = LEA64r %stack.0, 1, $noreg, 0, $noreg
  dead $eax = MOV32r0 implicit-def dead $eflags, implicit-def $al
  CALL64pcrel32 target-flags(x86-plt) @__isoc99_scanf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  renamable $edx = MOV32rm %stack.0, 1, $noreg, 0, $noreg, implicit-def $rdx :: (dereferenceable load (s32) from %ir.1, !tbaa !5)
  TEST32rr renamable $edx, renamable $edx, implicit-def $eflags
  JCC_1 %bb.2, 15, implicit killed $eflags

bb.1:
; predecessors: %bb.0
  successors: %bb.9(0x80000000); %bb.9(100.00%)

  renamable $rsi = MOV32ri64 1
  JMP_1 %bb.9

bb.2 (%ir-block.6):
; predecessors: %bb.0
  successors: %bb.3(0x40000000), %bb.4(0x40000000); %bb.3(50.00%), %bb.4(50.00%)
  liveins: $rdx
  renamable $rcx = LEA64r renamable $rdx, 1, $noreg, -1, $noreg
  renamable $eax = COPY renamable $edx, implicit-def $rax
  renamable $eax = AND32ri renamable $eax(tied-def 0), 7, implicit-def dead $eflags, implicit killed $rax, implicit-def $rax
  CMP64ri32 killed renamable $rcx, 7, implicit-def $eflags
  JCC_1 %bb.4, 3, implicit killed $eflags

bb.3:
; predecessors: %bb.2
  successors: %bb.6(0x80000000); %bb.6(100.00%)
  liveins: $rax
  renamable $rcx = MOV32ri64 1
  renamable $rsi = MOV32ri64 1
  JMP_1 %bb.6

bb.4 (%ir-block.12):
; predecessors: %bb.2
  successors: %bb.10(0x80000000); %bb.10(100.00%)
  liveins: $rax, $rdx
  renamable $edx = AND32ri renamable $edx(tied-def 0), -8, implicit-def dead $eflags, implicit killed $rdx, implicit-def $rdx
  renamable $rdx = NEG64r killed renamable $rdx(tied-def 0), implicit-def dead $eflags
  renamable $rsi = MOV32ri64 1
  renamable $rcx = MOV32ri64 8
  JMP_1 %bb.10

bb.5 (%ir-block.15):
; predecessors: %bb.10
  successors: %bb.6(0x80000000); %bb.6(100.00%)
  liveins: $rax, $rcx, $rsi
  renamable $rcx = ADD64ri32 killed renamable $rcx(tied-def 0), -7, implicit-def dead $eflags

bb.6 (%ir-block.17):
; predecessors: %bb.5, %bb.3
  successors: %bb.9(0x30000000), %bb.7(0x50000000); %bb.9(37.50%), %bb.7(62.50%)
  liveins: $rax, $rcx, $rsi
  TEST64rr renamable $rax, renamable $rax, implicit-def $eflags
  JCC_1 %bb.9, 4, implicit killed $eflags
  JMP_1 %bb.7

bb.7 (%ir-block.22):
; predecessors: %bb.6
  successors: %bb.8(0x80000000); %bb.8(100.00%)
  liveins: $rax, $rcx, $rsi

bb.8 (%ir-block.23):
; predecessors: %bb.7, %bb.8
  successors: %bb.9(0x04000000), %bb.8(0x7c000000); %bb.9(3.12%), %bb.8(96.88%)
  liveins: $rax, $rcx, $rsi
  renamable $rsi = IMUL64rr killed renamable $rsi(tied-def 0), renamable $rcx, implicit-def dead $eflags
  renamable $rcx = nuw nsw INC64r killed renamable $rcx(tied-def 0), implicit-def dead $eflags
  renamable $rax = DEC64r killed renamable $rax(tied-def 0), implicit-def $eflags
  JCC_1 %bb.8, 5, implicit killed $eflags
  JMP_1 %bb.9

bb.9 (%ir-block.31):
; predecessors: %bb.6, %bb.8, %bb.1
  liveins: $rsi
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  renamable $rdi = LEA64r $rip, 1, $noreg, @.str.1, $noreg
  dead $eax = MOV32r0 implicit-def dead $eflags, implicit-def $al
  CALL64pcrel32 target-flags(x86-plt) @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $eax = MOV32r0 implicit-def dead $eflags
  RET 0, $eax

bb.10 (%ir-block.34):
; predecessors: %bb.4, %bb.10
  successors: %bb.5(0x04000000), %bb.10(0x7c000000); %bb.5(3.12%), %bb.10(96.88%)
  liveins: $rax, $rcx, $rdx, $rsi
  renamable $rdi = LEA64r renamable $rcx, 1, $noreg, -7, $noreg
  renamable $rdi = IMUL64rr killed renamable $rdi(tied-def 0), killed renamable $rsi, implicit-def dead $eflags
  renamable $rsi = LEA64r renamable $rcx, 1, $noreg, -6, $noreg
  renamable $r8 = LEA64r renamable $rcx, 1, $noreg, -5, $noreg
  renamable $rsi = IMUL64rr killed renamable $rsi(tied-def 0), killed renamable $r8, implicit-def dead $eflags
  renamable $rsi = IMUL64rr killed renamable $rsi(tied-def 0), killed renamable $rdi, implicit-def dead $eflags
  renamable $rdi = LEA64r renamable $rcx, 1, $noreg, -4, $noreg
  renamable $r8 = LEA64r renamable $rcx, 1, $noreg, -3, $noreg
  renamable $rdi = IMUL64rr killed renamable $rdi(tied-def 0), killed renamable $r8, implicit-def dead $eflags
  renamable $r8 = LEA64r renamable $rcx, 1, $noreg, -2, $noreg
  renamable $r8 = IMUL64rr killed renamable $r8(tied-def 0), killed renamable $rdi, implicit-def dead $eflags
  renamable $r8 = IMUL64rr killed renamable $r8(tied-def 0), killed renamable $rsi, implicit-def dead $eflags
  renamable $rsi = LEA64r renamable $rcx, 1, $noreg, -1, $noreg
  renamable $rsi = IMUL64rr killed renamable $rsi(tied-def 0), renamable $rcx, implicit-def dead $eflags
  renamable $rsi = IMUL64rr killed renamable $rsi(tied-def 0), killed renamable $r8, implicit-def dead $eflags
  renamable $rdi = LEA64r renamable $rdx, 1, renamable $rcx, 8, $noreg
  renamable $rcx = ADD64ri32 killed renamable $rcx(tied-def 0), 8, implicit-def dead $eflags
  CMP64ri32 killed renamable $rdi, 8, implicit-def $eflags
  JCC_1 %bb.5, 4, implicit killed $eflags
  JMP_1 %bb.10

# End machine code for function main.

# *** IR Dump After X86 FP Stackifier (x86-codegen) ***:
# Machine code for function main: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
Frame Objects:
  fi#0: size=4, align=4, at location [SP+8]

bb.0 (%ir-block.0):
  successors: %bb.1(0x30000000), %bb.2(0x50000000); %bb.1(37.50%), %bb.2(62.50%)

  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  renamable $rdi = LEA64r $rip, 1, $noreg, @.str, $noreg
  renamable $rsi = LEA64r %stack.0, 1, $noreg, 0, $noreg
  dead $eax = MOV32r0 implicit-def dead $eflags, implicit-def $al
  CALL64pcrel32 target-flags(x86-plt) @__isoc99_scanf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  renamable $edx = MOV32rm %stack.0, 1, $noreg, 0, $noreg, implicit-def $rdx :: (dereferenceable load (s32) from %ir.1, !tbaa !5)
  TEST32rr renamable $edx, renamable $edx, implicit-def $eflags
  JCC_1 %bb.2, 15, implicit killed $eflags

bb.1:
; predecessors: %bb.0
  successors: %bb.9(0x80000000); %bb.9(100.00%)

  renamable $rsi = MOV32ri64 1
  JMP_1 %bb.9

bb.2 (%ir-block.6):
; predecessors: %bb.0
  successors: %bb.3(0x40000000), %bb.4(0x40000000); %bb.3(50.00%), %bb.4(50.00%)
  liveins: $rdx
  renamable $rcx = LEA64r renamable $rdx, 1, $noreg, -1, $noreg
  renamable $eax = COPY renamable $edx, implicit-def $rax
  renamable $eax = AND32ri renamable $eax(tied-def 0), 7, implicit-def dead $eflags, implicit killed $rax, implicit-def $rax
  CMP64ri32 killed renamable $rcx, 7, implicit-def $eflags
  JCC_1 %bb.4, 3, implicit killed $eflags

bb.3:
; predecessors: %bb.2
  successors: %bb.6(0x80000000); %bb.6(100.00%)
  liveins: $rax
  renamable $rcx = MOV32ri64 1
  renamable $rsi = MOV32ri64 1
  JMP_1 %bb.6

bb.4 (%ir-block.12):
; predecessors: %bb.2
  successors: %bb.10(0x80000000); %bb.10(100.00%)
  liveins: $rax, $rdx
  renamable $edx = AND32ri renamable $edx(tied-def 0), -8, implicit-def dead $eflags, implicit killed $rdx, implicit-def $rdx
  renamable $rdx = NEG64r killed renamable $rdx(tied-def 0), implicit-def dead $eflags
  renamable $rsi = MOV32ri64 1
  renamable $rcx = MOV32ri64 8
  JMP_1 %bb.10

bb.5 (%ir-block.15):
; predecessors: %bb.10
  successors: %bb.6(0x80000000); %bb.6(100.00%)
  liveins: $rax, $rcx, $rsi
  renamable $rcx = ADD64ri32 killed renamable $rcx(tied-def 0), -7, implicit-def dead $eflags

bb.6 (%ir-block.17):
; predecessors: %bb.5, %bb.3
  successors: %bb.9(0x30000000), %bb.7(0x50000000); %bb.9(37.50%), %bb.7(62.50%)
  liveins: $rax, $rcx, $rsi
  TEST64rr renamable $rax, renamable $rax, implicit-def $eflags
  JCC_1 %bb.9, 4, implicit killed $eflags
  JMP_1 %bb.7

bb.7 (%ir-block.22):
; predecessors: %bb.6
  successors: %bb.8(0x80000000); %bb.8(100.00%)
  liveins: $rax, $rcx, $rsi

bb.8 (%ir-block.23):
; predecessors: %bb.7, %bb.8
  successors: %bb.9(0x04000000), %bb.8(0x7c000000); %bb.9(3.12%), %bb.8(96.88%)
  liveins: $rax, $rcx, $rsi
  renamable $rsi = IMUL64rr killed renamable $rsi(tied-def 0), renamable $rcx, implicit-def dead $eflags
  renamable $rcx = nuw nsw INC64r killed renamable $rcx(tied-def 0), implicit-def dead $eflags
  renamable $rax = DEC64r killed renamable $rax(tied-def 0), implicit-def $eflags
  JCC_1 %bb.8, 5, implicit killed $eflags
  JMP_1 %bb.9

bb.9 (%ir-block.31):
; predecessors: %bb.6, %bb.8, %bb.1
  liveins: $rsi
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  renamable $rdi = LEA64r $rip, 1, $noreg, @.str.1, $noreg
  dead $eax = MOV32r0 implicit-def dead $eflags, implicit-def $al
  CALL64pcrel32 target-flags(x86-plt) @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $eax = MOV32r0 implicit-def dead $eflags
  RET 0, $eax

bb.10 (%ir-block.34):
; predecessors: %bb.4, %bb.10
  successors: %bb.5(0x04000000), %bb.10(0x7c000000); %bb.5(3.12%), %bb.10(96.88%)
  liveins: $rax, $rcx, $rdx, $rsi
  renamable $rdi = LEA64r renamable $rcx, 1, $noreg, -7, $noreg
  renamable $rdi = IMUL64rr killed renamable $rdi(tied-def 0), killed renamable $rsi, implicit-def dead $eflags
  renamable $rsi = LEA64r renamable $rcx, 1, $noreg, -6, $noreg
  renamable $r8 = LEA64r renamable $rcx, 1, $noreg, -5, $noreg
  renamable $rsi = IMUL64rr killed renamable $rsi(tied-def 0), killed renamable $r8, implicit-def dead $eflags
  renamable $rsi = IMUL64rr killed renamable $rsi(tied-def 0), killed renamable $rdi, implicit-def dead $eflags
  renamable $rdi = LEA64r renamable $rcx, 1, $noreg, -4, $noreg
  renamable $r8 = LEA64r renamable $rcx, 1, $noreg, -3, $noreg
  renamable $rdi = IMUL64rr killed renamable $rdi(tied-def 0), killed renamable $r8, implicit-def dead $eflags
  renamable $r8 = LEA64r renamable $rcx, 1, $noreg, -2, $noreg
  renamable $r8 = IMUL64rr killed renamable $r8(tied-def 0), killed renamable $rdi, implicit-def dead $eflags
  renamable $r8 = IMUL64rr killed renamable $r8(tied-def 0), killed renamable $rsi, implicit-def dead $eflags
  renamable $rsi = LEA64r renamable $rcx, 1, $noreg, -1, $noreg
  renamable $rsi = IMUL64rr killed renamable $rsi(tied-def 0), renamable $rcx, implicit-def dead $eflags
  renamable $rsi = IMUL64rr killed renamable $rsi(tied-def 0), killed renamable $r8, implicit-def dead $eflags
  renamable $rdi = LEA64r renamable $rdx, 1, renamable $rcx, 8, $noreg
  renamable $rcx = ADD64ri32 killed renamable $rcx(tied-def 0), 8, implicit-def dead $eflags
  CMP64ri32 killed renamable $rdi, 8, implicit-def $eflags
  JCC_1 %bb.5, 4, implicit killed $eflags
  JMP_1 %bb.10

# End machine code for function main.

# *** IR Dump After X86 Load Value Injection (LVI) Load Hardening (x86-lvi-load) ***:
# Machine code for function main: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
Frame Objects:
  fi#0: size=4, align=4, at location [SP+8]

bb.0 (%ir-block.0):
  successors: %bb.1(0x30000000), %bb.2(0x50000000); %bb.1(37.50%), %bb.2(62.50%)

  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  renamable $rdi = LEA64r $rip, 1, $noreg, @.str, $noreg
  renamable $rsi = LEA64r %stack.0, 1, $noreg, 0, $noreg
  dead $eax = MOV32r0 implicit-def dead $eflags, implicit-def $al
  CALL64pcrel32 target-flags(x86-plt) @__isoc99_scanf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  renamable $edx = MOV32rm %stack.0, 1, $noreg, 0, $noreg, implicit-def $rdx :: (dereferenceable load (s32) from %ir.1, !tbaa !5)
  TEST32rr renamable $edx, renamable $edx, implicit-def $eflags
  JCC_1 %bb.2, 15, implicit killed $eflags

bb.1:
; predecessors: %bb.0
  successors: %bb.9(0x80000000); %bb.9(100.00%)

  renamable $rsi = MOV32ri64 1
  JMP_1 %bb.9

bb.2 (%ir-block.6):
; predecessors: %bb.0
  successors: %bb.3(0x40000000), %bb.4(0x40000000); %bb.3(50.00%), %bb.4(50.00%)
  liveins: $rdx
  renamable $rcx = LEA64r renamable $rdx, 1, $noreg, -1, $noreg
  renamable $eax = COPY renamable $edx, implicit-def $rax
  renamable $eax = AND32ri renamable $eax(tied-def 0), 7, implicit-def dead $eflags, implicit killed $rax, implicit-def $rax
  CMP64ri32 killed renamable $rcx, 7, implicit-def $eflags
  JCC_1 %bb.4, 3, implicit killed $eflags

bb.3:
; predecessors: %bb.2
  successors: %bb.6(0x80000000); %bb.6(100.00%)
  liveins: $rax
  renamable $rcx = MOV32ri64 1
  renamable $rsi = MOV32ri64 1
  JMP_1 %bb.6

bb.4 (%ir-block.12):
; predecessors: %bb.2
  successors: %bb.10(0x80000000); %bb.10(100.00%)
  liveins: $rax, $rdx
  renamable $edx = AND32ri renamable $edx(tied-def 0), -8, implicit-def dead $eflags, implicit killed $rdx, implicit-def $rdx
  renamable $rdx = NEG64r killed renamable $rdx(tied-def 0), implicit-def dead $eflags
  renamable $rsi = MOV32ri64 1
  renamable $rcx = MOV32ri64 8
  JMP_1 %bb.10

bb.5 (%ir-block.15):
; predecessors: %bb.10
  successors: %bb.6(0x80000000); %bb.6(100.00%)
  liveins: $rax, $rcx, $rsi
  renamable $rcx = ADD64ri32 killed renamable $rcx(tied-def 0), -7, implicit-def dead $eflags

bb.6 (%ir-block.17):
; predecessors: %bb.5, %bb.3
  successors: %bb.9(0x30000000), %bb.7(0x50000000); %bb.9(37.50%), %bb.7(62.50%)
  liveins: $rax, $rcx, $rsi
  TEST64rr renamable $rax, renamable $rax, implicit-def $eflags
  JCC_1 %bb.9, 4, implicit killed $eflags
  JMP_1 %bb.7

bb.7 (%ir-block.22):
; predecessors: %bb.6
  successors: %bb.8(0x80000000); %bb.8(100.00%)
  liveins: $rax, $rcx, $rsi

bb.8 (%ir-block.23):
; predecessors: %bb.7, %bb.8
  successors: %bb.9(0x04000000), %bb.8(0x7c000000); %bb.9(3.12%), %bb.8(96.88%)
  liveins: $rax, $rcx, $rsi
  renamable $rsi = IMUL64rr killed renamable $rsi(tied-def 0), renamable $rcx, implicit-def dead $eflags
  renamable $rcx = nuw nsw INC64r killed renamable $rcx(tied-def 0), implicit-def dead $eflags
  renamable $rax = DEC64r killed renamable $rax(tied-def 0), implicit-def $eflags
  JCC_1 %bb.8, 5, implicit killed $eflags
  JMP_1 %bb.9

bb.9 (%ir-block.31):
; predecessors: %bb.6, %bb.8, %bb.1
  liveins: $rsi
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  renamable $rdi = LEA64r $rip, 1, $noreg, @.str.1, $noreg
  dead $eax = MOV32r0 implicit-def dead $eflags, implicit-def $al
  CALL64pcrel32 target-flags(x86-plt) @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $eax = MOV32r0 implicit-def dead $eflags
  RET 0, $eax

bb.10 (%ir-block.34):
; predecessors: %bb.4, %bb.10
  successors: %bb.5(0x04000000), %bb.10(0x7c000000); %bb.5(3.12%), %bb.10(96.88%)
  liveins: $rax, $rcx, $rdx, $rsi
  renamable $rdi = LEA64r renamable $rcx, 1, $noreg, -7, $noreg
  renamable $rdi = IMUL64rr killed renamable $rdi(tied-def 0), killed renamable $rsi, implicit-def dead $eflags
  renamable $rsi = LEA64r renamable $rcx, 1, $noreg, -6, $noreg
  renamable $r8 = LEA64r renamable $rcx, 1, $noreg, -5, $noreg
  renamable $rsi = IMUL64rr killed renamable $rsi(tied-def 0), killed renamable $r8, implicit-def dead $eflags
  renamable $rsi = IMUL64rr killed renamable $rsi(tied-def 0), killed renamable $rdi, implicit-def dead $eflags
  renamable $rdi = LEA64r renamable $rcx, 1, $noreg, -4, $noreg
  renamable $r8 = LEA64r renamable $rcx, 1, $noreg, -3, $noreg
  renamable $rdi = IMUL64rr killed renamable $rdi(tied-def 0), killed renamable $r8, implicit-def dead $eflags
  renamable $r8 = LEA64r renamable $rcx, 1, $noreg, -2, $noreg
  renamable $r8 = IMUL64rr killed renamable $r8(tied-def 0), killed renamable $rdi, implicit-def dead $eflags
  renamable $r8 = IMUL64rr killed renamable $r8(tied-def 0), killed renamable $rsi, implicit-def dead $eflags
  renamable $rsi = LEA64r renamable $rcx, 1, $noreg, -1, $noreg
  renamable $rsi = IMUL64rr killed renamable $rsi(tied-def 0), renamable $rcx, implicit-def dead $eflags
  renamable $rsi = IMUL64rr killed renamable $rsi(tied-def 0), killed renamable $r8, implicit-def dead $eflags
  renamable $rdi = LEA64r renamable $rdx, 1, renamable $rcx, 8, $noreg
  renamable $rcx = ADD64ri32 killed renamable $rcx(tied-def 0), 8, implicit-def dead $eflags
  CMP64ri32 killed renamable $rdi, 8, implicit-def $eflags
  JCC_1 %bb.5, 4, implicit killed $eflags
  JMP_1 %bb.10

# End machine code for function main.

# *** IR Dump After Remove Redundant DEBUG_VALUE analysis (removeredundantdebugvalues) ***:
# Machine code for function main: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
Frame Objects:
  fi#0: size=4, align=4, at location [SP+8]

bb.0 (%ir-block.0):
  successors: %bb.1(0x30000000), %bb.2(0x50000000); %bb.1(37.50%), %bb.2(62.50%)

  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  renamable $rdi = LEA64r $rip, 1, $noreg, @.str, $noreg
  renamable $rsi = LEA64r %stack.0, 1, $noreg, 0, $noreg
  dead $eax = MOV32r0 implicit-def dead $eflags, implicit-def $al
  CALL64pcrel32 target-flags(x86-plt) @__isoc99_scanf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  renamable $edx = MOV32rm %stack.0, 1, $noreg, 0, $noreg, implicit-def $rdx :: (dereferenceable load (s32) from %ir.1, !tbaa !5)
  TEST32rr renamable $edx, renamable $edx, implicit-def $eflags
  JCC_1 %bb.2, 15, implicit killed $eflags

bb.1:
; predecessors: %bb.0
  successors: %bb.9(0x80000000); %bb.9(100.00%)

  renamable $rsi = MOV32ri64 1
  JMP_1 %bb.9

bb.2 (%ir-block.6):
; predecessors: %bb.0
  successors: %bb.3(0x40000000), %bb.4(0x40000000); %bb.3(50.00%), %bb.4(50.00%)
  liveins: $rdx
  renamable $rcx = LEA64r renamable $rdx, 1, $noreg, -1, $noreg
  renamable $eax = COPY renamable $edx, implicit-def $rax
  renamable $eax = AND32ri renamable $eax(tied-def 0), 7, implicit-def dead $eflags, implicit killed $rax, implicit-def $rax
  CMP64ri32 killed renamable $rcx, 7, implicit-def $eflags
  JCC_1 %bb.4, 3, implicit killed $eflags

bb.3:
; predecessors: %bb.2
  successors: %bb.6(0x80000000); %bb.6(100.00%)
  liveins: $rax
  renamable $rcx = MOV32ri64 1
  renamable $rsi = MOV32ri64 1
  JMP_1 %bb.6

bb.4 (%ir-block.12):
; predecessors: %bb.2
  successors: %bb.10(0x80000000); %bb.10(100.00%)
  liveins: $rax, $rdx
  renamable $edx = AND32ri renamable $edx(tied-def 0), -8, implicit-def dead $eflags, implicit killed $rdx, implicit-def $rdx
  renamable $rdx = NEG64r killed renamable $rdx(tied-def 0), implicit-def dead $eflags
  renamable $rsi = MOV32ri64 1
  renamable $rcx = MOV32ri64 8
  JMP_1 %bb.10

bb.5 (%ir-block.15):
; predecessors: %bb.10
  successors: %bb.6(0x80000000); %bb.6(100.00%)
  liveins: $rax, $rcx, $rsi
  renamable $rcx = ADD64ri32 killed renamable $rcx(tied-def 0), -7, implicit-def dead $eflags

bb.6 (%ir-block.17):
; predecessors: %bb.5, %bb.3
  successors: %bb.9(0x30000000), %bb.7(0x50000000); %bb.9(37.50%), %bb.7(62.50%)
  liveins: $rax, $rcx, $rsi
  TEST64rr renamable $rax, renamable $rax, implicit-def $eflags
  JCC_1 %bb.9, 4, implicit killed $eflags
  JMP_1 %bb.7

bb.7 (%ir-block.22):
; predecessors: %bb.6
  successors: %bb.8(0x80000000); %bb.8(100.00%)
  liveins: $rax, $rcx, $rsi

bb.8 (%ir-block.23):
; predecessors: %bb.7, %bb.8
  successors: %bb.9(0x04000000), %bb.8(0x7c000000); %bb.9(3.12%), %bb.8(96.88%)
  liveins: $rax, $rcx, $rsi
  renamable $rsi = IMUL64rr killed renamable $rsi(tied-def 0), renamable $rcx, implicit-def dead $eflags
  renamable $rcx = nuw nsw INC64r killed renamable $rcx(tied-def 0), implicit-def dead $eflags
  renamable $rax = DEC64r killed renamable $rax(tied-def 0), implicit-def $eflags
  JCC_1 %bb.8, 5, implicit killed $eflags
  JMP_1 %bb.9

bb.9 (%ir-block.31):
; predecessors: %bb.6, %bb.8, %bb.1
  liveins: $rsi
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  renamable $rdi = LEA64r $rip, 1, $noreg, @.str.1, $noreg
  dead $eax = MOV32r0 implicit-def dead $eflags, implicit-def $al
  CALL64pcrel32 target-flags(x86-plt) @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $eax = MOV32r0 implicit-def dead $eflags
  RET 0, $eax

bb.10 (%ir-block.34):
; predecessors: %bb.4, %bb.10
  successors: %bb.5(0x04000000), %bb.10(0x7c000000); %bb.5(3.12%), %bb.10(96.88%)
  liveins: $rax, $rcx, $rdx, $rsi
  renamable $rdi = LEA64r renamable $rcx, 1, $noreg, -7, $noreg
  renamable $rdi = IMUL64rr killed renamable $rdi(tied-def 0), killed renamable $rsi, implicit-def dead $eflags
  renamable $rsi = LEA64r renamable $rcx, 1, $noreg, -6, $noreg
  renamable $r8 = LEA64r renamable $rcx, 1, $noreg, -5, $noreg
  renamable $rsi = IMUL64rr killed renamable $rsi(tied-def 0), killed renamable $r8, implicit-def dead $eflags
  renamable $rsi = IMUL64rr killed renamable $rsi(tied-def 0), killed renamable $rdi, implicit-def dead $eflags
  renamable $rdi = LEA64r renamable $rcx, 1, $noreg, -4, $noreg
  renamable $r8 = LEA64r renamable $rcx, 1, $noreg, -3, $noreg
  renamable $rdi = IMUL64rr killed renamable $rdi(tied-def 0), killed renamable $r8, implicit-def dead $eflags
  renamable $r8 = LEA64r renamable $rcx, 1, $noreg, -2, $noreg
  renamable $r8 = IMUL64rr killed renamable $r8(tied-def 0), killed renamable $rdi, implicit-def dead $eflags
  renamable $r8 = IMUL64rr killed renamable $r8(tied-def 0), killed renamable $rsi, implicit-def dead $eflags
  renamable $rsi = LEA64r renamable $rcx, 1, $noreg, -1, $noreg
  renamable $rsi = IMUL64rr killed renamable $rsi(tied-def 0), renamable $rcx, implicit-def dead $eflags
  renamable $rsi = IMUL64rr killed renamable $rsi(tied-def 0), killed renamable $r8, implicit-def dead $eflags
  renamable $rdi = LEA64r renamable $rdx, 1, renamable $rcx, 8, $noreg
  renamable $rcx = ADD64ri32 killed renamable $rcx(tied-def 0), 8, implicit-def dead $eflags
  CMP64ri32 killed renamable $rdi, 8, implicit-def $eflags
  JCC_1 %bb.5, 4, implicit killed $eflags
  JMP_1 %bb.10

# End machine code for function main.

# *** IR Dump After Fixup Statepoint Caller Saved (fixup-statepoint-caller-saved) ***:
# Machine code for function main: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
Frame Objects:
  fi#0: size=4, align=4, at location [SP+8]

bb.0 (%ir-block.0):
  successors: %bb.1(0x30000000), %bb.2(0x50000000); %bb.1(37.50%), %bb.2(62.50%)

  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  renamable $rdi = LEA64r $rip, 1, $noreg, @.str, $noreg
  renamable $rsi = LEA64r %stack.0, 1, $noreg, 0, $noreg
  dead $eax = MOV32r0 implicit-def dead $eflags, implicit-def $al
  CALL64pcrel32 target-flags(x86-plt) @__isoc99_scanf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  renamable $edx = MOV32rm %stack.0, 1, $noreg, 0, $noreg, implicit-def $rdx :: (dereferenceable load (s32) from %ir.1, !tbaa !5)
  TEST32rr renamable $edx, renamable $edx, implicit-def $eflags
  JCC_1 %bb.2, 15, implicit killed $eflags

bb.1:
; predecessors: %bb.0
  successors: %bb.9(0x80000000); %bb.9(100.00%)

  renamable $rsi = MOV32ri64 1
  JMP_1 %bb.9

bb.2 (%ir-block.6):
; predecessors: %bb.0
  successors: %bb.3(0x40000000), %bb.4(0x40000000); %bb.3(50.00%), %bb.4(50.00%)
  liveins: $rdx
  renamable $rcx = LEA64r renamable $rdx, 1, $noreg, -1, $noreg
  renamable $eax = COPY renamable $edx, implicit-def $rax
  renamable $eax = AND32ri renamable $eax(tied-def 0), 7, implicit-def dead $eflags, implicit killed $rax, implicit-def $rax
  CMP64ri32 killed renamable $rcx, 7, implicit-def $eflags
  JCC_1 %bb.4, 3, implicit killed $eflags

bb.3:
; predecessors: %bb.2
  successors: %bb.6(0x80000000); %bb.6(100.00%)
  liveins: $rax
  renamable $rcx = MOV32ri64 1
  renamable $rsi = MOV32ri64 1
  JMP_1 %bb.6

bb.4 (%ir-block.12):
; predecessors: %bb.2
  successors: %bb.10(0x80000000); %bb.10(100.00%)
  liveins: $rax, $rdx
  renamable $edx = AND32ri renamable $edx(tied-def 0), -8, implicit-def dead $eflags, implicit killed $rdx, implicit-def $rdx
  renamable $rdx = NEG64r killed renamable $rdx(tied-def 0), implicit-def dead $eflags
  renamable $rsi = MOV32ri64 1
  renamable $rcx = MOV32ri64 8
  JMP_1 %bb.10

bb.5 (%ir-block.15):
; predecessors: %bb.10
  successors: %bb.6(0x80000000); %bb.6(100.00%)
  liveins: $rax, $rcx, $rsi
  renamable $rcx = ADD64ri32 killed renamable $rcx(tied-def 0), -7, implicit-def dead $eflags

bb.6 (%ir-block.17):
; predecessors: %bb.5, %bb.3
  successors: %bb.9(0x30000000), %bb.7(0x50000000); %bb.9(37.50%), %bb.7(62.50%)
  liveins: $rax, $rcx, $rsi
  TEST64rr renamable $rax, renamable $rax, implicit-def $eflags
  JCC_1 %bb.9, 4, implicit killed $eflags
  JMP_1 %bb.7

bb.7 (%ir-block.22):
; predecessors: %bb.6
  successors: %bb.8(0x80000000); %bb.8(100.00%)
  liveins: $rax, $rcx, $rsi

bb.8 (%ir-block.23):
; predecessors: %bb.7, %bb.8
  successors: %bb.9(0x04000000), %bb.8(0x7c000000); %bb.9(3.12%), %bb.8(96.88%)
  liveins: $rax, $rcx, $rsi
  renamable $rsi = IMUL64rr killed renamable $rsi(tied-def 0), renamable $rcx, implicit-def dead $eflags
  renamable $rcx = nuw nsw INC64r killed renamable $rcx(tied-def 0), implicit-def dead $eflags
  renamable $rax = DEC64r killed renamable $rax(tied-def 0), implicit-def $eflags
  JCC_1 %bb.8, 5, implicit killed $eflags
  JMP_1 %bb.9

bb.9 (%ir-block.31):
; predecessors: %bb.6, %bb.8, %bb.1
  liveins: $rsi
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  renamable $rdi = LEA64r $rip, 1, $noreg, @.str.1, $noreg
  dead $eax = MOV32r0 implicit-def dead $eflags, implicit-def $al
  CALL64pcrel32 target-flags(x86-plt) @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $eax = MOV32r0 implicit-def dead $eflags
  RET 0, $eax

bb.10 (%ir-block.34):
; predecessors: %bb.4, %bb.10
  successors: %bb.5(0x04000000), %bb.10(0x7c000000); %bb.5(3.12%), %bb.10(96.88%)
  liveins: $rax, $rcx, $rdx, $rsi
  renamable $rdi = LEA64r renamable $rcx, 1, $noreg, -7, $noreg
  renamable $rdi = IMUL64rr killed renamable $rdi(tied-def 0), killed renamable $rsi, implicit-def dead $eflags
  renamable $rsi = LEA64r renamable $rcx, 1, $noreg, -6, $noreg
  renamable $r8 = LEA64r renamable $rcx, 1, $noreg, -5, $noreg
  renamable $rsi = IMUL64rr killed renamable $rsi(tied-def 0), killed renamable $r8, implicit-def dead $eflags
  renamable $rsi = IMUL64rr killed renamable $rsi(tied-def 0), killed renamable $rdi, implicit-def dead $eflags
  renamable $rdi = LEA64r renamable $rcx, 1, $noreg, -4, $noreg
  renamable $r8 = LEA64r renamable $rcx, 1, $noreg, -3, $noreg
  renamable $rdi = IMUL64rr killed renamable $rdi(tied-def 0), killed renamable $r8, implicit-def dead $eflags
  renamable $r8 = LEA64r renamable $rcx, 1, $noreg, -2, $noreg
  renamable $r8 = IMUL64rr killed renamable $r8(tied-def 0), killed renamable $rdi, implicit-def dead $eflags
  renamable $r8 = IMUL64rr killed renamable $r8(tied-def 0), killed renamable $rsi, implicit-def dead $eflags
  renamable $rsi = LEA64r renamable $rcx, 1, $noreg, -1, $noreg
  renamable $rsi = IMUL64rr killed renamable $rsi(tied-def 0), renamable $rcx, implicit-def dead $eflags
  renamable $rsi = IMUL64rr killed renamable $rsi(tied-def 0), killed renamable $r8, implicit-def dead $eflags
  renamable $rdi = LEA64r renamable $rdx, 1, renamable $rcx, 8, $noreg
  renamable $rcx = ADD64ri32 killed renamable $rcx(tied-def 0), 8, implicit-def dead $eflags
  CMP64ri32 killed renamable $rdi, 8, implicit-def $eflags
  JCC_1 %bb.5, 4, implicit killed $eflags
  JMP_1 %bb.10

# End machine code for function main.

# *** IR Dump After PostRA Machine Sink (postra-machine-sink) ***:
# Machine code for function main: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
Frame Objects:
  fi#0: size=4, align=4, at location [SP+8]

bb.0 (%ir-block.0):
  successors: %bb.1(0x30000000), %bb.2(0x50000000); %bb.1(37.50%), %bb.2(62.50%)

  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  renamable $rdi = LEA64r $rip, 1, $noreg, @.str, $noreg
  renamable $rsi = LEA64r %stack.0, 1, $noreg, 0, $noreg
  dead $eax = MOV32r0 implicit-def dead $eflags, implicit-def $al
  CALL64pcrel32 target-flags(x86-plt) @__isoc99_scanf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  renamable $edx = MOV32rm %stack.0, 1, $noreg, 0, $noreg, implicit-def $rdx :: (dereferenceable load (s32) from %ir.1, !tbaa !5)
  TEST32rr renamable $edx, renamable $edx, implicit-def $eflags
  JCC_1 %bb.2, 15, implicit killed $eflags

bb.1:
; predecessors: %bb.0
  successors: %bb.9(0x80000000); %bb.9(100.00%)

  renamable $rsi = MOV32ri64 1
  JMP_1 %bb.9

bb.2 (%ir-block.6):
; predecessors: %bb.0
  successors: %bb.3(0x40000000), %bb.4(0x40000000); %bb.3(50.00%), %bb.4(50.00%)
  liveins: $rdx
  renamable $rcx = LEA64r renamable $rdx, 1, $noreg, -1, $noreg
  renamable $eax = COPY renamable $edx, implicit-def $rax
  renamable $eax = AND32ri renamable $eax(tied-def 0), 7, implicit-def dead $eflags, implicit killed $rax, implicit-def $rax
  CMP64ri32 killed renamable $rcx, 7, implicit-def $eflags
  JCC_1 %bb.4, 3, implicit killed $eflags

bb.3:
; predecessors: %bb.2
  successors: %bb.6(0x80000000); %bb.6(100.00%)
  liveins: $rax
  renamable $rcx = MOV32ri64 1
  renamable $rsi = MOV32ri64 1
  JMP_1 %bb.6

bb.4 (%ir-block.12):
; predecessors: %bb.2
  successors: %bb.10(0x80000000); %bb.10(100.00%)
  liveins: $rax, $rdx
  renamable $edx = AND32ri renamable $edx(tied-def 0), -8, implicit-def dead $eflags, implicit killed $rdx, implicit-def $rdx
  renamable $rdx = NEG64r killed renamable $rdx(tied-def 0), implicit-def dead $eflags
  renamable $rsi = MOV32ri64 1
  renamable $rcx = MOV32ri64 8
  JMP_1 %bb.10

bb.5 (%ir-block.15):
; predecessors: %bb.10
  successors: %bb.6(0x80000000); %bb.6(100.00%)
  liveins: $rax, $rcx, $rsi
  renamable $rcx = ADD64ri32 killed renamable $rcx(tied-def 0), -7, implicit-def dead $eflags

bb.6 (%ir-block.17):
; predecessors: %bb.5, %bb.3
  successors: %bb.9(0x30000000), %bb.7(0x50000000); %bb.9(37.50%), %bb.7(62.50%)
  liveins: $rax, $rcx, $rsi
  TEST64rr renamable $rax, renamable $rax, implicit-def $eflags
  JCC_1 %bb.9, 4, implicit killed $eflags
  JMP_1 %bb.7

bb.7 (%ir-block.22):
; predecessors: %bb.6
  successors: %bb.8(0x80000000); %bb.8(100.00%)
  liveins: $rax, $rcx, $rsi

bb.8 (%ir-block.23):
; predecessors: %bb.7, %bb.8
  successors: %bb.9(0x04000000), %bb.8(0x7c000000); %bb.9(3.12%), %bb.8(96.88%)
  liveins: $rax, $rcx, $rsi
  renamable $rsi = IMUL64rr killed renamable $rsi(tied-def 0), renamable $rcx, implicit-def dead $eflags
  renamable $rcx = nuw nsw INC64r killed renamable $rcx(tied-def 0), implicit-def dead $eflags
  renamable $rax = DEC64r killed renamable $rax(tied-def 0), implicit-def $eflags
  JCC_1 %bb.8, 5, implicit killed $eflags
  JMP_1 %bb.9

bb.9 (%ir-block.31):
; predecessors: %bb.6, %bb.8, %bb.1
  liveins: $rsi
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  renamable $rdi = LEA64r $rip, 1, $noreg, @.str.1, $noreg
  dead $eax = MOV32r0 implicit-def dead $eflags, implicit-def $al
  CALL64pcrel32 target-flags(x86-plt) @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $eax = MOV32r0 implicit-def dead $eflags
  RET 0, $eax

bb.10 (%ir-block.34):
; predecessors: %bb.4, %bb.10
  successors: %bb.5(0x04000000), %bb.10(0x7c000000); %bb.5(3.12%), %bb.10(96.88%)
  liveins: $rax, $rcx, $rdx, $rsi
  renamable $rdi = LEA64r renamable $rcx, 1, $noreg, -7, $noreg
  renamable $rdi = IMUL64rr killed renamable $rdi(tied-def 0), killed renamable $rsi, implicit-def dead $eflags
  renamable $rsi = LEA64r renamable $rcx, 1, $noreg, -6, $noreg
  renamable $r8 = LEA64r renamable $rcx, 1, $noreg, -5, $noreg
  renamable $rsi = IMUL64rr killed renamable $rsi(tied-def 0), killed renamable $r8, implicit-def dead $eflags
  renamable $rsi = IMUL64rr killed renamable $rsi(tied-def 0), killed renamable $rdi, implicit-def dead $eflags
  renamable $rdi = LEA64r renamable $rcx, 1, $noreg, -4, $noreg
  renamable $r8 = LEA64r renamable $rcx, 1, $noreg, -3, $noreg
  renamable $rdi = IMUL64rr killed renamable $rdi(tied-def 0), killed renamable $r8, implicit-def dead $eflags
  renamable $r8 = LEA64r renamable $rcx, 1, $noreg, -2, $noreg
  renamable $r8 = IMUL64rr killed renamable $r8(tied-def 0), killed renamable $rdi, implicit-def dead $eflags
  renamable $r8 = IMUL64rr killed renamable $r8(tied-def 0), killed renamable $rsi, implicit-def dead $eflags
  renamable $rsi = LEA64r renamable $rcx, 1, $noreg, -1, $noreg
  renamable $rsi = IMUL64rr killed renamable $rsi(tied-def 0), renamable $rcx, implicit-def dead $eflags
  renamable $rsi = IMUL64rr killed renamable $rsi(tied-def 0), killed renamable $r8, implicit-def dead $eflags
  renamable $rdi = LEA64r renamable $rdx, 1, renamable $rcx, 8, $noreg
  renamable $rcx = ADD64ri32 killed renamable $rcx(tied-def 0), 8, implicit-def dead $eflags
  CMP64ri32 killed renamable $rdi, 8, implicit-def $eflags
  JCC_1 %bb.5, 4, implicit killed $eflags
  JMP_1 %bb.10

# End machine code for function main.

# *** IR Dump After Shrink Wrapping analysis (shrink-wrap) ***:
# Machine code for function main: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
Frame Objects:
  fi#0: size=4, align=4, at location [SP+8]

bb.0 (%ir-block.0):
  successors: %bb.1(0x30000000), %bb.2(0x50000000); %bb.1(37.50%), %bb.2(62.50%)

  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  renamable $rdi = LEA64r $rip, 1, $noreg, @.str, $noreg
  renamable $rsi = LEA64r %stack.0, 1, $noreg, 0, $noreg
  dead $eax = MOV32r0 implicit-def dead $eflags, implicit-def $al
  CALL64pcrel32 target-flags(x86-plt) @__isoc99_scanf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  renamable $edx = MOV32rm %stack.0, 1, $noreg, 0, $noreg, implicit-def $rdx :: (dereferenceable load (s32) from %ir.1, !tbaa !5)
  TEST32rr renamable $edx, renamable $edx, implicit-def $eflags
  JCC_1 %bb.2, 15, implicit killed $eflags

bb.1:
; predecessors: %bb.0
  successors: %bb.9(0x80000000); %bb.9(100.00%)

  renamable $rsi = MOV32ri64 1
  JMP_1 %bb.9

bb.2 (%ir-block.6):
; predecessors: %bb.0
  successors: %bb.3(0x40000000), %bb.4(0x40000000); %bb.3(50.00%), %bb.4(50.00%)
  liveins: $rdx
  renamable $rcx = LEA64r renamable $rdx, 1, $noreg, -1, $noreg
  renamable $eax = COPY renamable $edx, implicit-def $rax
  renamable $eax = AND32ri renamable $eax(tied-def 0), 7, implicit-def dead $eflags, implicit killed $rax, implicit-def $rax
  CMP64ri32 killed renamable $rcx, 7, implicit-def $eflags
  JCC_1 %bb.4, 3, implicit killed $eflags

bb.3:
; predecessors: %bb.2
  successors: %bb.6(0x80000000); %bb.6(100.00%)
  liveins: $rax
  renamable $rcx = MOV32ri64 1
  renamable $rsi = MOV32ri64 1
  JMP_1 %bb.6

bb.4 (%ir-block.12):
; predecessors: %bb.2
  successors: %bb.10(0x80000000); %bb.10(100.00%)
  liveins: $rax, $rdx
  renamable $edx = AND32ri renamable $edx(tied-def 0), -8, implicit-def dead $eflags, implicit killed $rdx, implicit-def $rdx
  renamable $rdx = NEG64r killed renamable $rdx(tied-def 0), implicit-def dead $eflags
  renamable $rsi = MOV32ri64 1
  renamable $rcx = MOV32ri64 8
  JMP_1 %bb.10

bb.5 (%ir-block.15):
; predecessors: %bb.10
  successors: %bb.6(0x80000000); %bb.6(100.00%)
  liveins: $rax, $rcx, $rsi
  renamable $rcx = ADD64ri32 killed renamable $rcx(tied-def 0), -7, implicit-def dead $eflags

bb.6 (%ir-block.17):
; predecessors: %bb.5, %bb.3
  successors: %bb.9(0x30000000), %bb.7(0x50000000); %bb.9(37.50%), %bb.7(62.50%)
  liveins: $rax, $rcx, $rsi
  TEST64rr renamable $rax, renamable $rax, implicit-def $eflags
  JCC_1 %bb.9, 4, implicit killed $eflags
  JMP_1 %bb.7

bb.7 (%ir-block.22):
; predecessors: %bb.6
  successors: %bb.8(0x80000000); %bb.8(100.00%)
  liveins: $rax, $rcx, $rsi

bb.8 (%ir-block.23):
; predecessors: %bb.7, %bb.8
  successors: %bb.9(0x04000000), %bb.8(0x7c000000); %bb.9(3.12%), %bb.8(96.88%)
  liveins: $rax, $rcx, $rsi
  renamable $rsi = IMUL64rr killed renamable $rsi(tied-def 0), renamable $rcx, implicit-def dead $eflags
  renamable $rcx = nuw nsw INC64r killed renamable $rcx(tied-def 0), implicit-def dead $eflags
  renamable $rax = DEC64r killed renamable $rax(tied-def 0), implicit-def $eflags
  JCC_1 %bb.8, 5, implicit killed $eflags
  JMP_1 %bb.9

bb.9 (%ir-block.31):
; predecessors: %bb.6, %bb.8, %bb.1
  liveins: $rsi
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  renamable $rdi = LEA64r $rip, 1, $noreg, @.str.1, $noreg
  dead $eax = MOV32r0 implicit-def dead $eflags, implicit-def $al
  CALL64pcrel32 target-flags(x86-plt) @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $eax = MOV32r0 implicit-def dead $eflags
  RET 0, $eax

bb.10 (%ir-block.34):
; predecessors: %bb.4, %bb.10
  successors: %bb.5(0x04000000), %bb.10(0x7c000000); %bb.5(3.12%), %bb.10(96.88%)
  liveins: $rax, $rcx, $rdx, $rsi
  renamable $rdi = LEA64r renamable $rcx, 1, $noreg, -7, $noreg
  renamable $rdi = IMUL64rr killed renamable $rdi(tied-def 0), killed renamable $rsi, implicit-def dead $eflags
  renamable $rsi = LEA64r renamable $rcx, 1, $noreg, -6, $noreg
  renamable $r8 = LEA64r renamable $rcx, 1, $noreg, -5, $noreg
  renamable $rsi = IMUL64rr killed renamable $rsi(tied-def 0), killed renamable $r8, implicit-def dead $eflags
  renamable $rsi = IMUL64rr killed renamable $rsi(tied-def 0), killed renamable $rdi, implicit-def dead $eflags
  renamable $rdi = LEA64r renamable $rcx, 1, $noreg, -4, $noreg
  renamable $r8 = LEA64r renamable $rcx, 1, $noreg, -3, $noreg
  renamable $rdi = IMUL64rr killed renamable $rdi(tied-def 0), killed renamable $r8, implicit-def dead $eflags
  renamable $r8 = LEA64r renamable $rcx, 1, $noreg, -2, $noreg
  renamable $r8 = IMUL64rr killed renamable $r8(tied-def 0), killed renamable $rdi, implicit-def dead $eflags
  renamable $r8 = IMUL64rr killed renamable $r8(tied-def 0), killed renamable $rsi, implicit-def dead $eflags
  renamable $rsi = LEA64r renamable $rcx, 1, $noreg, -1, $noreg
  renamable $rsi = IMUL64rr killed renamable $rsi(tied-def 0), renamable $rcx, implicit-def dead $eflags
  renamable $rsi = IMUL64rr killed renamable $rsi(tied-def 0), killed renamable $r8, implicit-def dead $eflags
  renamable $rdi = LEA64r renamable $rdx, 1, renamable $rcx, 8, $noreg
  renamable $rcx = ADD64ri32 killed renamable $rcx(tied-def 0), 8, implicit-def dead $eflags
  CMP64ri32 killed renamable $rdi, 8, implicit-def $eflags
  JCC_1 %bb.5, 4, implicit killed $eflags
  JMP_1 %bb.10

# End machine code for function main.

# *** IR Dump After Prologue/Epilogue Insertion & Frame Finalization (prologepilog) ***:
# Machine code for function main: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
Frame Objects:
  fi#0: size=4, align=4, at location [SP-4]

bb.0 (%ir-block.0):
  successors: %bb.1(0x30000000), %bb.2(0x50000000); %bb.1(37.50%), %bb.2(62.50%)

  frame-setup PUSH64r undef $rax, implicit-def $rsp, implicit $rsp
  frame-setup CFI_INSTRUCTION def_cfa_offset 16
  renamable $rdi = LEA64r $rip, 1, $noreg, @.str, $noreg
  renamable $rsi = LEA64r $rsp, 1, $noreg, 4, $noreg
  dead $eax = MOV32r0 implicit-def dead $eflags, implicit-def $al
  CALL64pcrel32 target-flags(x86-plt) @__isoc99_scanf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
  renamable $edx = MOV32rm $rsp, 1, $noreg, 4, $noreg, implicit-def $rdx :: (dereferenceable load (s32) from %ir.1, !tbaa !5)
  TEST32rr renamable $edx, renamable $edx, implicit-def $eflags
  JCC_1 %bb.2, 15, implicit killed $eflags

bb.1:
; predecessors: %bb.0
  successors: %bb.9(0x80000000); %bb.9(100.00%)

  renamable $rsi = MOV32ri64 1
  JMP_1 %bb.9

bb.2 (%ir-block.6):
; predecessors: %bb.0
  successors: %bb.3(0x40000000), %bb.4(0x40000000); %bb.3(50.00%), %bb.4(50.00%)
  liveins: $rdx
  renamable $rcx = LEA64r renamable $rdx, 1, $noreg, -1, $noreg
  renamable $eax = COPY renamable $edx, implicit-def $rax
  renamable $eax = AND32ri renamable $eax(tied-def 0), 7, implicit-def dead $eflags, implicit killed $rax, implicit-def $rax
  CMP64ri32 killed renamable $rcx, 7, implicit-def $eflags
  JCC_1 %bb.4, 3, implicit killed $eflags

bb.3:
; predecessors: %bb.2
  successors: %bb.6(0x80000000); %bb.6(100.00%)
  liveins: $rax
  renamable $rcx = MOV32ri64 1
  renamable $rsi = MOV32ri64 1
  JMP_1 %bb.6

bb.4 (%ir-block.12):
; predecessors: %bb.2
  successors: %bb.10(0x80000000); %bb.10(100.00%)
  liveins: $rax, $rdx
  renamable $edx = AND32ri renamable $edx(tied-def 0), -8, implicit-def dead $eflags, implicit killed $rdx, implicit-def $rdx
  renamable $rdx = NEG64r killed renamable $rdx(tied-def 0), implicit-def dead $eflags
  renamable $rsi = MOV32ri64 1
  renamable $rcx = MOV32ri64 8
  JMP_1 %bb.10

bb.5 (%ir-block.15):
; predecessors: %bb.10
  successors: %bb.6(0x80000000); %bb.6(100.00%)
  liveins: $rax, $rcx, $rsi
  renamable $rcx = ADD64ri32 killed renamable $rcx(tied-def 0), -7, implicit-def dead $eflags

bb.6 (%ir-block.17):
; predecessors: %bb.5, %bb.3
  successors: %bb.9(0x30000000), %bb.7(0x50000000); %bb.9(37.50%), %bb.7(62.50%)
  liveins: $rax, $rcx, $rsi
  TEST64rr renamable $rax, renamable $rax, implicit-def $eflags
  JCC_1 %bb.9, 4, implicit killed $eflags
  JMP_1 %bb.7

bb.7 (%ir-block.22):
; predecessors: %bb.6
  successors: %bb.8(0x80000000); %bb.8(100.00%)
  liveins: $rax, $rcx, $rsi

bb.8 (%ir-block.23):
; predecessors: %bb.7, %bb.8
  successors: %bb.9(0x04000000), %bb.8(0x7c000000); %bb.9(3.12%), %bb.8(96.88%)
  liveins: $rax, $rcx, $rsi
  renamable $rsi = IMUL64rr killed renamable $rsi(tied-def 0), renamable $rcx, implicit-def dead $eflags
  renamable $rcx = nuw nsw INC64r killed renamable $rcx(tied-def 0), implicit-def dead $eflags
  renamable $rax = DEC64r killed renamable $rax(tied-def 0), implicit-def $eflags
  JCC_1 %bb.8, 5, implicit killed $eflags
  JMP_1 %bb.9

bb.9 (%ir-block.31):
; predecessors: %bb.6, %bb.8, %bb.1
  liveins: $rsi
  renamable $rdi = LEA64r $rip, 1, $noreg, @.str.1, $noreg
  dead $eax = MOV32r0 implicit-def dead $eflags, implicit-def $al
  CALL64pcrel32 target-flags(x86-plt) @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
  $eax = MOV32r0 implicit-def dead $eflags
  $rcx = frame-destroy POP64r implicit-def $rsp, implicit $rsp
  frame-destroy CFI_INSTRUCTION def_cfa_offset 8
  RET 0, $eax

bb.10 (%ir-block.34):
; predecessors: %bb.4, %bb.10
  successors: %bb.5(0x04000000), %bb.10(0x7c000000); %bb.5(3.12%), %bb.10(96.88%)
  liveins: $rax, $rcx, $rdx, $rsi
  renamable $rdi = LEA64r renamable $rcx, 1, $noreg, -7, $noreg
  renamable $rdi = IMUL64rr killed renamable $rdi(tied-def 0), killed renamable $rsi, implicit-def dead $eflags
  renamable $rsi = LEA64r renamable $rcx, 1, $noreg, -6, $noreg
  renamable $r8 = LEA64r renamable $rcx, 1, $noreg, -5, $noreg
  renamable $rsi = IMUL64rr killed renamable $rsi(tied-def 0), killed renamable $r8, implicit-def dead $eflags
  renamable $rsi = IMUL64rr killed renamable $rsi(tied-def 0), killed renamable $rdi, implicit-def dead $eflags
  renamable $rdi = LEA64r renamable $rcx, 1, $noreg, -4, $noreg
  renamable $r8 = LEA64r renamable $rcx, 1, $noreg, -3, $noreg
  renamable $rdi = IMUL64rr killed renamable $rdi(tied-def 0), killed renamable $r8, implicit-def dead $eflags
  renamable $r8 = LEA64r renamable $rcx, 1, $noreg, -2, $noreg
  renamable $r8 = IMUL64rr killed renamable $r8(tied-def 0), killed renamable $rdi, implicit-def dead $eflags
  renamable $r8 = IMUL64rr killed renamable $r8(tied-def 0), killed renamable $rsi, implicit-def dead $eflags
  renamable $rsi = LEA64r renamable $rcx, 1, $noreg, -1, $noreg
  renamable $rsi = IMUL64rr killed renamable $rsi(tied-def 0), renamable $rcx, implicit-def dead $eflags
  renamable $rsi = IMUL64rr killed renamable $rsi(tied-def 0), killed renamable $r8, implicit-def dead $eflags
  renamable $rdi = LEA64r renamable $rdx, 1, renamable $rcx, 8, $noreg
  renamable $rcx = ADD64ri32 killed renamable $rcx(tied-def 0), 8, implicit-def dead $eflags
  CMP64ri32 killed renamable $rdi, 8, implicit-def $eflags
  JCC_1 %bb.5, 4, implicit killed $eflags
  JMP_1 %bb.10

# End machine code for function main.

# *** IR Dump After Machine Late Instructions Cleanup Pass (machine-latecleanup) ***:
# Machine code for function main: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
Frame Objects:
  fi#0: size=4, align=4, at location [SP-4]

bb.0 (%ir-block.0):
  successors: %bb.1(0x30000000), %bb.2(0x50000000); %bb.1(37.50%), %bb.2(62.50%)

  frame-setup PUSH64r undef $rax, implicit-def $rsp, implicit $rsp
  frame-setup CFI_INSTRUCTION def_cfa_offset 16
  renamable $rdi = LEA64r $rip, 1, $noreg, @.str, $noreg
  renamable $rsi = LEA64r $rsp, 1, $noreg, 4, $noreg
  dead $eax = MOV32r0 implicit-def dead $eflags, implicit-def $al
  CALL64pcrel32 target-flags(x86-plt) @__isoc99_scanf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
  renamable $edx = MOV32rm $rsp, 1, $noreg, 4, $noreg, implicit-def $rdx :: (dereferenceable load (s32) from %ir.1, !tbaa !5)
  TEST32rr renamable $edx, renamable $edx, implicit-def $eflags
  JCC_1 %bb.2, 15, implicit killed $eflags

bb.1:
; predecessors: %bb.0
  successors: %bb.9(0x80000000); %bb.9(100.00%)

  renamable $rsi = MOV32ri64 1
  JMP_1 %bb.9

bb.2 (%ir-block.6):
; predecessors: %bb.0
  successors: %bb.3(0x40000000), %bb.4(0x40000000); %bb.3(50.00%), %bb.4(50.00%)
  liveins: $rdx
  renamable $rcx = LEA64r renamable $rdx, 1, $noreg, -1, $noreg
  renamable $eax = COPY renamable $edx, implicit-def $rax
  renamable $eax = AND32ri renamable $eax(tied-def 0), 7, implicit-def dead $eflags, implicit killed $rax, implicit-def $rax
  CMP64ri32 killed renamable $rcx, 7, implicit-def $eflags
  JCC_1 %bb.4, 3, implicit killed $eflags

bb.3:
; predecessors: %bb.2
  successors: %bb.6(0x80000000); %bb.6(100.00%)
  liveins: $rax
  renamable $rcx = MOV32ri64 1
  renamable $rsi = MOV32ri64 1
  JMP_1 %bb.6

bb.4 (%ir-block.12):
; predecessors: %bb.2
  successors: %bb.10(0x80000000); %bb.10(100.00%)
  liveins: $rax, $rdx
  renamable $edx = AND32ri renamable $edx(tied-def 0), -8, implicit-def dead $eflags, implicit killed $rdx, implicit-def $rdx
  renamable $rdx = NEG64r killed renamable $rdx(tied-def 0), implicit-def dead $eflags
  renamable $rsi = MOV32ri64 1
  renamable $rcx = MOV32ri64 8
  JMP_1 %bb.10

bb.5 (%ir-block.15):
; predecessors: %bb.10
  successors: %bb.6(0x80000000); %bb.6(100.00%)
  liveins: $rax, $rcx, $rsi
  renamable $rcx = ADD64ri32 killed renamable $rcx(tied-def 0), -7, implicit-def dead $eflags

bb.6 (%ir-block.17):
; predecessors: %bb.5, %bb.3
  successors: %bb.9(0x30000000), %bb.7(0x50000000); %bb.9(37.50%), %bb.7(62.50%)
  liveins: $rax, $rcx, $rsi
  TEST64rr renamable $rax, renamable $rax, implicit-def $eflags
  JCC_1 %bb.9, 4, implicit killed $eflags
  JMP_1 %bb.7

bb.7 (%ir-block.22):
; predecessors: %bb.6
  successors: %bb.8(0x80000000); %bb.8(100.00%)
  liveins: $rax, $rcx, $rsi

bb.8 (%ir-block.23):
; predecessors: %bb.7, %bb.8
  successors: %bb.9(0x04000000), %bb.8(0x7c000000); %bb.9(3.12%), %bb.8(96.88%)
  liveins: $rax, $rcx, $rsi
  renamable $rsi = IMUL64rr killed renamable $rsi(tied-def 0), renamable $rcx, implicit-def dead $eflags
  renamable $rcx = nuw nsw INC64r killed renamable $rcx(tied-def 0), implicit-def dead $eflags
  renamable $rax = DEC64r killed renamable $rax(tied-def 0), implicit-def $eflags
  JCC_1 %bb.8, 5, implicit killed $eflags
  JMP_1 %bb.9

bb.9 (%ir-block.31):
; predecessors: %bb.6, %bb.8, %bb.1
  liveins: $rsi
  renamable $rdi = LEA64r $rip, 1, $noreg, @.str.1, $noreg
  dead $eax = MOV32r0 implicit-def dead $eflags, implicit-def $al
  CALL64pcrel32 target-flags(x86-plt) @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
  $eax = MOV32r0 implicit-def dead $eflags
  $rcx = frame-destroy POP64r implicit-def $rsp, implicit $rsp
  frame-destroy CFI_INSTRUCTION def_cfa_offset 8
  RET 0, $eax

bb.10 (%ir-block.34):
; predecessors: %bb.4, %bb.10
  successors: %bb.5(0x04000000), %bb.10(0x7c000000); %bb.5(3.12%), %bb.10(96.88%)
  liveins: $rax, $rcx, $rdx, $rsi
  renamable $rdi = LEA64r renamable $rcx, 1, $noreg, -7, $noreg
  renamable $rdi = IMUL64rr killed renamable $rdi(tied-def 0), killed renamable $rsi, implicit-def dead $eflags
  renamable $rsi = LEA64r renamable $rcx, 1, $noreg, -6, $noreg
  renamable $r8 = LEA64r renamable $rcx, 1, $noreg, -5, $noreg
  renamable $rsi = IMUL64rr killed renamable $rsi(tied-def 0), killed renamable $r8, implicit-def dead $eflags
  renamable $rsi = IMUL64rr killed renamable $rsi(tied-def 0), killed renamable $rdi, implicit-def dead $eflags
  renamable $rdi = LEA64r renamable $rcx, 1, $noreg, -4, $noreg
  renamable $r8 = LEA64r renamable $rcx, 1, $noreg, -3, $noreg
  renamable $rdi = IMUL64rr killed renamable $rdi(tied-def 0), killed renamable $r8, implicit-def dead $eflags
  renamable $r8 = LEA64r renamable $rcx, 1, $noreg, -2, $noreg
  renamable $r8 = IMUL64rr killed renamable $r8(tied-def 0), killed renamable $rdi, implicit-def dead $eflags
  renamable $r8 = IMUL64rr killed renamable $r8(tied-def 0), killed renamable $rsi, implicit-def dead $eflags
  renamable $rsi = LEA64r renamable $rcx, 1, $noreg, -1, $noreg
  renamable $rsi = IMUL64rr killed renamable $rsi(tied-def 0), renamable $rcx, implicit-def dead $eflags
  renamable $rsi = IMUL64rr killed renamable $rsi(tied-def 0), killed renamable $r8, implicit-def dead $eflags
  renamable $rdi = LEA64r renamable $rdx, 1, renamable $rcx, 8, $noreg
  renamable $rcx = ADD64ri32 killed renamable $rcx(tied-def 0), 8, implicit-def dead $eflags
  CMP64ri32 killed renamable $rdi, 8, implicit-def $eflags
  JCC_1 %bb.5, 4, implicit killed $eflags
  JMP_1 %bb.10

# End machine code for function main.

# *** IR Dump After Control Flow Optimizer (branch-folder) ***:
# Machine code for function main: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
Frame Objects:
  fi#0: size=4, align=4, at location [SP-4]

bb.0 (%ir-block.0):
  successors: %bb.1(0x30000000), %bb.2(0x50000000); %bb.1(37.50%), %bb.2(62.50%)

  frame-setup PUSH64r undef $rax, implicit-def $rsp, implicit $rsp
  frame-setup CFI_INSTRUCTION def_cfa_offset 16
  renamable $rdi = LEA64r $rip, 1, $noreg, @.str, $noreg
  renamable $rsi = LEA64r $rsp, 1, $noreg, 4, $noreg
  dead $eax = MOV32r0 implicit-def dead $eflags, implicit-def $al
  CALL64pcrel32 target-flags(x86-plt) @__isoc99_scanf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
  renamable $edx = MOV32rm $rsp, 1, $noreg, 4, $noreg, implicit-def $rdx :: (dereferenceable load (s32) from %ir.1, !tbaa !5)
  TEST32rr renamable $edx, renamable $edx, implicit-def $eflags
  JCC_1 %bb.2, 15, implicit killed $eflags

bb.1:
; predecessors: %bb.0
  successors: %bb.7(0x80000000); %bb.7(100.00%)

  renamable $rsi = MOV32ri64 1
  JMP_1 %bb.7

bb.2 (%ir-block.6):
; predecessors: %bb.0
  successors: %bb.3(0x40000000), %bb.8(0x40000000); %bb.3(50.00%), %bb.8(50.00%)
  liveins: $rdx
  renamable $rcx = LEA64r renamable $rdx, 1, $noreg, -1, $noreg
  renamable $eax = COPY renamable $edx, implicit-def $rax
  renamable $eax = AND32ri renamable $eax(tied-def 0), 7, implicit-def dead $eflags, implicit killed $rax, implicit-def $rax
  CMP64ri32 killed renamable $rcx, 7, implicit-def $eflags
  JCC_1 %bb.8, 3, implicit killed $eflags

bb.3:
; predecessors: %bb.2
  successors: %bb.5(0x80000000); %bb.5(100.00%)
  liveins: $rax
  renamable $rcx = MOV32ri64 1
  renamable $rsi = MOV32ri64 1
  JMP_1 %bb.5

bb.4 (%ir-block.15):
; predecessors: %bb.9
  successors: %bb.5(0x80000000); %bb.5(100.00%)
  liveins: $rax, $rcx, $rsi
  renamable $rcx = ADD64ri32 killed renamable $rcx(tied-def 0), -7, implicit-def dead $eflags

bb.5 (%ir-block.17):
; predecessors: %bb.4, %bb.3
  successors: %bb.7(0x30000000), %bb.6(0x50000000); %bb.7(37.50%), %bb.6(62.50%)
  liveins: $rax, $rcx, $rsi
  TEST64rr renamable $rax, renamable $rax, implicit-def $eflags
  JCC_1 %bb.7, 4, implicit $eflags

bb.6 (%ir-block.23):
; predecessors: %bb.6, %bb.5
  successors: %bb.7(0x04000000), %bb.6(0x7c000000); %bb.7(3.12%), %bb.6(96.88%)
  liveins: $rax, $rcx, $rsi
  renamable $rsi = IMUL64rr killed renamable $rsi(tied-def 0), renamable $rcx, implicit-def dead $eflags
  renamable $rcx = nuw nsw INC64r killed renamable $rcx(tied-def 0), implicit-def dead $eflags
  renamable $rax = DEC64r killed renamable $rax(tied-def 0), implicit-def $eflags
  JCC_1 %bb.6, 5, implicit killed $eflags

bb.7 (%ir-block.31):
; predecessors: %bb.5, %bb.6, %bb.1
  liveins: $rsi
  renamable $rdi = LEA64r $rip, 1, $noreg, @.str.1, $noreg
  dead $eax = MOV32r0 implicit-def dead $eflags, implicit-def $al
  CALL64pcrel32 target-flags(x86-plt) @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
  $eax = MOV32r0 implicit-def dead $eflags
  $rcx = frame-destroy POP64r implicit-def $rsp, implicit $rsp
  frame-destroy CFI_INSTRUCTION def_cfa_offset 8
  RET 0, $eax

bb.8 (%ir-block.12):
; predecessors: %bb.2
  successors: %bb.9(0x80000000); %bb.9(100.00%)
  liveins: $rax, $rdx
  renamable $edx = AND32ri renamable $edx(tied-def 0), -8, implicit-def dead $eflags, implicit killed $rdx, implicit-def $rdx
  renamable $rdx = NEG64r killed renamable $rdx(tied-def 0), implicit-def dead $eflags
  renamable $rsi = MOV32ri64 1
  renamable $rcx = MOV32ri64 8

bb.9 (%ir-block.34):
; predecessors: %bb.8, %bb.9
  successors: %bb.4(0x04000000), %bb.9(0x7c000000); %bb.4(3.12%), %bb.9(96.88%)
  liveins: $rax, $rcx, $rdx, $rsi
  renamable $rdi = LEA64r renamable $rcx, 1, $noreg, -7, $noreg
  renamable $rdi = IMUL64rr killed renamable $rdi(tied-def 0), killed renamable $rsi, implicit-def dead $eflags
  renamable $rsi = LEA64r renamable $rcx, 1, $noreg, -6, $noreg
  renamable $r8 = LEA64r renamable $rcx, 1, $noreg, -5, $noreg
  renamable $rsi = IMUL64rr killed renamable $rsi(tied-def 0), killed renamable $r8, implicit-def dead $eflags
  renamable $rsi = IMUL64rr killed renamable $rsi(tied-def 0), killed renamable $rdi, implicit-def dead $eflags
  renamable $rdi = LEA64r renamable $rcx, 1, $noreg, -4, $noreg
  renamable $r8 = LEA64r renamable $rcx, 1, $noreg, -3, $noreg
  renamable $rdi = IMUL64rr killed renamable $rdi(tied-def 0), killed renamable $r8, implicit-def dead $eflags
  renamable $r8 = LEA64r renamable $rcx, 1, $noreg, -2, $noreg
  renamable $r8 = IMUL64rr killed renamable $r8(tied-def 0), killed renamable $rdi, implicit-def dead $eflags
  renamable $r8 = IMUL64rr killed renamable $r8(tied-def 0), killed renamable $rsi, implicit-def dead $eflags
  renamable $rsi = LEA64r renamable $rcx, 1, $noreg, -1, $noreg
  renamable $rsi = IMUL64rr killed renamable $rsi(tied-def 0), renamable $rcx, implicit-def dead $eflags
  renamable $rsi = IMUL64rr killed renamable $rsi(tied-def 0), killed renamable $r8, implicit-def dead $eflags
  renamable $rdi = LEA64r renamable $rdx, 1, renamable $rcx, 8, $noreg
  renamable $rcx = ADD64ri32 killed renamable $rcx(tied-def 0), 8, implicit-def dead $eflags
  CMP64ri32 killed renamable $rdi, 8, implicit-def $eflags
  JCC_1 %bb.9, 5, implicit $eflags
  JMP_1 %bb.4

# End machine code for function main.

# *** IR Dump After Tail Duplication (tailduplication) ***:
# Machine code for function main: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
Frame Objects:
  fi#0: size=4, align=4, at location [SP-4]

bb.0 (%ir-block.0):
  successors: %bb.1(0x30000000), %bb.2(0x50000000); %bb.1(37.50%), %bb.2(62.50%)

  frame-setup PUSH64r undef $rax, implicit-def $rsp, implicit $rsp
  frame-setup CFI_INSTRUCTION def_cfa_offset 16
  renamable $rdi = LEA64r $rip, 1, $noreg, @.str, $noreg
  renamable $rsi = LEA64r $rsp, 1, $noreg, 4, $noreg
  dead $eax = MOV32r0 implicit-def dead $eflags, implicit-def $al
  CALL64pcrel32 target-flags(x86-plt) @__isoc99_scanf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
  renamable $edx = MOV32rm $rsp, 1, $noreg, 4, $noreg, implicit-def $rdx :: (dereferenceable load (s32) from %ir.1, !tbaa !5)
  TEST32rr renamable $edx, renamable $edx, implicit-def $eflags
  JCC_1 %bb.2, 15, implicit killed $eflags

bb.1:
; predecessors: %bb.0
  successors: %bb.7(0x80000000); %bb.7(100.00%)

  renamable $rsi = MOV32ri64 1
  JMP_1 %bb.7

bb.2 (%ir-block.6):
; predecessors: %bb.0
  successors: %bb.3(0x40000000), %bb.8(0x40000000); %bb.3(50.00%), %bb.8(50.00%)
  liveins: $rdx
  renamable $rcx = LEA64r renamable $rdx, 1, $noreg, -1, $noreg
  renamable $eax = COPY renamable $edx, implicit-def $rax
  renamable $eax = AND32ri renamable $eax(tied-def 0), 7, implicit-def dead $eflags, implicit killed $rax, implicit-def $rax
  CMP64ri32 killed renamable $rcx, 7, implicit-def $eflags
  JCC_1 %bb.8, 3, implicit killed $eflags

bb.3:
; predecessors: %bb.2
  successors: %bb.5(0x80000000); %bb.5(100.00%)
  liveins: $rax
  renamable $rcx = MOV32ri64 1
  renamable $rsi = MOV32ri64 1
  JMP_1 %bb.5

bb.4 (%ir-block.15):
; predecessors: %bb.9
  successors: %bb.5(0x80000000); %bb.5(100.00%)
  liveins: $rax, $rcx, $rsi
  renamable $rcx = ADD64ri32 killed renamable $rcx(tied-def 0), -7, implicit-def dead $eflags

bb.5 (%ir-block.17):
; predecessors: %bb.4, %bb.3
  successors: %bb.7(0x30000000), %bb.6(0x50000000); %bb.7(37.50%), %bb.6(62.50%)
  liveins: $rax, $rcx, $rsi
  TEST64rr renamable $rax, renamable $rax, implicit-def $eflags
  JCC_1 %bb.7, 4, implicit $eflags

bb.6 (%ir-block.23):
; predecessors: %bb.6, %bb.5
  successors: %bb.7(0x04000000), %bb.6(0x7c000000); %bb.7(3.12%), %bb.6(96.88%)
  liveins: $rax, $rcx, $rsi
  renamable $rsi = IMUL64rr killed renamable $rsi(tied-def 0), renamable $rcx, implicit-def dead $eflags
  renamable $rcx = nuw nsw INC64r killed renamable $rcx(tied-def 0), implicit-def dead $eflags
  renamable $rax = DEC64r killed renamable $rax(tied-def 0), implicit-def $eflags
  JCC_1 %bb.6, 5, implicit killed $eflags

bb.7 (%ir-block.31):
; predecessors: %bb.5, %bb.6, %bb.1
  liveins: $rsi
  renamable $rdi = LEA64r $rip, 1, $noreg, @.str.1, $noreg
  dead $eax = MOV32r0 implicit-def dead $eflags, implicit-def $al
  CALL64pcrel32 target-flags(x86-plt) @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
  $eax = MOV32r0 implicit-def dead $eflags
  $rcx = frame-destroy POP64r implicit-def $rsp, implicit $rsp
  frame-destroy CFI_INSTRUCTION def_cfa_offset 8
  RET 0, $eax

bb.8 (%ir-block.12):
; predecessors: %bb.2
  successors: %bb.9(0x80000000); %bb.9(100.00%)
  liveins: $rax, $rdx
  renamable $edx = AND32ri renamable $edx(tied-def 0), -8, implicit-def dead $eflags, implicit killed $rdx, implicit-def $rdx
  renamable $rdx = NEG64r killed renamable $rdx(tied-def 0), implicit-def dead $eflags
  renamable $rsi = MOV32ri64 1
  renamable $rcx = MOV32ri64 8

bb.9 (%ir-block.34):
; predecessors: %bb.8, %bb.9
  successors: %bb.4(0x04000000), %bb.9(0x7c000000); %bb.4(3.12%), %bb.9(96.88%)
  liveins: $rax, $rcx, $rdx, $rsi
  renamable $rdi = LEA64r renamable $rcx, 1, $noreg, -7, $noreg
  renamable $rdi = IMUL64rr killed renamable $rdi(tied-def 0), killed renamable $rsi, implicit-def dead $eflags
  renamable $rsi = LEA64r renamable $rcx, 1, $noreg, -6, $noreg
  renamable $r8 = LEA64r renamable $rcx, 1, $noreg, -5, $noreg
  renamable $rsi = IMUL64rr killed renamable $rsi(tied-def 0), killed renamable $r8, implicit-def dead $eflags
  renamable $rsi = IMUL64rr killed renamable $rsi(tied-def 0), killed renamable $rdi, implicit-def dead $eflags
  renamable $rdi = LEA64r renamable $rcx, 1, $noreg, -4, $noreg
  renamable $r8 = LEA64r renamable $rcx, 1, $noreg, -3, $noreg
  renamable $rdi = IMUL64rr killed renamable $rdi(tied-def 0), killed renamable $r8, implicit-def dead $eflags
  renamable $r8 = LEA64r renamable $rcx, 1, $noreg, -2, $noreg
  renamable $r8 = IMUL64rr killed renamable $r8(tied-def 0), killed renamable $rdi, implicit-def dead $eflags
  renamable $r8 = IMUL64rr killed renamable $r8(tied-def 0), killed renamable $rsi, implicit-def dead $eflags
  renamable $rsi = LEA64r renamable $rcx, 1, $noreg, -1, $noreg
  renamable $rsi = IMUL64rr killed renamable $rsi(tied-def 0), renamable $rcx, implicit-def dead $eflags
  renamable $rsi = IMUL64rr killed renamable $rsi(tied-def 0), killed renamable $r8, implicit-def dead $eflags
  renamable $rdi = LEA64r renamable $rdx, 1, renamable $rcx, 8, $noreg
  renamable $rcx = ADD64ri32 killed renamable $rcx(tied-def 0), 8, implicit-def dead $eflags
  CMP64ri32 killed renamable $rdi, 8, implicit-def $eflags
  JCC_1 %bb.9, 5, implicit $eflags
  JMP_1 %bb.4

# End machine code for function main.

# *** IR Dump After Machine Copy Propagation Pass (machine-cp) ***:
# Machine code for function main: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
Frame Objects:
  fi#0: size=4, align=4, at location [SP-4]

bb.0 (%ir-block.0):
  successors: %bb.1(0x30000000), %bb.2(0x50000000); %bb.1(37.50%), %bb.2(62.50%)

  frame-setup PUSH64r undef $rax, implicit-def $rsp, implicit $rsp
  frame-setup CFI_INSTRUCTION def_cfa_offset 16
  renamable $rdi = LEA64r $rip, 1, $noreg, @.str, $noreg
  renamable $rsi = LEA64r $rsp, 1, $noreg, 4, $noreg
  dead $eax = MOV32r0 implicit-def dead $eflags, implicit-def $al
  CALL64pcrel32 target-flags(x86-plt) @__isoc99_scanf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
  renamable $edx = MOV32rm $rsp, 1, $noreg, 4, $noreg, implicit-def $rdx :: (dereferenceable load (s32) from %ir.1, !tbaa !5)
  TEST32rr renamable $edx, renamable $edx, implicit-def $eflags
  JCC_1 %bb.2, 15, implicit killed $eflags

bb.1:
; predecessors: %bb.0
  successors: %bb.7(0x80000000); %bb.7(100.00%)

  renamable $rsi = MOV32ri64 1
  JMP_1 %bb.7

bb.2 (%ir-block.6):
; predecessors: %bb.0
  successors: %bb.3(0x40000000), %bb.8(0x40000000); %bb.3(50.00%), %bb.8(50.00%)
  liveins: $rdx
  renamable $rcx = LEA64r renamable $rdx, 1, $noreg, -1, $noreg
  renamable $eax = COPY renamable $edx, implicit-def $rax
  renamable $eax = AND32ri renamable $eax(tied-def 0), 7, implicit-def dead $eflags, implicit killed $rax, implicit-def $rax
  CMP64ri32 killed renamable $rcx, 7, implicit-def $eflags
  JCC_1 %bb.8, 3, implicit killed $eflags

bb.3:
; predecessors: %bb.2
  successors: %bb.5(0x80000000); %bb.5(100.00%)
  liveins: $rax
  renamable $rcx = MOV32ri64 1
  renamable $rsi = MOV32ri64 1
  JMP_1 %bb.5

bb.4 (%ir-block.15):
; predecessors: %bb.9
  successors: %bb.5(0x80000000); %bb.5(100.00%)
  liveins: $rax, $rcx, $rsi
  renamable $rcx = ADD64ri32 killed renamable $rcx(tied-def 0), -7, implicit-def dead $eflags

bb.5 (%ir-block.17):
; predecessors: %bb.4, %bb.3
  successors: %bb.7(0x30000000), %bb.6(0x50000000); %bb.7(37.50%), %bb.6(62.50%)
  liveins: $rax, $rcx, $rsi
  TEST64rr renamable $rax, renamable $rax, implicit-def $eflags
  JCC_1 %bb.7, 4, implicit $eflags

bb.6 (%ir-block.23):
; predecessors: %bb.6, %bb.5
  successors: %bb.7(0x04000000), %bb.6(0x7c000000); %bb.7(3.12%), %bb.6(96.88%)
  liveins: $rax, $rcx, $rsi
  renamable $rsi = IMUL64rr killed renamable $rsi(tied-def 0), renamable $rcx, implicit-def dead $eflags
  renamable $rcx = nuw nsw INC64r killed renamable $rcx(tied-def 0), implicit-def dead $eflags
  renamable $rax = DEC64r killed renamable $rax(tied-def 0), implicit-def $eflags
  JCC_1 %bb.6, 5, implicit killed $eflags

bb.7 (%ir-block.31):
; predecessors: %bb.5, %bb.6, %bb.1
  liveins: $rsi
  renamable $rdi = LEA64r $rip, 1, $noreg, @.str.1, $noreg
  dead $eax = MOV32r0 implicit-def dead $eflags, implicit-def $al
  CALL64pcrel32 target-flags(x86-plt) @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
  $eax = MOV32r0 implicit-def dead $eflags
  $rcx = frame-destroy POP64r implicit-def $rsp, implicit $rsp
  frame-destroy CFI_INSTRUCTION def_cfa_offset 8
  RET 0, $eax

bb.8 (%ir-block.12):
; predecessors: %bb.2
  successors: %bb.9(0x80000000); %bb.9(100.00%)
  liveins: $rax, $rdx
  renamable $edx = AND32ri renamable $edx(tied-def 0), -8, implicit-def dead $eflags, implicit killed $rdx, implicit-def $rdx
  renamable $rdx = NEG64r killed renamable $rdx(tied-def 0), implicit-def dead $eflags
  renamable $rsi = MOV32ri64 1
  renamable $rcx = MOV32ri64 8

bb.9 (%ir-block.34):
; predecessors: %bb.8, %bb.9
  successors: %bb.4(0x04000000), %bb.9(0x7c000000); %bb.4(3.12%), %bb.9(96.88%)
  liveins: $rax, $rcx, $rdx, $rsi
  renamable $rdi = LEA64r renamable $rcx, 1, $noreg, -7, $noreg
  renamable $rdi = IMUL64rr killed renamable $rdi(tied-def 0), killed renamable $rsi, implicit-def dead $eflags
  renamable $rsi = LEA64r renamable $rcx, 1, $noreg, -6, $noreg
  renamable $r8 = LEA64r renamable $rcx, 1, $noreg, -5, $noreg
  renamable $rsi = IMUL64rr killed renamable $rsi(tied-def 0), killed renamable $r8, implicit-def dead $eflags
  renamable $rsi = IMUL64rr killed renamable $rsi(tied-def 0), killed renamable $rdi, implicit-def dead $eflags
  renamable $rdi = LEA64r renamable $rcx, 1, $noreg, -4, $noreg
  renamable $r8 = LEA64r renamable $rcx, 1, $noreg, -3, $noreg
  renamable $rdi = IMUL64rr killed renamable $rdi(tied-def 0), killed renamable $r8, implicit-def dead $eflags
  renamable $r8 = LEA64r renamable $rcx, 1, $noreg, -2, $noreg
  renamable $r8 = IMUL64rr killed renamable $r8(tied-def 0), killed renamable $rdi, implicit-def dead $eflags
  renamable $r8 = IMUL64rr killed renamable $r8(tied-def 0), killed renamable $rsi, implicit-def dead $eflags
  renamable $rsi = LEA64r renamable $rcx, 1, $noreg, -1, $noreg
  renamable $rsi = IMUL64rr killed renamable $rsi(tied-def 0), renamable $rcx, implicit-def dead $eflags
  renamable $rsi = IMUL64rr killed renamable $rsi(tied-def 0), killed renamable $r8, implicit-def dead $eflags
  renamable $rdi = LEA64r renamable $rdx, 1, renamable $rcx, 8, $noreg
  renamable $rcx = ADD64ri32 killed renamable $rcx(tied-def 0), 8, implicit-def dead $eflags
  CMP64ri32 killed renamable $rdi, 8, implicit-def $eflags
  JCC_1 %bb.9, 5, implicit $eflags
  JMP_1 %bb.4

# End machine code for function main.

# *** IR Dump After Post-RA pseudo instruction expansion pass (postrapseudos) ***:
# Machine code for function main: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
Frame Objects:
  fi#0: size=4, align=4, at location [SP-4]

bb.0 (%ir-block.0):
  successors: %bb.1(0x30000000), %bb.2(0x50000000); %bb.1(37.50%), %bb.2(62.50%)

  frame-setup PUSH64r undef $rax, implicit-def $rsp, implicit $rsp
  frame-setup CFI_INSTRUCTION def_cfa_offset 16
  renamable $rdi = LEA64r $rip, 1, $noreg, @.str, $noreg
  renamable $rsi = LEA64r $rsp, 1, $noreg, 4, $noreg
  dead $eax = XOR32rr undef $eax(tied-def 0), undef $eax, implicit-def dead $eflags, implicit-def $al
  CALL64pcrel32 target-flags(x86-plt) @__isoc99_scanf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
  renamable $edx = MOV32rm $rsp, 1, $noreg, 4, $noreg, implicit-def $rdx :: (dereferenceable load (s32) from %ir.1, !tbaa !5)
  TEST32rr renamable $edx, renamable $edx, implicit-def $eflags
  JCC_1 %bb.2, 15, implicit killed $eflags

bb.1:
; predecessors: %bb.0
  successors: %bb.7(0x80000000); %bb.7(100.00%)

  $esi = MOV32ri 1, implicit-def $rsi
  JMP_1 %bb.7

bb.2 (%ir-block.6):
; predecessors: %bb.0
  successors: %bb.3(0x40000000), %bb.8(0x40000000); %bb.3(50.00%), %bb.8(50.00%)
  liveins: $rdx
  renamable $rcx = LEA64r renamable $rdx, 1, $noreg, -1, $noreg
  $eax = MOV32rr $edx, implicit-def $rax
  renamable $eax = AND32ri renamable $eax(tied-def 0), 7, implicit-def dead $eflags, implicit killed $rax, implicit-def $rax
  CMP64ri32 killed renamable $rcx, 7, implicit-def $eflags
  JCC_1 %bb.8, 3, implicit killed $eflags

bb.3:
; predecessors: %bb.2
  successors: %bb.5(0x80000000); %bb.5(100.00%)
  liveins: $rax
  $ecx = MOV32ri 1, implicit-def $rcx
  $esi = MOV32ri 1, implicit-def $rsi
  JMP_1 %bb.5

bb.4 (%ir-block.15):
; predecessors: %bb.9
  successors: %bb.5(0x80000000); %bb.5(100.00%)
  liveins: $rax, $rcx, $rsi
  renamable $rcx = ADD64ri32 killed renamable $rcx(tied-def 0), -7, implicit-def dead $eflags

bb.5 (%ir-block.17):
; predecessors: %bb.4, %bb.3
  successors: %bb.7(0x30000000), %bb.6(0x50000000); %bb.7(37.50%), %bb.6(62.50%)
  liveins: $rax, $rcx, $rsi
  TEST64rr renamable $rax, renamable $rax, implicit-def $eflags
  JCC_1 %bb.7, 4, implicit $eflags

bb.6 (%ir-block.23):
; predecessors: %bb.6, %bb.5
  successors: %bb.7(0x04000000), %bb.6(0x7c000000); %bb.7(3.12%), %bb.6(96.88%)
  liveins: $rax, $rcx, $rsi
  renamable $rsi = IMUL64rr killed renamable $rsi(tied-def 0), renamable $rcx, implicit-def dead $eflags
  renamable $rcx = nuw nsw INC64r killed renamable $rcx(tied-def 0), implicit-def dead $eflags
  renamable $rax = DEC64r killed renamable $rax(tied-def 0), implicit-def $eflags
  JCC_1 %bb.6, 5, implicit killed $eflags

bb.7 (%ir-block.31):
; predecessors: %bb.5, %bb.6, %bb.1
  liveins: $rsi
  renamable $rdi = LEA64r $rip, 1, $noreg, @.str.1, $noreg
  dead $eax = XOR32rr undef $eax(tied-def 0), undef $eax, implicit-def dead $eflags, implicit-def $al
  CALL64pcrel32 target-flags(x86-plt) @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
  $eax = XOR32rr undef $eax(tied-def 0), undef $eax, implicit-def dead $eflags
  $rcx = frame-destroy POP64r implicit-def $rsp, implicit $rsp
  frame-destroy CFI_INSTRUCTION def_cfa_offset 8
  RET 0, $eax

bb.8 (%ir-block.12):
; predecessors: %bb.2
  successors: %bb.9(0x80000000); %bb.9(100.00%)
  liveins: $rax, $rdx
  renamable $edx = AND32ri renamable $edx(tied-def 0), -8, implicit-def dead $eflags, implicit killed $rdx, implicit-def $rdx
  renamable $rdx = NEG64r killed renamable $rdx(tied-def 0), implicit-def dead $eflags
  $esi = MOV32ri 1, implicit-def $rsi
  $ecx = MOV32ri 8, implicit-def $rcx

bb.9 (%ir-block.34):
; predecessors: %bb.8, %bb.9
  successors: %bb.4(0x04000000), %bb.9(0x7c000000); %bb.4(3.12%), %bb.9(96.88%)
  liveins: $rax, $rcx, $rdx, $rsi
  renamable $rdi = LEA64r renamable $rcx, 1, $noreg, -7, $noreg
  renamable $rdi = IMUL64rr killed renamable $rdi(tied-def 0), killed renamable $rsi, implicit-def dead $eflags
  renamable $rsi = LEA64r renamable $rcx, 1, $noreg, -6, $noreg
  renamable $r8 = LEA64r renamable $rcx, 1, $noreg, -5, $noreg
  renamable $rsi = IMUL64rr killed renamable $rsi(tied-def 0), killed renamable $r8, implicit-def dead $eflags
  renamable $rsi = IMUL64rr killed renamable $rsi(tied-def 0), killed renamable $rdi, implicit-def dead $eflags
  renamable $rdi = LEA64r renamable $rcx, 1, $noreg, -4, $noreg
  renamable $r8 = LEA64r renamable $rcx, 1, $noreg, -3, $noreg
  renamable $rdi = IMUL64rr killed renamable $rdi(tied-def 0), killed renamable $r8, implicit-def dead $eflags
  renamable $r8 = LEA64r renamable $rcx, 1, $noreg, -2, $noreg
  renamable $r8 = IMUL64rr killed renamable $r8(tied-def 0), killed renamable $rdi, implicit-def dead $eflags
  renamable $r8 = IMUL64rr killed renamable $r8(tied-def 0), killed renamable $rsi, implicit-def dead $eflags
  renamable $rsi = LEA64r renamable $rcx, 1, $noreg, -1, $noreg
  renamable $rsi = IMUL64rr killed renamable $rsi(tied-def 0), renamable $rcx, implicit-def dead $eflags
  renamable $rsi = IMUL64rr killed renamable $rsi(tied-def 0), killed renamable $r8, implicit-def dead $eflags
  renamable $rdi = LEA64r renamable $rdx, 1, renamable $rcx, 8, $noreg
  renamable $rcx = ADD64ri32 killed renamable $rcx(tied-def 0), 8, implicit-def dead $eflags
  CMP64ri32 killed renamable $rdi, 8, implicit-def $eflags
  JCC_1 %bb.9, 5, implicit $eflags
  JMP_1 %bb.4

# End machine code for function main.

# *** IR Dump After X86 pseudo instruction expansion pass (x86-pseudo) ***:
# Machine code for function main: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
Frame Objects:
  fi#0: size=4, align=4, at location [SP-4]

bb.0 (%ir-block.0):
  successors: %bb.1(0x30000000), %bb.2(0x50000000); %bb.1(37.50%), %bb.2(62.50%)

  frame-setup PUSH64r undef $rax, implicit-def $rsp, implicit $rsp
  frame-setup CFI_INSTRUCTION def_cfa_offset 16
  renamable $rdi = LEA64r $rip, 1, $noreg, @.str, $noreg
  renamable $rsi = LEA64r $rsp, 1, $noreg, 4, $noreg
  dead $eax = XOR32rr undef $eax(tied-def 0), undef $eax, implicit-def dead $eflags, implicit-def $al
  CALL64pcrel32 target-flags(x86-plt) @__isoc99_scanf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
  renamable $edx = MOV32rm $rsp, 1, $noreg, 4, $noreg, implicit-def $rdx :: (dereferenceable load (s32) from %ir.1, !tbaa !5)
  TEST32rr renamable $edx, renamable $edx, implicit-def $eflags
  JCC_1 %bb.2, 15, implicit killed $eflags

bb.1:
; predecessors: %bb.0
  successors: %bb.7(0x80000000); %bb.7(100.00%)

  $esi = MOV32ri 1, implicit-def $rsi
  JMP_1 %bb.7

bb.2 (%ir-block.6):
; predecessors: %bb.0
  successors: %bb.3(0x40000000), %bb.8(0x40000000); %bb.3(50.00%), %bb.8(50.00%)
  liveins: $rdx
  renamable $rcx = LEA64r renamable $rdx, 1, $noreg, -1, $noreg
  $eax = MOV32rr $edx, implicit-def $rax
  renamable $eax = AND32ri renamable $eax(tied-def 0), 7, implicit-def dead $eflags, implicit killed $rax, implicit-def $rax
  CMP64ri32 killed renamable $rcx, 7, implicit-def $eflags
  JCC_1 %bb.8, 3, implicit killed $eflags

bb.3:
; predecessors: %bb.2
  successors: %bb.5(0x80000000); %bb.5(100.00%)
  liveins: $rax
  $ecx = MOV32ri 1, implicit-def $rcx
  $esi = MOV32ri 1, implicit-def $rsi
  JMP_1 %bb.5

bb.4 (%ir-block.15):
; predecessors: %bb.9
  successors: %bb.5(0x80000000); %bb.5(100.00%)
  liveins: $rax, $rcx, $rsi
  renamable $rcx = ADD64ri32 killed renamable $rcx(tied-def 0), -7, implicit-def dead $eflags

bb.5 (%ir-block.17):
; predecessors: %bb.4, %bb.3
  successors: %bb.7(0x30000000), %bb.6(0x50000000); %bb.7(37.50%), %bb.6(62.50%)
  liveins: $rax, $rcx, $rsi
  TEST64rr renamable $rax, renamable $rax, implicit-def $eflags
  JCC_1 %bb.7, 4, implicit $eflags

bb.6 (%ir-block.23):
; predecessors: %bb.6, %bb.5
  successors: %bb.7(0x04000000), %bb.6(0x7c000000); %bb.7(3.12%), %bb.6(96.88%)
  liveins: $rax, $rcx, $rsi
  renamable $rsi = IMUL64rr killed renamable $rsi(tied-def 0), renamable $rcx, implicit-def dead $eflags
  renamable $rcx = nuw nsw INC64r killed renamable $rcx(tied-def 0), implicit-def dead $eflags
  renamable $rax = DEC64r killed renamable $rax(tied-def 0), implicit-def $eflags
  JCC_1 %bb.6, 5, implicit killed $eflags

bb.7 (%ir-block.31):
; predecessors: %bb.5, %bb.6, %bb.1
  liveins: $rsi
  renamable $rdi = LEA64r $rip, 1, $noreg, @.str.1, $noreg
  dead $eax = XOR32rr undef $eax(tied-def 0), undef $eax, implicit-def dead $eflags, implicit-def $al
  CALL64pcrel32 target-flags(x86-plt) @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
  $eax = XOR32rr undef $eax(tied-def 0), undef $eax, implicit-def dead $eflags
  $rcx = frame-destroy POP64r implicit-def $rsp, implicit $rsp
  frame-destroy CFI_INSTRUCTION def_cfa_offset 8
  RET64 $eax

bb.8 (%ir-block.12):
; predecessors: %bb.2
  successors: %bb.9(0x80000000); %bb.9(100.00%)
  liveins: $rax, $rdx
  renamable $edx = AND32ri renamable $edx(tied-def 0), -8, implicit-def dead $eflags, implicit killed $rdx, implicit-def $rdx
  renamable $rdx = NEG64r killed renamable $rdx(tied-def 0), implicit-def dead $eflags
  $esi = MOV32ri 1, implicit-def $rsi
  $ecx = MOV32ri 8, implicit-def $rcx

bb.9 (%ir-block.34):
; predecessors: %bb.8, %bb.9
  successors: %bb.4(0x04000000), %bb.9(0x7c000000); %bb.4(3.12%), %bb.9(96.88%)
  liveins: $rax, $rcx, $rdx, $rsi
  renamable $rdi = LEA64r renamable $rcx, 1, $noreg, -7, $noreg
  renamable $rdi = IMUL64rr killed renamable $rdi(tied-def 0), killed renamable $rsi, implicit-def dead $eflags
  renamable $rsi = LEA64r renamable $rcx, 1, $noreg, -6, $noreg
  renamable $r8 = LEA64r renamable $rcx, 1, $noreg, -5, $noreg
  renamable $rsi = IMUL64rr killed renamable $rsi(tied-def 0), killed renamable $r8, implicit-def dead $eflags
  renamable $rsi = IMUL64rr killed renamable $rsi(tied-def 0), killed renamable $rdi, implicit-def dead $eflags
  renamable $rdi = LEA64r renamable $rcx, 1, $noreg, -4, $noreg
  renamable $r8 = LEA64r renamable $rcx, 1, $noreg, -3, $noreg
  renamable $rdi = IMUL64rr killed renamable $rdi(tied-def 0), killed renamable $r8, implicit-def dead $eflags
  renamable $r8 = LEA64r renamable $rcx, 1, $noreg, -2, $noreg
  renamable $r8 = IMUL64rr killed renamable $r8(tied-def 0), killed renamable $rdi, implicit-def dead $eflags
  renamable $r8 = IMUL64rr killed renamable $r8(tied-def 0), killed renamable $rsi, implicit-def dead $eflags
  renamable $rsi = LEA64r renamable $rcx, 1, $noreg, -1, $noreg
  renamable $rsi = IMUL64rr killed renamable $rsi(tied-def 0), renamable $rcx, implicit-def dead $eflags
  renamable $rsi = IMUL64rr killed renamable $rsi(tied-def 0), killed renamable $r8, implicit-def dead $eflags
  renamable $rdi = LEA64r renamable $rdx, 1, renamable $rcx, 8, $noreg
  renamable $rcx = ADD64ri32 killed renamable $rcx(tied-def 0), 8, implicit-def dead $eflags
  CMP64ri32 killed renamable $rdi, 8, implicit-def $eflags
  JCC_1 %bb.9, 5, implicit $eflags
  JMP_1 %bb.4

# End machine code for function main.

# *** IR Dump After Insert KCFI indirect call checks (kcfi) ***:
# Machine code for function main: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
Frame Objects:
  fi#0: size=4, align=4, at location [SP-4]

bb.0 (%ir-block.0):
  successors: %bb.1(0x30000000), %bb.2(0x50000000); %bb.1(37.50%), %bb.2(62.50%)

  frame-setup PUSH64r undef $rax, implicit-def $rsp, implicit $rsp
  frame-setup CFI_INSTRUCTION def_cfa_offset 16
  renamable $rdi = LEA64r $rip, 1, $noreg, @.str, $noreg
  renamable $rsi = LEA64r $rsp, 1, $noreg, 4, $noreg
  dead $eax = XOR32rr undef $eax(tied-def 0), undef $eax, implicit-def dead $eflags, implicit-def $al
  CALL64pcrel32 target-flags(x86-plt) @__isoc99_scanf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
  renamable $edx = MOV32rm $rsp, 1, $noreg, 4, $noreg, implicit-def $rdx :: (dereferenceable load (s32) from %ir.1, !tbaa !5)
  TEST32rr renamable $edx, renamable $edx, implicit-def $eflags
  JCC_1 %bb.2, 15, implicit killed $eflags

bb.1:
; predecessors: %bb.0
  successors: %bb.7(0x80000000); %bb.7(100.00%)

  $esi = MOV32ri 1, implicit-def $rsi
  JMP_1 %bb.7

bb.2 (%ir-block.6):
; predecessors: %bb.0
  successors: %bb.3(0x40000000), %bb.8(0x40000000); %bb.3(50.00%), %bb.8(50.00%)
  liveins: $rdx
  renamable $rcx = LEA64r renamable $rdx, 1, $noreg, -1, $noreg
  $eax = MOV32rr $edx, implicit-def $rax
  renamable $eax = AND32ri renamable $eax(tied-def 0), 7, implicit-def dead $eflags, implicit killed $rax, implicit-def $rax
  CMP64ri32 killed renamable $rcx, 7, implicit-def $eflags
  JCC_1 %bb.8, 3, implicit killed $eflags

bb.3:
; predecessors: %bb.2
  successors: %bb.5(0x80000000); %bb.5(100.00%)
  liveins: $rax
  $ecx = MOV32ri 1, implicit-def $rcx
  $esi = MOV32ri 1, implicit-def $rsi
  JMP_1 %bb.5

bb.4 (%ir-block.15):
; predecessors: %bb.9
  successors: %bb.5(0x80000000); %bb.5(100.00%)
  liveins: $rax, $rcx, $rsi
  renamable $rcx = ADD64ri32 killed renamable $rcx(tied-def 0), -7, implicit-def dead $eflags

bb.5 (%ir-block.17):
; predecessors: %bb.4, %bb.3
  successors: %bb.7(0x30000000), %bb.6(0x50000000); %bb.7(37.50%), %bb.6(62.50%)
  liveins: $rax, $rcx, $rsi
  TEST64rr renamable $rax, renamable $rax, implicit-def $eflags
  JCC_1 %bb.7, 4, implicit $eflags

bb.6 (%ir-block.23):
; predecessors: %bb.6, %bb.5
  successors: %bb.7(0x04000000), %bb.6(0x7c000000); %bb.7(3.12%), %bb.6(96.88%)
  liveins: $rax, $rcx, $rsi
  renamable $rsi = IMUL64rr killed renamable $rsi(tied-def 0), renamable $rcx, implicit-def dead $eflags
  renamable $rcx = nuw nsw INC64r killed renamable $rcx(tied-def 0), implicit-def dead $eflags
  renamable $rax = DEC64r killed renamable $rax(tied-def 0), implicit-def $eflags
  JCC_1 %bb.6, 5, implicit killed $eflags

bb.7 (%ir-block.31):
; predecessors: %bb.5, %bb.6, %bb.1
  liveins: $rsi
  renamable $rdi = LEA64r $rip, 1, $noreg, @.str.1, $noreg
  dead $eax = XOR32rr undef $eax(tied-def 0), undef $eax, implicit-def dead $eflags, implicit-def $al
  CALL64pcrel32 target-flags(x86-plt) @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
  $eax = XOR32rr undef $eax(tied-def 0), undef $eax, implicit-def dead $eflags
  $rcx = frame-destroy POP64r implicit-def $rsp, implicit $rsp
  frame-destroy CFI_INSTRUCTION def_cfa_offset 8
  RET64 $eax

bb.8 (%ir-block.12):
; predecessors: %bb.2
  successors: %bb.9(0x80000000); %bb.9(100.00%)
  liveins: $rax, $rdx
  renamable $edx = AND32ri renamable $edx(tied-def 0), -8, implicit-def dead $eflags, implicit killed $rdx, implicit-def $rdx
  renamable $rdx = NEG64r killed renamable $rdx(tied-def 0), implicit-def dead $eflags
  $esi = MOV32ri 1, implicit-def $rsi
  $ecx = MOV32ri 8, implicit-def $rcx

bb.9 (%ir-block.34):
; predecessors: %bb.8, %bb.9
  successors: %bb.4(0x04000000), %bb.9(0x7c000000); %bb.4(3.12%), %bb.9(96.88%)
  liveins: $rax, $rcx, $rdx, $rsi
  renamable $rdi = LEA64r renamable $rcx, 1, $noreg, -7, $noreg
  renamable $rdi = IMUL64rr killed renamable $rdi(tied-def 0), killed renamable $rsi, implicit-def dead $eflags
  renamable $rsi = LEA64r renamable $rcx, 1, $noreg, -6, $noreg
  renamable $r8 = LEA64r renamable $rcx, 1, $noreg, -5, $noreg
  renamable $rsi = IMUL64rr killed renamable $rsi(tied-def 0), killed renamable $r8, implicit-def dead $eflags
  renamable $rsi = IMUL64rr killed renamable $rsi(tied-def 0), killed renamable $rdi, implicit-def dead $eflags
  renamable $rdi = LEA64r renamable $rcx, 1, $noreg, -4, $noreg
  renamable $r8 = LEA64r renamable $rcx, 1, $noreg, -3, $noreg
  renamable $rdi = IMUL64rr killed renamable $rdi(tied-def 0), killed renamable $r8, implicit-def dead $eflags
  renamable $r8 = LEA64r renamable $rcx, 1, $noreg, -2, $noreg
  renamable $r8 = IMUL64rr killed renamable $r8(tied-def 0), killed renamable $rdi, implicit-def dead $eflags
  renamable $r8 = IMUL64rr killed renamable $r8(tied-def 0), killed renamable $rsi, implicit-def dead $eflags
  renamable $rsi = LEA64r renamable $rcx, 1, $noreg, -1, $noreg
  renamable $rsi = IMUL64rr killed renamable $rsi(tied-def 0), renamable $rcx, implicit-def dead $eflags
  renamable $rsi = IMUL64rr killed renamable $rsi(tied-def 0), killed renamable $r8, implicit-def dead $eflags
  renamable $rdi = LEA64r renamable $rdx, 1, renamable $rcx, 8, $noreg
  renamable $rcx = ADD64ri32 killed renamable $rcx(tied-def 0), 8, implicit-def dead $eflags
  CMP64ri32 killed renamable $rdi, 8, implicit-def $eflags
  JCC_1 %bb.9, 5, implicit $eflags
  JMP_1 %bb.4

# End machine code for function main.

# *** IR Dump After Post RA top-down list latency scheduler (post-RA-sched) ***:
# Machine code for function main: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
Frame Objects:
  fi#0: size=4, align=4, at location [SP-4]

bb.0 (%ir-block.0):
  successors: %bb.1(0x30000000), %bb.2(0x50000000); %bb.1(37.50%), %bb.2(62.50%)

  frame-setup PUSH64r undef $rax, implicit-def $rsp, implicit $rsp
  frame-setup CFI_INSTRUCTION def_cfa_offset 16
  renamable $rdi = LEA64r $rip, 1, $noreg, @.str, $noreg
  renamable $rsi = LEA64r $rsp, 1, $noreg, 4, $noreg
  dead $eax = XOR32rr undef $eax(tied-def 0), undef $eax, implicit-def dead $eflags, implicit-def $al
  CALL64pcrel32 target-flags(x86-plt) @__isoc99_scanf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
  renamable $edx = MOV32rm $rsp, 1, $noreg, 4, $noreg, implicit-def $rdx :: (dereferenceable load (s32) from %ir.1, !tbaa !5)
  TEST32rr renamable $edx, renamable $edx, implicit-def $eflags
  JCC_1 %bb.2, 15, implicit killed $eflags

bb.1:
; predecessors: %bb.0
  successors: %bb.7(0x80000000); %bb.7(100.00%)

  $esi = MOV32ri 1, implicit-def $rsi
  JMP_1 %bb.7

bb.2 (%ir-block.6):
; predecessors: %bb.0
  successors: %bb.3(0x40000000), %bb.8(0x40000000); %bb.3(50.00%), %bb.8(50.00%)
  liveins: $rdx
  renamable $rcx = LEA64r renamable $rdx, 1, $noreg, -1, $noreg
  $eax = MOV32rr $edx, implicit-def $rax
  renamable $eax = AND32ri renamable $eax(tied-def 0), 7, implicit-def dead $eflags, implicit killed $rax, implicit-def $rax
  CMP64ri32 killed renamable $rcx, 7, implicit-def $eflags
  JCC_1 %bb.8, 3, implicit killed $eflags

bb.3:
; predecessors: %bb.2
  successors: %bb.5(0x80000000); %bb.5(100.00%)
  liveins: $rax
  $ecx = MOV32ri 1, implicit-def $rcx
  $esi = MOV32ri 1, implicit-def $rsi
  JMP_1 %bb.5

bb.4 (%ir-block.15):
; predecessors: %bb.9
  successors: %bb.5(0x80000000); %bb.5(100.00%)
  liveins: $rax, $rcx, $rsi
  renamable $rcx = ADD64ri32 killed renamable $rcx(tied-def 0), -7, implicit-def dead $eflags

bb.5 (%ir-block.17):
; predecessors: %bb.4, %bb.3
  successors: %bb.7(0x30000000), %bb.6(0x50000000); %bb.7(37.50%), %bb.6(62.50%)
  liveins: $rax, $rcx, $rsi
  TEST64rr renamable $rax, renamable $rax, implicit-def $eflags
  JCC_1 %bb.7, 4, implicit $eflags

bb.6 (%ir-block.23):
; predecessors: %bb.6, %bb.5
  successors: %bb.7(0x04000000), %bb.6(0x7c000000); %bb.7(3.12%), %bb.6(96.88%)
  liveins: $rax, $rcx, $rsi
  renamable $rsi = IMUL64rr killed renamable $rsi(tied-def 0), renamable $rcx, implicit-def dead $eflags
  renamable $rcx = nuw nsw INC64r killed renamable $rcx(tied-def 0), implicit-def dead $eflags
  renamable $rax = DEC64r killed renamable $rax(tied-def 0), implicit-def $eflags
  JCC_1 %bb.6, 5, implicit killed $eflags

bb.7 (%ir-block.31):
; predecessors: %bb.5, %bb.6, %bb.1
  liveins: $rsi
  renamable $rdi = LEA64r $rip, 1, $noreg, @.str.1, $noreg
  dead $eax = XOR32rr undef $eax(tied-def 0), undef $eax, implicit-def dead $eflags, implicit-def $al
  CALL64pcrel32 target-flags(x86-plt) @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
  $eax = XOR32rr undef $eax(tied-def 0), undef $eax, implicit-def dead $eflags
  $rcx = frame-destroy POP64r implicit-def $rsp, implicit $rsp
  frame-destroy CFI_INSTRUCTION def_cfa_offset 8
  RET64 $eax

bb.8 (%ir-block.12):
; predecessors: %bb.2
  successors: %bb.9(0x80000000); %bb.9(100.00%)
  liveins: $rax, $rdx
  renamable $edx = AND32ri renamable $edx(tied-def 0), -8, implicit-def dead $eflags, implicit killed $rdx, implicit-def $rdx
  renamable $rdx = NEG64r killed renamable $rdx(tied-def 0), implicit-def dead $eflags
  $esi = MOV32ri 1, implicit-def $rsi
  $ecx = MOV32ri 8, implicit-def $rcx

bb.9 (%ir-block.34):
; predecessors: %bb.8, %bb.9
  successors: %bb.4(0x04000000), %bb.9(0x7c000000); %bb.4(3.12%), %bb.9(96.88%)
  liveins: $rax, $rcx, $rdx, $rsi
  renamable $rdi = LEA64r renamable $rcx, 1, $noreg, -7, $noreg
  renamable $rdi = IMUL64rr killed renamable $rdi(tied-def 0), killed renamable $rsi, implicit-def dead $eflags
  renamable $rsi = LEA64r renamable $rcx, 1, $noreg, -6, $noreg
  renamable $r8 = LEA64r renamable $rcx, 1, $noreg, -5, $noreg
  renamable $rsi = IMUL64rr killed renamable $rsi(tied-def 0), killed renamable $r8, implicit-def dead $eflags
  renamable $rsi = IMUL64rr killed renamable $rsi(tied-def 0), killed renamable $rdi, implicit-def dead $eflags
  renamable $rdi = LEA64r renamable $rcx, 1, $noreg, -4, $noreg
  renamable $r8 = LEA64r renamable $rcx, 1, $noreg, -3, $noreg
  renamable $rdi = IMUL64rr killed renamable $rdi(tied-def 0), killed renamable $r8, implicit-def dead $eflags
  renamable $r8 = LEA64r renamable $rcx, 1, $noreg, -2, $noreg
  renamable $r8 = IMUL64rr killed renamable $r8(tied-def 0), killed renamable $rdi, implicit-def dead $eflags
  renamable $r8 = IMUL64rr killed renamable $r8(tied-def 0), killed renamable $rsi, implicit-def dead $eflags
  renamable $rsi = LEA64r renamable $rcx, 1, $noreg, -1, $noreg
  renamable $rsi = IMUL64rr killed renamable $rsi(tied-def 0), renamable $rcx, implicit-def dead $eflags
  renamable $rsi = IMUL64rr killed renamable $rsi(tied-def 0), killed renamable $r8, implicit-def dead $eflags
  renamable $rdi = LEA64r renamable $rdx, 1, renamable $rcx, 8, $noreg
  renamable $rcx = ADD64ri32 killed renamable $rcx(tied-def 0), 8, implicit-def dead $eflags
  CMP64ri32 killed renamable $rdi, 8, implicit-def $eflags
  JCC_1 %bb.9, 5, implicit $eflags
  JMP_1 %bb.4

# End machine code for function main.

# *** IR Dump After Analyze Machine Code For Garbage Collection (gc-analysis) ***:
# Machine code for function main: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
Frame Objects:
  fi#0: size=4, align=4, at location [SP-4]

bb.0 (%ir-block.0):
  successors: %bb.1(0x30000000), %bb.2(0x50000000); %bb.1(37.50%), %bb.2(62.50%)

  frame-setup PUSH64r undef $rax, implicit-def $rsp, implicit $rsp
  frame-setup CFI_INSTRUCTION def_cfa_offset 16
  renamable $rdi = LEA64r $rip, 1, $noreg, @.str, $noreg
  renamable $rsi = LEA64r $rsp, 1, $noreg, 4, $noreg
  dead $eax = XOR32rr undef $eax(tied-def 0), undef $eax, implicit-def dead $eflags, implicit-def $al
  CALL64pcrel32 target-flags(x86-plt) @__isoc99_scanf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
  renamable $edx = MOV32rm $rsp, 1, $noreg, 4, $noreg, implicit-def $rdx :: (dereferenceable load (s32) from %ir.1, !tbaa !5)
  TEST32rr renamable $edx, renamable $edx, implicit-def $eflags
  JCC_1 %bb.2, 15, implicit killed $eflags

bb.1:
; predecessors: %bb.0
  successors: %bb.7(0x80000000); %bb.7(100.00%)

  $esi = MOV32ri 1, implicit-def $rsi
  JMP_1 %bb.7

bb.2 (%ir-block.6):
; predecessors: %bb.0
  successors: %bb.3(0x40000000), %bb.8(0x40000000); %bb.3(50.00%), %bb.8(50.00%)
  liveins: $rdx
  renamable $rcx = LEA64r renamable $rdx, 1, $noreg, -1, $noreg
  $eax = MOV32rr $edx, implicit-def $rax
  renamable $eax = AND32ri renamable $eax(tied-def 0), 7, implicit-def dead $eflags, implicit killed $rax, implicit-def $rax
  CMP64ri32 killed renamable $rcx, 7, implicit-def $eflags
  JCC_1 %bb.8, 3, implicit killed $eflags

bb.3:
; predecessors: %bb.2
  successors: %bb.5(0x80000000); %bb.5(100.00%)
  liveins: $rax
  $ecx = MOV32ri 1, implicit-def $rcx
  $esi = MOV32ri 1, implicit-def $rsi
  JMP_1 %bb.5

bb.4 (%ir-block.15):
; predecessors: %bb.9
  successors: %bb.5(0x80000000); %bb.5(100.00%)
  liveins: $rax, $rcx, $rsi
  renamable $rcx = ADD64ri32 killed renamable $rcx(tied-def 0), -7, implicit-def dead $eflags

bb.5 (%ir-block.17):
; predecessors: %bb.4, %bb.3
  successors: %bb.7(0x30000000), %bb.6(0x50000000); %bb.7(37.50%), %bb.6(62.50%)
  liveins: $rax, $rcx, $rsi
  TEST64rr renamable $rax, renamable $rax, implicit-def $eflags
  JCC_1 %bb.7, 4, implicit $eflags

bb.6 (%ir-block.23):
; predecessors: %bb.6, %bb.5
  successors: %bb.7(0x04000000), %bb.6(0x7c000000); %bb.7(3.12%), %bb.6(96.88%)
  liveins: $rax, $rcx, $rsi
  renamable $rsi = IMUL64rr killed renamable $rsi(tied-def 0), renamable $rcx, implicit-def dead $eflags
  renamable $rcx = nuw nsw INC64r killed renamable $rcx(tied-def 0), implicit-def dead $eflags
  renamable $rax = DEC64r killed renamable $rax(tied-def 0), implicit-def $eflags
  JCC_1 %bb.6, 5, implicit killed $eflags

bb.7 (%ir-block.31):
; predecessors: %bb.5, %bb.6, %bb.1
  liveins: $rsi
  renamable $rdi = LEA64r $rip, 1, $noreg, @.str.1, $noreg
  dead $eax = XOR32rr undef $eax(tied-def 0), undef $eax, implicit-def dead $eflags, implicit-def $al
  CALL64pcrel32 target-flags(x86-plt) @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
  $eax = XOR32rr undef $eax(tied-def 0), undef $eax, implicit-def dead $eflags
  $rcx = frame-destroy POP64r implicit-def $rsp, implicit $rsp
  frame-destroy CFI_INSTRUCTION def_cfa_offset 8
  RET64 $eax

bb.8 (%ir-block.12):
; predecessors: %bb.2
  successors: %bb.9(0x80000000); %bb.9(100.00%)
  liveins: $rax, $rdx
  renamable $edx = AND32ri renamable $edx(tied-def 0), -8, implicit-def dead $eflags, implicit killed $rdx, implicit-def $rdx
  renamable $rdx = NEG64r killed renamable $rdx(tied-def 0), implicit-def dead $eflags
  $esi = MOV32ri 1, implicit-def $rsi
  $ecx = MOV32ri 8, implicit-def $rcx

bb.9 (%ir-block.34):
; predecessors: %bb.8, %bb.9
  successors: %bb.4(0x04000000), %bb.9(0x7c000000); %bb.4(3.12%), %bb.9(96.88%)
  liveins: $rax, $rcx, $rdx, $rsi
  renamable $rdi = LEA64r renamable $rcx, 1, $noreg, -7, $noreg
  renamable $rdi = IMUL64rr killed renamable $rdi(tied-def 0), killed renamable $rsi, implicit-def dead $eflags
  renamable $rsi = LEA64r renamable $rcx, 1, $noreg, -6, $noreg
  renamable $r8 = LEA64r renamable $rcx, 1, $noreg, -5, $noreg
  renamable $rsi = IMUL64rr killed renamable $rsi(tied-def 0), killed renamable $r8, implicit-def dead $eflags
  renamable $rsi = IMUL64rr killed renamable $rsi(tied-def 0), killed renamable $rdi, implicit-def dead $eflags
  renamable $rdi = LEA64r renamable $rcx, 1, $noreg, -4, $noreg
  renamable $r8 = LEA64r renamable $rcx, 1, $noreg, -3, $noreg
  renamable $rdi = IMUL64rr killed renamable $rdi(tied-def 0), killed renamable $r8, implicit-def dead $eflags
  renamable $r8 = LEA64r renamable $rcx, 1, $noreg, -2, $noreg
  renamable $r8 = IMUL64rr killed renamable $r8(tied-def 0), killed renamable $rdi, implicit-def dead $eflags
  renamable $r8 = IMUL64rr killed renamable $r8(tied-def 0), killed renamable $rsi, implicit-def dead $eflags
  renamable $rsi = LEA64r renamable $rcx, 1, $noreg, -1, $noreg
  renamable $rsi = IMUL64rr killed renamable $rsi(tied-def 0), renamable $rcx, implicit-def dead $eflags
  renamable $rsi = IMUL64rr killed renamable $rsi(tied-def 0), killed renamable $r8, implicit-def dead $eflags
  renamable $rdi = LEA64r renamable $rdx, 1, renamable $rcx, 8, $noreg
  renamable $rcx = ADD64ri32 killed renamable $rcx(tied-def 0), 8, implicit-def dead $eflags
  CMP64ri32 killed renamable $rdi, 8, implicit-def $eflags
  JCC_1 %bb.9, 5, implicit $eflags
  JMP_1 %bb.4

# End machine code for function main.

# *** IR Dump After Branch Probability Basic Block Placement (block-placement) ***:
# Machine code for function main: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
Frame Objects:
  fi#0: size=4, align=4, at location [SP-4]

bb.0 (%ir-block.0):
  successors: %bb.1(0x30000000), %bb.2(0x50000000); %bb.1(37.50%), %bb.2(62.50%)

  frame-setup PUSH64r undef $rax, implicit-def $rsp, implicit $rsp
  frame-setup CFI_INSTRUCTION def_cfa_offset 16
  renamable $rdi = LEA64r $rip, 1, $noreg, @.str, $noreg
  renamable $rsi = LEA64r $rsp, 1, $noreg, 4, $noreg
  dead $eax = XOR32rr undef $eax(tied-def 0), undef $eax, implicit-def dead $eflags, implicit-def $al
  CALL64pcrel32 target-flags(x86-plt) @__isoc99_scanf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
  renamable $edx = MOV32rm $rsp, 1, $noreg, 4, $noreg, implicit-def $rdx :: (dereferenceable load (s32) from %ir.1, !tbaa !5)
  TEST32rr renamable $edx, renamable $edx, implicit-def $eflags
  JCC_1 %bb.1, 14, implicit $eflags

bb.2 (%ir-block.6):
; predecessors: %bb.0
  successors: %bb.3(0x40000000), %bb.8(0x40000000); %bb.3(50.00%), %bb.8(50.00%)
  liveins: $rdx
  renamable $rcx = LEA64r renamable $rdx, 1, $noreg, -1, $noreg
  $eax = MOV32rr $edx, implicit-def $rax
  renamable $eax = AND32ri renamable $eax(tied-def 0), 7, implicit-def dead $eflags, implicit killed $rax, implicit-def $rax
  CMP64ri32 killed renamable $rcx, 7, implicit-def $eflags
  JCC_1 %bb.8, 3, implicit killed $eflags

bb.3:
; predecessors: %bb.2
  successors: %bb.7(0x30000000), %bb.6(0x50000000); %bb.7(37.50%), %bb.6(62.50%)
  liveins: $rax
  $ecx = MOV32ri 1, implicit-def $rcx
  $esi = MOV32ri 1, implicit-def $rsi
  TEST64rr renamable $rax, renamable $rax, implicit-def $eflags
  JCC_1 %bb.6, 5, implicit $eflags
  JMP_1 %bb.7

bb.1:
; predecessors: %bb.0
  successors: %bb.7(0x80000000); %bb.7(100.00%)

  $esi = MOV32ri 1, implicit-def $rsi
  JMP_1 %bb.7

bb.8 (%ir-block.12):
; predecessors: %bb.2
  successors: %bb.9(0x80000000); %bb.9(100.00%)
  liveins: $rax, $rdx
  renamable $edx = AND32ri renamable $edx(tied-def 0), -8, implicit-def dead $eflags, implicit killed $rdx, implicit-def $rdx
  renamable $rdx = NEG64r killed renamable $rdx(tied-def 0), implicit-def dead $eflags
  $esi = MOV32ri 1, implicit-def $rsi
  $ecx = MOV32ri 8, implicit-def $rcx

bb.9 (%ir-block.34, align 16):
; predecessors: %bb.8, %bb.9
  successors: %bb.4(0x04000000), %bb.9(0x7c000000); %bb.4(3.12%), %bb.9(96.88%)
  liveins: $rax, $rcx, $rdx, $rsi
  renamable $rdi = LEA64r renamable $rcx, 1, $noreg, -7, $noreg
  renamable $rdi = IMUL64rr killed renamable $rdi(tied-def 0), killed renamable $rsi, implicit-def dead $eflags
  renamable $rsi = LEA64r renamable $rcx, 1, $noreg, -6, $noreg
  renamable $r8 = LEA64r renamable $rcx, 1, $noreg, -5, $noreg
  renamable $rsi = IMUL64rr killed renamable $rsi(tied-def 0), killed renamable $r8, implicit-def dead $eflags
  renamable $rsi = IMUL64rr killed renamable $rsi(tied-def 0), killed renamable $rdi, implicit-def dead $eflags
  renamable $rdi = LEA64r renamable $rcx, 1, $noreg, -4, $noreg
  renamable $r8 = LEA64r renamable $rcx, 1, $noreg, -3, $noreg
  renamable $rdi = IMUL64rr killed renamable $rdi(tied-def 0), killed renamable $r8, implicit-def dead $eflags
  renamable $r8 = LEA64r renamable $rcx, 1, $noreg, -2, $noreg
  renamable $r8 = IMUL64rr killed renamable $r8(tied-def 0), killed renamable $rdi, implicit-def dead $eflags
  renamable $r8 = IMUL64rr killed renamable $r8(tied-def 0), killed renamable $rsi, implicit-def dead $eflags
  renamable $rsi = LEA64r renamable $rcx, 1, $noreg, -1, $noreg
  renamable $rsi = IMUL64rr killed renamable $rsi(tied-def 0), renamable $rcx, implicit-def dead $eflags
  renamable $rsi = IMUL64rr killed renamable $rsi(tied-def 0), killed renamable $r8, implicit-def dead $eflags
  renamable $rdi = LEA64r renamable $rdx, 1, renamable $rcx, 8, $noreg
  renamable $rcx = ADD64ri32 killed renamable $rcx(tied-def 0), 8, implicit-def dead $eflags
  CMP64ri32 killed renamable $rdi, 8, implicit-def $eflags
  JCC_1 %bb.9, 5, implicit $eflags

bb.4 (%ir-block.15):
; predecessors: %bb.9
  successors: %bb.7(0x30000000), %bb.6(0x50000000); %bb.7(37.50%), %bb.6(62.50%)
  liveins: $rax, $rcx, $rsi
  renamable $rcx = ADD64ri32 killed renamable $rcx(tied-def 0), -7, implicit-def dead $eflags
  TEST64rr renamable $rax, renamable $rax, implicit-def $eflags
  JCC_1 %bb.7, 4, implicit $eflags

bb.6 (%ir-block.23, align 16):
; predecessors: %bb.6, %bb.4, %bb.3
  successors: %bb.7(0x04000000), %bb.6(0x7c000000); %bb.7(3.12%), %bb.6(96.88%)
  liveins: $rax, $rcx, $rsi
  renamable $rsi = IMUL64rr killed renamable $rsi(tied-def 0), renamable $rcx, implicit-def dead $eflags
  renamable $rcx = nuw nsw INC64r killed renamable $rcx(tied-def 0), implicit-def dead $eflags
  renamable $rax = DEC64r killed renamable $rax(tied-def 0), implicit-def $eflags
  JCC_1 %bb.6, 5, implicit killed $eflags

bb.7 (%ir-block.31):
; predecessors: %bb.6, %bb.1, %bb.4, %bb.3
  liveins: $rsi
  renamable $rdi = LEA64r $rip, 1, $noreg, @.str.1, $noreg
  dead $eax = XOR32rr undef $eax(tied-def 0), undef $eax, implicit-def dead $eflags, implicit-def $al
  CALL64pcrel32 target-flags(x86-plt) @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
  $eax = XOR32rr undef $eax(tied-def 0), undef $eax, implicit-def dead $eflags
  $rcx = frame-destroy POP64r implicit-def $rsp, implicit $rsp
  frame-destroy CFI_INSTRUCTION def_cfa_offset 8
  RET64 $eax

# End machine code for function main.

# *** IR Dump After Insert fentry calls (fentry-insert) ***:
# Machine code for function main: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
Frame Objects:
  fi#0: size=4, align=4, at location [SP-4]

bb.0 (%ir-block.0):
  successors: %bb.1(0x30000000), %bb.2(0x50000000); %bb.1(37.50%), %bb.2(62.50%)

  frame-setup PUSH64r undef $rax, implicit-def $rsp, implicit $rsp
  frame-setup CFI_INSTRUCTION def_cfa_offset 16
  renamable $rdi = LEA64r $rip, 1, $noreg, @.str, $noreg
  renamable $rsi = LEA64r $rsp, 1, $noreg, 4, $noreg
  dead $eax = XOR32rr undef $eax(tied-def 0), undef $eax, implicit-def dead $eflags, implicit-def $al
  CALL64pcrel32 target-flags(x86-plt) @__isoc99_scanf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
  renamable $edx = MOV32rm $rsp, 1, $noreg, 4, $noreg, implicit-def $rdx :: (dereferenceable load (s32) from %ir.1, !tbaa !5)
  TEST32rr renamable $edx, renamable $edx, implicit-def $eflags
  JCC_1 %bb.1, 14, implicit $eflags

bb.2 (%ir-block.6):
; predecessors: %bb.0
  successors: %bb.3(0x40000000), %bb.8(0x40000000); %bb.3(50.00%), %bb.8(50.00%)
  liveins: $rdx
  renamable $rcx = LEA64r renamable $rdx, 1, $noreg, -1, $noreg
  $eax = MOV32rr $edx, implicit-def $rax
  renamable $eax = AND32ri renamable $eax(tied-def 0), 7, implicit-def dead $eflags, implicit killed $rax, implicit-def $rax
  CMP64ri32 killed renamable $rcx, 7, implicit-def $eflags
  JCC_1 %bb.8, 3, implicit killed $eflags

bb.3:
; predecessors: %bb.2
  successors: %bb.7(0x30000000), %bb.6(0x50000000); %bb.7(37.50%), %bb.6(62.50%)
  liveins: $rax
  $ecx = MOV32ri 1, implicit-def $rcx
  $esi = MOV32ri 1, implicit-def $rsi
  TEST64rr renamable $rax, renamable $rax, implicit-def $eflags
  JCC_1 %bb.6, 5, implicit $eflags
  JMP_1 %bb.7

bb.1:
; predecessors: %bb.0
  successors: %bb.7(0x80000000); %bb.7(100.00%)

  $esi = MOV32ri 1, implicit-def $rsi
  JMP_1 %bb.7

bb.8 (%ir-block.12):
; predecessors: %bb.2
  successors: %bb.9(0x80000000); %bb.9(100.00%)
  liveins: $rax, $rdx
  renamable $edx = AND32ri renamable $edx(tied-def 0), -8, implicit-def dead $eflags, implicit killed $rdx, implicit-def $rdx
  renamable $rdx = NEG64r killed renamable $rdx(tied-def 0), implicit-def dead $eflags
  $esi = MOV32ri 1, implicit-def $rsi
  $ecx = MOV32ri 8, implicit-def $rcx

bb.9 (%ir-block.34, align 16):
; predecessors: %bb.8, %bb.9
  successors: %bb.4(0x04000000), %bb.9(0x7c000000); %bb.4(3.12%), %bb.9(96.88%)
  liveins: $rax, $rcx, $rdx, $rsi
  renamable $rdi = LEA64r renamable $rcx, 1, $noreg, -7, $noreg
  renamable $rdi = IMUL64rr killed renamable $rdi(tied-def 0), killed renamable $rsi, implicit-def dead $eflags
  renamable $rsi = LEA64r renamable $rcx, 1, $noreg, -6, $noreg
  renamable $r8 = LEA64r renamable $rcx, 1, $noreg, -5, $noreg
  renamable $rsi = IMUL64rr killed renamable $rsi(tied-def 0), killed renamable $r8, implicit-def dead $eflags
  renamable $rsi = IMUL64rr killed renamable $rsi(tied-def 0), killed renamable $rdi, implicit-def dead $eflags
  renamable $rdi = LEA64r renamable $rcx, 1, $noreg, -4, $noreg
  renamable $r8 = LEA64r renamable $rcx, 1, $noreg, -3, $noreg
  renamable $rdi = IMUL64rr killed renamable $rdi(tied-def 0), killed renamable $r8, implicit-def dead $eflags
  renamable $r8 = LEA64r renamable $rcx, 1, $noreg, -2, $noreg
  renamable $r8 = IMUL64rr killed renamable $r8(tied-def 0), killed renamable $rdi, implicit-def dead $eflags
  renamable $r8 = IMUL64rr killed renamable $r8(tied-def 0), killed renamable $rsi, implicit-def dead $eflags
  renamable $rsi = LEA64r renamable $rcx, 1, $noreg, -1, $noreg
  renamable $rsi = IMUL64rr killed renamable $rsi(tied-def 0), renamable $rcx, implicit-def dead $eflags
  renamable $rsi = IMUL64rr killed renamable $rsi(tied-def 0), killed renamable $r8, implicit-def dead $eflags
  renamable $rdi = LEA64r renamable $rdx, 1, renamable $rcx, 8, $noreg
  renamable $rcx = ADD64ri32 killed renamable $rcx(tied-def 0), 8, implicit-def dead $eflags
  CMP64ri32 killed renamable $rdi, 8, implicit-def $eflags
  JCC_1 %bb.9, 5, implicit $eflags

bb.4 (%ir-block.15):
; predecessors: %bb.9
  successors: %bb.7(0x30000000), %bb.6(0x50000000); %bb.7(37.50%), %bb.6(62.50%)
  liveins: $rax, $rcx, $rsi
  renamable $rcx = ADD64ri32 killed renamable $rcx(tied-def 0), -7, implicit-def dead $eflags
  TEST64rr renamable $rax, renamable $rax, implicit-def $eflags
  JCC_1 %bb.7, 4, implicit $eflags

bb.6 (%ir-block.23, align 16):
; predecessors: %bb.6, %bb.4, %bb.3
  successors: %bb.7(0x04000000), %bb.6(0x7c000000); %bb.7(3.12%), %bb.6(96.88%)
  liveins: $rax, $rcx, $rsi
  renamable $rsi = IMUL64rr killed renamable $rsi(tied-def 0), renamable $rcx, implicit-def dead $eflags
  renamable $rcx = nuw nsw INC64r killed renamable $rcx(tied-def 0), implicit-def dead $eflags
  renamable $rax = DEC64r killed renamable $rax(tied-def 0), implicit-def $eflags
  JCC_1 %bb.6, 5, implicit killed $eflags

bb.7 (%ir-block.31):
; predecessors: %bb.6, %bb.1, %bb.4, %bb.3
  liveins: $rsi
  renamable $rdi = LEA64r $rip, 1, $noreg, @.str.1, $noreg
  dead $eax = XOR32rr undef $eax(tied-def 0), undef $eax, implicit-def dead $eflags, implicit-def $al
  CALL64pcrel32 target-flags(x86-plt) @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
  $eax = XOR32rr undef $eax(tied-def 0), undef $eax, implicit-def dead $eflags
  $rcx = frame-destroy POP64r implicit-def $rsp, implicit $rsp
  frame-destroy CFI_INSTRUCTION def_cfa_offset 8
  RET64 $eax

# End machine code for function main.

# *** IR Dump After Insert XRay ops (xray-instrumentation) ***:
# Machine code for function main: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
Frame Objects:
  fi#0: size=4, align=4, at location [SP-4]

bb.0 (%ir-block.0):
  successors: %bb.1(0x30000000), %bb.2(0x50000000); %bb.1(37.50%), %bb.2(62.50%)

  frame-setup PUSH64r undef $rax, implicit-def $rsp, implicit $rsp
  frame-setup CFI_INSTRUCTION def_cfa_offset 16
  renamable $rdi = LEA64r $rip, 1, $noreg, @.str, $noreg
  renamable $rsi = LEA64r $rsp, 1, $noreg, 4, $noreg
  dead $eax = XOR32rr undef $eax(tied-def 0), undef $eax, implicit-def dead $eflags, implicit-def $al
  CALL64pcrel32 target-flags(x86-plt) @__isoc99_scanf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
  renamable $edx = MOV32rm $rsp, 1, $noreg, 4, $noreg, implicit-def $rdx :: (dereferenceable load (s32) from %ir.1, !tbaa !5)
  TEST32rr renamable $edx, renamable $edx, implicit-def $eflags
  JCC_1 %bb.1, 14, implicit $eflags

bb.2 (%ir-block.6):
; predecessors: %bb.0
  successors: %bb.3(0x40000000), %bb.8(0x40000000); %bb.3(50.00%), %bb.8(50.00%)
  liveins: $rdx
  renamable $rcx = LEA64r renamable $rdx, 1, $noreg, -1, $noreg
  $eax = MOV32rr $edx, implicit-def $rax
  renamable $eax = AND32ri renamable $eax(tied-def 0), 7, implicit-def dead $eflags, implicit killed $rax, implicit-def $rax
  CMP64ri32 killed renamable $rcx, 7, implicit-def $eflags
  JCC_1 %bb.8, 3, implicit killed $eflags

bb.3:
; predecessors: %bb.2
  successors: %bb.7(0x30000000), %bb.6(0x50000000); %bb.7(37.50%), %bb.6(62.50%)
  liveins: $rax
  $ecx = MOV32ri 1, implicit-def $rcx
  $esi = MOV32ri 1, implicit-def $rsi
  TEST64rr renamable $rax, renamable $rax, implicit-def $eflags
  JCC_1 %bb.6, 5, implicit $eflags
  JMP_1 %bb.7

bb.1:
; predecessors: %bb.0
  successors: %bb.7(0x80000000); %bb.7(100.00%)

  $esi = MOV32ri 1, implicit-def $rsi
  JMP_1 %bb.7

bb.8 (%ir-block.12):
; predecessors: %bb.2
  successors: %bb.9(0x80000000); %bb.9(100.00%)
  liveins: $rax, $rdx
  renamable $edx = AND32ri renamable $edx(tied-def 0), -8, implicit-def dead $eflags, implicit killed $rdx, implicit-def $rdx
  renamable $rdx = NEG64r killed renamable $rdx(tied-def 0), implicit-def dead $eflags
  $esi = MOV32ri 1, implicit-def $rsi
  $ecx = MOV32ri 8, implicit-def $rcx

bb.9 (%ir-block.34, align 16):
; predecessors: %bb.8, %bb.9
  successors: %bb.4(0x04000000), %bb.9(0x7c000000); %bb.4(3.12%), %bb.9(96.88%)
  liveins: $rax, $rcx, $rdx, $rsi
  renamable $rdi = LEA64r renamable $rcx, 1, $noreg, -7, $noreg
  renamable $rdi = IMUL64rr killed renamable $rdi(tied-def 0), killed renamable $rsi, implicit-def dead $eflags
  renamable $rsi = LEA64r renamable $rcx, 1, $noreg, -6, $noreg
  renamable $r8 = LEA64r renamable $rcx, 1, $noreg, -5, $noreg
  renamable $rsi = IMUL64rr killed renamable $rsi(tied-def 0), killed renamable $r8, implicit-def dead $eflags
  renamable $rsi = IMUL64rr killed renamable $rsi(tied-def 0), killed renamable $rdi, implicit-def dead $eflags
  renamable $rdi = LEA64r renamable $rcx, 1, $noreg, -4, $noreg
  renamable $r8 = LEA64r renamable $rcx, 1, $noreg, -3, $noreg
  renamable $rdi = IMUL64rr killed renamable $rdi(tied-def 0), killed renamable $r8, implicit-def dead $eflags
  renamable $r8 = LEA64r renamable $rcx, 1, $noreg, -2, $noreg
  renamable $r8 = IMUL64rr killed renamable $r8(tied-def 0), killed renamable $rdi, implicit-def dead $eflags
  renamable $r8 = IMUL64rr killed renamable $r8(tied-def 0), killed renamable $rsi, implicit-def dead $eflags
  renamable $rsi = LEA64r renamable $rcx, 1, $noreg, -1, $noreg
  renamable $rsi = IMUL64rr killed renamable $rsi(tied-def 0), renamable $rcx, implicit-def dead $eflags
  renamable $rsi = IMUL64rr killed renamable $rsi(tied-def 0), killed renamable $r8, implicit-def dead $eflags
  renamable $rdi = LEA64r renamable $rdx, 1, renamable $rcx, 8, $noreg
  renamable $rcx = ADD64ri32 killed renamable $rcx(tied-def 0), 8, implicit-def dead $eflags
  CMP64ri32 killed renamable $rdi, 8, implicit-def $eflags
  JCC_1 %bb.9, 5, implicit $eflags

bb.4 (%ir-block.15):
; predecessors: %bb.9
  successors: %bb.7(0x30000000), %bb.6(0x50000000); %bb.7(37.50%), %bb.6(62.50%)
  liveins: $rax, $rcx, $rsi
  renamable $rcx = ADD64ri32 killed renamable $rcx(tied-def 0), -7, implicit-def dead $eflags
  TEST64rr renamable $rax, renamable $rax, implicit-def $eflags
  JCC_1 %bb.7, 4, implicit $eflags

bb.6 (%ir-block.23, align 16):
; predecessors: %bb.6, %bb.4, %bb.3
  successors: %bb.7(0x04000000), %bb.6(0x7c000000); %bb.7(3.12%), %bb.6(96.88%)
  liveins: $rax, $rcx, $rsi
  renamable $rsi = IMUL64rr killed renamable $rsi(tied-def 0), renamable $rcx, implicit-def dead $eflags
  renamable $rcx = nuw nsw INC64r killed renamable $rcx(tied-def 0), implicit-def dead $eflags
  renamable $rax = DEC64r killed renamable $rax(tied-def 0), implicit-def $eflags
  JCC_1 %bb.6, 5, implicit killed $eflags

bb.7 (%ir-block.31):
; predecessors: %bb.6, %bb.1, %bb.4, %bb.3
  liveins: $rsi
  renamable $rdi = LEA64r $rip, 1, $noreg, @.str.1, $noreg
  dead $eax = XOR32rr undef $eax(tied-def 0), undef $eax, implicit-def dead $eflags, implicit-def $al
  CALL64pcrel32 target-flags(x86-plt) @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
  $eax = XOR32rr undef $eax(tied-def 0), undef $eax, implicit-def dead $eflags
  $rcx = frame-destroy POP64r implicit-def $rsp, implicit $rsp
  frame-destroy CFI_INSTRUCTION def_cfa_offset 8
  RET64 $eax

# End machine code for function main.

# *** IR Dump After Implement the 'patchable-function' attribute (patchable-function) ***:
# Machine code for function main: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
Frame Objects:
  fi#0: size=4, align=4, at location [SP-4]

bb.0 (%ir-block.0):
  successors: %bb.1(0x30000000), %bb.2(0x50000000); %bb.1(37.50%), %bb.2(62.50%)

  frame-setup PUSH64r undef $rax, implicit-def $rsp, implicit $rsp
  frame-setup CFI_INSTRUCTION def_cfa_offset 16
  renamable $rdi = LEA64r $rip, 1, $noreg, @.str, $noreg
  renamable $rsi = LEA64r $rsp, 1, $noreg, 4, $noreg
  dead $eax = XOR32rr undef $eax(tied-def 0), undef $eax, implicit-def dead $eflags, implicit-def $al
  CALL64pcrel32 target-flags(x86-plt) @__isoc99_scanf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
  renamable $edx = MOV32rm $rsp, 1, $noreg, 4, $noreg, implicit-def $rdx :: (dereferenceable load (s32) from %ir.1, !tbaa !5)
  TEST32rr renamable $edx, renamable $edx, implicit-def $eflags
  JCC_1 %bb.1, 14, implicit $eflags

bb.2 (%ir-block.6):
; predecessors: %bb.0
  successors: %bb.3(0x40000000), %bb.8(0x40000000); %bb.3(50.00%), %bb.8(50.00%)
  liveins: $rdx
  renamable $rcx = LEA64r renamable $rdx, 1, $noreg, -1, $noreg
  $eax = MOV32rr $edx, implicit-def $rax
  renamable $eax = AND32ri renamable $eax(tied-def 0), 7, implicit-def dead $eflags, implicit killed $rax, implicit-def $rax
  CMP64ri32 killed renamable $rcx, 7, implicit-def $eflags
  JCC_1 %bb.8, 3, implicit killed $eflags

bb.3:
; predecessors: %bb.2
  successors: %bb.7(0x30000000), %bb.6(0x50000000); %bb.7(37.50%), %bb.6(62.50%)
  liveins: $rax
  $ecx = MOV32ri 1, implicit-def $rcx
  $esi = MOV32ri 1, implicit-def $rsi
  TEST64rr renamable $rax, renamable $rax, implicit-def $eflags
  JCC_1 %bb.6, 5, implicit $eflags
  JMP_1 %bb.7

bb.1:
; predecessors: %bb.0
  successors: %bb.7(0x80000000); %bb.7(100.00%)

  $esi = MOV32ri 1, implicit-def $rsi
  JMP_1 %bb.7

bb.8 (%ir-block.12):
; predecessors: %bb.2
  successors: %bb.9(0x80000000); %bb.9(100.00%)
  liveins: $rax, $rdx
  renamable $edx = AND32ri renamable $edx(tied-def 0), -8, implicit-def dead $eflags, implicit killed $rdx, implicit-def $rdx
  renamable $rdx = NEG64r killed renamable $rdx(tied-def 0), implicit-def dead $eflags
  $esi = MOV32ri 1, implicit-def $rsi
  $ecx = MOV32ri 8, implicit-def $rcx

bb.9 (%ir-block.34, align 16):
; predecessors: %bb.8, %bb.9
  successors: %bb.4(0x04000000), %bb.9(0x7c000000); %bb.4(3.12%), %bb.9(96.88%)
  liveins: $rax, $rcx, $rdx, $rsi
  renamable $rdi = LEA64r renamable $rcx, 1, $noreg, -7, $noreg
  renamable $rdi = IMUL64rr killed renamable $rdi(tied-def 0), killed renamable $rsi, implicit-def dead $eflags
  renamable $rsi = LEA64r renamable $rcx, 1, $noreg, -6, $noreg
  renamable $r8 = LEA64r renamable $rcx, 1, $noreg, -5, $noreg
  renamable $rsi = IMUL64rr killed renamable $rsi(tied-def 0), killed renamable $r8, implicit-def dead $eflags
  renamable $rsi = IMUL64rr killed renamable $rsi(tied-def 0), killed renamable $rdi, implicit-def dead $eflags
  renamable $rdi = LEA64r renamable $rcx, 1, $noreg, -4, $noreg
  renamable $r8 = LEA64r renamable $rcx, 1, $noreg, -3, $noreg
  renamable $rdi = IMUL64rr killed renamable $rdi(tied-def 0), killed renamable $r8, implicit-def dead $eflags
  renamable $r8 = LEA64r renamable $rcx, 1, $noreg, -2, $noreg
  renamable $r8 = IMUL64rr killed renamable $r8(tied-def 0), killed renamable $rdi, implicit-def dead $eflags
  renamable $r8 = IMUL64rr killed renamable $r8(tied-def 0), killed renamable $rsi, implicit-def dead $eflags
  renamable $rsi = LEA64r renamable $rcx, 1, $noreg, -1, $noreg
  renamable $rsi = IMUL64rr killed renamable $rsi(tied-def 0), renamable $rcx, implicit-def dead $eflags
  renamable $rsi = IMUL64rr killed renamable $rsi(tied-def 0), killed renamable $r8, implicit-def dead $eflags
  renamable $rdi = LEA64r renamable $rdx, 1, renamable $rcx, 8, $noreg
  renamable $rcx = ADD64ri32 killed renamable $rcx(tied-def 0), 8, implicit-def dead $eflags
  CMP64ri32 killed renamable $rdi, 8, implicit-def $eflags
  JCC_1 %bb.9, 5, implicit $eflags

bb.4 (%ir-block.15):
; predecessors: %bb.9
  successors: %bb.7(0x30000000), %bb.6(0x50000000); %bb.7(37.50%), %bb.6(62.50%)
  liveins: $rax, $rcx, $rsi
  renamable $rcx = ADD64ri32 killed renamable $rcx(tied-def 0), -7, implicit-def dead $eflags
  TEST64rr renamable $rax, renamable $rax, implicit-def $eflags
  JCC_1 %bb.7, 4, implicit $eflags

bb.6 (%ir-block.23, align 16):
; predecessors: %bb.6, %bb.4, %bb.3
  successors: %bb.7(0x04000000), %bb.6(0x7c000000); %bb.7(3.12%), %bb.6(96.88%)
  liveins: $rax, $rcx, $rsi
  renamable $rsi = IMUL64rr killed renamable $rsi(tied-def 0), renamable $rcx, implicit-def dead $eflags
  renamable $rcx = nuw nsw INC64r killed renamable $rcx(tied-def 0), implicit-def dead $eflags
  renamable $rax = DEC64r killed renamable $rax(tied-def 0), implicit-def $eflags
  JCC_1 %bb.6, 5, implicit killed $eflags

bb.7 (%ir-block.31):
; predecessors: %bb.6, %bb.1, %bb.4, %bb.3
  liveins: $rsi
  renamable $rdi = LEA64r $rip, 1, $noreg, @.str.1, $noreg
  dead $eax = XOR32rr undef $eax(tied-def 0), undef $eax, implicit-def dead $eflags, implicit-def $al
  CALL64pcrel32 target-flags(x86-plt) @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
  $eax = XOR32rr undef $eax(tied-def 0), undef $eax, implicit-def dead $eflags
  $rcx = frame-destroy POP64r implicit-def $rsp, implicit $rsp
  frame-destroy CFI_INSTRUCTION def_cfa_offset 8
  RET64 $eax

# End machine code for function main.

# *** IR Dump After X86 Execution Dependency Fix (x86-execution-domain-fix) ***:
# Machine code for function main: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
Frame Objects:
  fi#0: size=4, align=4, at location [SP-4]

bb.0 (%ir-block.0):
  successors: %bb.1(0x30000000), %bb.2(0x50000000); %bb.1(37.50%), %bb.2(62.50%)

  frame-setup PUSH64r undef $rax, implicit-def $rsp, implicit $rsp
  frame-setup CFI_INSTRUCTION def_cfa_offset 16
  renamable $rdi = LEA64r $rip, 1, $noreg, @.str, $noreg
  renamable $rsi = LEA64r $rsp, 1, $noreg, 4, $noreg
  dead $eax = XOR32rr undef $eax(tied-def 0), undef $eax, implicit-def dead $eflags, implicit-def $al
  CALL64pcrel32 target-flags(x86-plt) @__isoc99_scanf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
  renamable $edx = MOV32rm $rsp, 1, $noreg, 4, $noreg, implicit-def $rdx :: (dereferenceable load (s32) from %ir.1, !tbaa !5)
  TEST32rr renamable $edx, renamable $edx, implicit-def $eflags
  JCC_1 %bb.1, 14, implicit $eflags

bb.2 (%ir-block.6):
; predecessors: %bb.0
  successors: %bb.3(0x40000000), %bb.8(0x40000000); %bb.3(50.00%), %bb.8(50.00%)
  liveins: $rdx
  renamable $rcx = LEA64r renamable $rdx, 1, $noreg, -1, $noreg
  $eax = MOV32rr $edx, implicit-def $rax
  renamable $eax = AND32ri renamable $eax(tied-def 0), 7, implicit-def dead $eflags, implicit killed $rax, implicit-def $rax
  CMP64ri32 killed renamable $rcx, 7, implicit-def $eflags
  JCC_1 %bb.8, 3, implicit killed $eflags

bb.3:
; predecessors: %bb.2
  successors: %bb.7(0x30000000), %bb.6(0x50000000); %bb.7(37.50%), %bb.6(62.50%)
  liveins: $rax
  $ecx = MOV32ri 1, implicit-def $rcx
  $esi = MOV32ri 1, implicit-def $rsi
  TEST64rr renamable $rax, renamable $rax, implicit-def $eflags
  JCC_1 %bb.6, 5, implicit $eflags
  JMP_1 %bb.7

bb.1:
; predecessors: %bb.0
  successors: %bb.7(0x80000000); %bb.7(100.00%)

  $esi = MOV32ri 1, implicit-def $rsi
  JMP_1 %bb.7

bb.8 (%ir-block.12):
; predecessors: %bb.2
  successors: %bb.9(0x80000000); %bb.9(100.00%)
  liveins: $rax, $rdx
  renamable $edx = AND32ri renamable $edx(tied-def 0), -8, implicit-def dead $eflags, implicit killed $rdx, implicit-def $rdx
  renamable $rdx = NEG64r killed renamable $rdx(tied-def 0), implicit-def dead $eflags
  $esi = MOV32ri 1, implicit-def $rsi
  $ecx = MOV32ri 8, implicit-def $rcx

bb.9 (%ir-block.34, align 16):
; predecessors: %bb.8, %bb.9
  successors: %bb.4(0x04000000), %bb.9(0x7c000000); %bb.4(3.12%), %bb.9(96.88%)
  liveins: $rax, $rcx, $rdx, $rsi
  renamable $rdi = LEA64r renamable $rcx, 1, $noreg, -7, $noreg
  renamable $rdi = IMUL64rr killed renamable $rdi(tied-def 0), killed renamable $rsi, implicit-def dead $eflags
  renamable $rsi = LEA64r renamable $rcx, 1, $noreg, -6, $noreg
  renamable $r8 = LEA64r renamable $rcx, 1, $noreg, -5, $noreg
  renamable $rsi = IMUL64rr killed renamable $rsi(tied-def 0), killed renamable $r8, implicit-def dead $eflags
  renamable $rsi = IMUL64rr killed renamable $rsi(tied-def 0), killed renamable $rdi, implicit-def dead $eflags
  renamable $rdi = LEA64r renamable $rcx, 1, $noreg, -4, $noreg
  renamable $r8 = LEA64r renamable $rcx, 1, $noreg, -3, $noreg
  renamable $rdi = IMUL64rr killed renamable $rdi(tied-def 0), killed renamable $r8, implicit-def dead $eflags
  renamable $r8 = LEA64r renamable $rcx, 1, $noreg, -2, $noreg
  renamable $r8 = IMUL64rr killed renamable $r8(tied-def 0), killed renamable $rdi, implicit-def dead $eflags
  renamable $r8 = IMUL64rr killed renamable $r8(tied-def 0), killed renamable $rsi, implicit-def dead $eflags
  renamable $rsi = LEA64r renamable $rcx, 1, $noreg, -1, $noreg
  renamable $rsi = IMUL64rr killed renamable $rsi(tied-def 0), renamable $rcx, implicit-def dead $eflags
  renamable $rsi = IMUL64rr killed renamable $rsi(tied-def 0), killed renamable $r8, implicit-def dead $eflags
  renamable $rdi = LEA64r renamable $rdx, 1, renamable $rcx, 8, $noreg
  renamable $rcx = ADD64ri32 killed renamable $rcx(tied-def 0), 8, implicit-def dead $eflags
  CMP64ri32 killed renamable $rdi, 8, implicit-def $eflags
  JCC_1 %bb.9, 5, implicit $eflags

bb.4 (%ir-block.15):
; predecessors: %bb.9
  successors: %bb.7(0x30000000), %bb.6(0x50000000); %bb.7(37.50%), %bb.6(62.50%)
  liveins: $rax, $rcx, $rsi
  renamable $rcx = ADD64ri32 killed renamable $rcx(tied-def 0), -7, implicit-def dead $eflags
  TEST64rr renamable $rax, renamable $rax, implicit-def $eflags
  JCC_1 %bb.7, 4, implicit $eflags

bb.6 (%ir-block.23, align 16):
; predecessors: %bb.6, %bb.4, %bb.3
  successors: %bb.7(0x04000000), %bb.6(0x7c000000); %bb.7(3.12%), %bb.6(96.88%)
  liveins: $rax, $rcx, $rsi
  renamable $rsi = IMUL64rr killed renamable $rsi(tied-def 0), renamable $rcx, implicit-def dead $eflags
  renamable $rcx = nuw nsw INC64r killed renamable $rcx(tied-def 0), implicit-def dead $eflags
  renamable $rax = DEC64r killed renamable $rax(tied-def 0), implicit-def $eflags
  JCC_1 %bb.6, 5, implicit killed $eflags

bb.7 (%ir-block.31):
; predecessors: %bb.6, %bb.1, %bb.4, %bb.3
  liveins: $rsi
  renamable $rdi = LEA64r $rip, 1, $noreg, @.str.1, $noreg
  dead $eax = XOR32rr undef $eax(tied-def 0), undef $eax, implicit-def dead $eflags, implicit-def $al
  CALL64pcrel32 target-flags(x86-plt) @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
  $eax = XOR32rr undef $eax(tied-def 0), undef $eax, implicit-def dead $eflags
  $rcx = frame-destroy POP64r implicit-def $rsp, implicit $rsp
  frame-destroy CFI_INSTRUCTION def_cfa_offset 8
  RET64 $eax

# End machine code for function main.

# *** IR Dump After BreakFalseDeps (break-false-deps) ***:
# Machine code for function main: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
Frame Objects:
  fi#0: size=4, align=4, at location [SP-4]

bb.0 (%ir-block.0):
  successors: %bb.1(0x30000000), %bb.2(0x50000000); %bb.1(37.50%), %bb.2(62.50%)

  frame-setup PUSH64r undef $rax, implicit-def $rsp, implicit $rsp
  frame-setup CFI_INSTRUCTION def_cfa_offset 16
  renamable $rdi = LEA64r $rip, 1, $noreg, @.str, $noreg
  renamable $rsi = LEA64r $rsp, 1, $noreg, 4, $noreg
  dead $eax = XOR32rr undef $eax(tied-def 0), undef $eax, implicit-def dead $eflags, implicit-def $al
  CALL64pcrel32 target-flags(x86-plt) @__isoc99_scanf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
  renamable $edx = MOV32rm $rsp, 1, $noreg, 4, $noreg, implicit-def $rdx :: (dereferenceable load (s32) from %ir.1, !tbaa !5)
  TEST32rr renamable $edx, renamable $edx, implicit-def $eflags
  JCC_1 %bb.1, 14, implicit $eflags

bb.2 (%ir-block.6):
; predecessors: %bb.0
  successors: %bb.3(0x40000000), %bb.8(0x40000000); %bb.3(50.00%), %bb.8(50.00%)
  liveins: $rdx
  renamable $rcx = LEA64r renamable $rdx, 1, $noreg, -1, $noreg
  $eax = MOV32rr $edx, implicit-def $rax
  renamable $eax = AND32ri renamable $eax(tied-def 0), 7, implicit-def dead $eflags, implicit killed $rax, implicit-def $rax
  CMP64ri32 killed renamable $rcx, 7, implicit-def $eflags
  JCC_1 %bb.8, 3, implicit killed $eflags

bb.3:
; predecessors: %bb.2
  successors: %bb.7(0x30000000), %bb.6(0x50000000); %bb.7(37.50%), %bb.6(62.50%)
  liveins: $rax
  $ecx = MOV32ri 1, implicit-def $rcx
  $esi = MOV32ri 1, implicit-def $rsi
  TEST64rr renamable $rax, renamable $rax, implicit-def $eflags
  JCC_1 %bb.6, 5, implicit $eflags
  JMP_1 %bb.7

bb.1:
; predecessors: %bb.0
  successors: %bb.7(0x80000000); %bb.7(100.00%)

  $esi = MOV32ri 1, implicit-def $rsi
  JMP_1 %bb.7

bb.8 (%ir-block.12):
; predecessors: %bb.2
  successors: %bb.9(0x80000000); %bb.9(100.00%)
  liveins: $rax, $rdx
  renamable $edx = AND32ri renamable $edx(tied-def 0), -8, implicit-def dead $eflags, implicit killed $rdx, implicit-def $rdx
  renamable $rdx = NEG64r killed renamable $rdx(tied-def 0), implicit-def dead $eflags
  $esi = MOV32ri 1, implicit-def $rsi
  $ecx = MOV32ri 8, implicit-def $rcx

bb.9 (%ir-block.34, align 16):
; predecessors: %bb.8, %bb.9
  successors: %bb.4(0x04000000), %bb.9(0x7c000000); %bb.4(3.12%), %bb.9(96.88%)
  liveins: $rax, $rcx, $rdx, $rsi
  renamable $rdi = LEA64r renamable $rcx, 1, $noreg, -7, $noreg
  renamable $rdi = IMUL64rr killed renamable $rdi(tied-def 0), killed renamable $rsi, implicit-def dead $eflags
  renamable $rsi = LEA64r renamable $rcx, 1, $noreg, -6, $noreg
  renamable $r8 = LEA64r renamable $rcx, 1, $noreg, -5, $noreg
  renamable $rsi = IMUL64rr killed renamable $rsi(tied-def 0), killed renamable $r8, implicit-def dead $eflags
  renamable $rsi = IMUL64rr killed renamable $rsi(tied-def 0), killed renamable $rdi, implicit-def dead $eflags
  renamable $rdi = LEA64r renamable $rcx, 1, $noreg, -4, $noreg
  renamable $r8 = LEA64r renamable $rcx, 1, $noreg, -3, $noreg
  renamable $rdi = IMUL64rr killed renamable $rdi(tied-def 0), killed renamable $r8, implicit-def dead $eflags
  renamable $r8 = LEA64r renamable $rcx, 1, $noreg, -2, $noreg
  renamable $r8 = IMUL64rr killed renamable $r8(tied-def 0), killed renamable $rdi, implicit-def dead $eflags
  renamable $r8 = IMUL64rr killed renamable $r8(tied-def 0), killed renamable $rsi, implicit-def dead $eflags
  renamable $rsi = LEA64r renamable $rcx, 1, $noreg, -1, $noreg
  renamable $rsi = IMUL64rr killed renamable $rsi(tied-def 0), renamable $rcx, implicit-def dead $eflags
  renamable $rsi = IMUL64rr killed renamable $rsi(tied-def 0), killed renamable $r8, implicit-def dead $eflags
  renamable $rdi = LEA64r renamable $rdx, 1, renamable $rcx, 8, $noreg
  renamable $rcx = ADD64ri32 killed renamable $rcx(tied-def 0), 8, implicit-def dead $eflags
  CMP64ri32 killed renamable $rdi, 8, implicit-def $eflags
  JCC_1 %bb.9, 5, implicit $eflags

bb.4 (%ir-block.15):
; predecessors: %bb.9
  successors: %bb.7(0x30000000), %bb.6(0x50000000); %bb.7(37.50%), %bb.6(62.50%)
  liveins: $rax, $rcx, $rsi
  renamable $rcx = ADD64ri32 killed renamable $rcx(tied-def 0), -7, implicit-def dead $eflags
  TEST64rr renamable $rax, renamable $rax, implicit-def $eflags
  JCC_1 %bb.7, 4, implicit $eflags

bb.6 (%ir-block.23, align 16):
; predecessors: %bb.6, %bb.4, %bb.3
  successors: %bb.7(0x04000000), %bb.6(0x7c000000); %bb.7(3.12%), %bb.6(96.88%)
  liveins: $rax, $rcx, $rsi
  renamable $rsi = IMUL64rr killed renamable $rsi(tied-def 0), renamable $rcx, implicit-def dead $eflags
  renamable $rcx = nuw nsw INC64r killed renamable $rcx(tied-def 0), implicit-def dead $eflags
  renamable $rax = DEC64r killed renamable $rax(tied-def 0), implicit-def $eflags
  JCC_1 %bb.6, 5, implicit killed $eflags

bb.7 (%ir-block.31):
; predecessors: %bb.6, %bb.1, %bb.4, %bb.3
  liveins: $rsi
  renamable $rdi = LEA64r $rip, 1, $noreg, @.str.1, $noreg
  dead $eax = XOR32rr undef $eax(tied-def 0), undef $eax, implicit-def dead $eflags, implicit-def $al
  CALL64pcrel32 target-flags(x86-plt) @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
  $eax = XOR32rr undef $eax(tied-def 0), undef $eax, implicit-def dead $eflags
  $rcx = frame-destroy POP64r implicit-def $rsp, implicit $rsp
  frame-destroy CFI_INSTRUCTION def_cfa_offset 8
  RET64 $eax

# End machine code for function main.

# *** IR Dump After X86 Byte/Word Instruction Fixup (x86-fixup-bw-insts) ***:
# Machine code for function main: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
Frame Objects:
  fi#0: size=4, align=4, at location [SP-4]

bb.0 (%ir-block.0):
  successors: %bb.1(0x30000000), %bb.2(0x50000000); %bb.1(37.50%), %bb.2(62.50%)

  frame-setup PUSH64r undef $rax, implicit-def $rsp, implicit $rsp
  frame-setup CFI_INSTRUCTION def_cfa_offset 16
  renamable $rdi = LEA64r $rip, 1, $noreg, @.str, $noreg
  renamable $rsi = LEA64r $rsp, 1, $noreg, 4, $noreg
  dead $eax = XOR32rr undef $eax(tied-def 0), undef $eax, implicit-def dead $eflags, implicit-def $al
  CALL64pcrel32 target-flags(x86-plt) @__isoc99_scanf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
  renamable $edx = MOV32rm $rsp, 1, $noreg, 4, $noreg, implicit-def $rdx :: (dereferenceable load (s32) from %ir.1, !tbaa !5)
  TEST32rr renamable $edx, renamable $edx, implicit-def $eflags
  JCC_1 %bb.1, 14, implicit $eflags

bb.2 (%ir-block.6):
; predecessors: %bb.0
  successors: %bb.3(0x40000000), %bb.8(0x40000000); %bb.3(50.00%), %bb.8(50.00%)
  liveins: $rdx
  renamable $rcx = LEA64r renamable $rdx, 1, $noreg, -1, $noreg
  $eax = MOV32rr $edx, implicit-def $rax
  renamable $eax = AND32ri renamable $eax(tied-def 0), 7, implicit-def dead $eflags, implicit killed $rax, implicit-def $rax
  CMP64ri32 killed renamable $rcx, 7, implicit-def $eflags
  JCC_1 %bb.8, 3, implicit killed $eflags

bb.3:
; predecessors: %bb.2
  successors: %bb.7(0x30000000), %bb.6(0x50000000); %bb.7(37.50%), %bb.6(62.50%)
  liveins: $rax
  $ecx = MOV32ri 1, implicit-def $rcx
  $esi = MOV32ri 1, implicit-def $rsi
  TEST64rr renamable $rax, renamable $rax, implicit-def $eflags
  JCC_1 %bb.6, 5, implicit $eflags
  JMP_1 %bb.7

bb.1:
; predecessors: %bb.0
  successors: %bb.7(0x80000000); %bb.7(100.00%)

  $esi = MOV32ri 1, implicit-def $rsi
  JMP_1 %bb.7

bb.8 (%ir-block.12):
; predecessors: %bb.2
  successors: %bb.9(0x80000000); %bb.9(100.00%)
  liveins: $rax, $rdx
  renamable $edx = AND32ri renamable $edx(tied-def 0), -8, implicit-def dead $eflags, implicit killed $rdx, implicit-def $rdx
  renamable $rdx = NEG64r killed renamable $rdx(tied-def 0), implicit-def dead $eflags
  $esi = MOV32ri 1, implicit-def $rsi
  $ecx = MOV32ri 8, implicit-def $rcx

bb.9 (%ir-block.34, align 16):
; predecessors: %bb.8, %bb.9
  successors: %bb.4(0x04000000), %bb.9(0x7c000000); %bb.4(3.12%), %bb.9(96.88%)
  liveins: $rax, $rcx, $rdx, $rsi
  renamable $rdi = LEA64r renamable $rcx, 1, $noreg, -7, $noreg
  renamable $rdi = IMUL64rr killed renamable $rdi(tied-def 0), killed renamable $rsi, implicit-def dead $eflags
  renamable $rsi = LEA64r renamable $rcx, 1, $noreg, -6, $noreg
  renamable $r8 = LEA64r renamable $rcx, 1, $noreg, -5, $noreg
  renamable $rsi = IMUL64rr killed renamable $rsi(tied-def 0), killed renamable $r8, implicit-def dead $eflags
  renamable $rsi = IMUL64rr killed renamable $rsi(tied-def 0), killed renamable $rdi, implicit-def dead $eflags
  renamable $rdi = LEA64r renamable $rcx, 1, $noreg, -4, $noreg
  renamable $r8 = LEA64r renamable $rcx, 1, $noreg, -3, $noreg
  renamable $rdi = IMUL64rr killed renamable $rdi(tied-def 0), killed renamable $r8, implicit-def dead $eflags
  renamable $r8 = LEA64r renamable $rcx, 1, $noreg, -2, $noreg
  renamable $r8 = IMUL64rr killed renamable $r8(tied-def 0), killed renamable $rdi, implicit-def dead $eflags
  renamable $r8 = IMUL64rr killed renamable $r8(tied-def 0), killed renamable $rsi, implicit-def dead $eflags
  renamable $rsi = LEA64r renamable $rcx, 1, $noreg, -1, $noreg
  renamable $rsi = IMUL64rr killed renamable $rsi(tied-def 0), renamable $rcx, implicit-def dead $eflags
  renamable $rsi = IMUL64rr killed renamable $rsi(tied-def 0), killed renamable $r8, implicit-def dead $eflags
  renamable $rdi = LEA64r renamable $rdx, 1, renamable $rcx, 8, $noreg
  renamable $rcx = ADD64ri32 killed renamable $rcx(tied-def 0), 8, implicit-def dead $eflags
  CMP64ri32 killed renamable $rdi, 8, implicit-def $eflags
  JCC_1 %bb.9, 5, implicit $eflags

bb.4 (%ir-block.15):
; predecessors: %bb.9
  successors: %bb.7(0x30000000), %bb.6(0x50000000); %bb.7(37.50%), %bb.6(62.50%)
  liveins: $rax, $rcx, $rsi
  renamable $rcx = ADD64ri32 killed renamable $rcx(tied-def 0), -7, implicit-def dead $eflags
  TEST64rr renamable $rax, renamable $rax, implicit-def $eflags
  JCC_1 %bb.7, 4, implicit $eflags

bb.6 (%ir-block.23, align 16):
; predecessors: %bb.6, %bb.4, %bb.3
  successors: %bb.7(0x04000000), %bb.6(0x7c000000); %bb.7(3.12%), %bb.6(96.88%)
  liveins: $rax, $rcx, $rsi
  renamable $rsi = IMUL64rr killed renamable $rsi(tied-def 0), renamable $rcx, implicit-def dead $eflags
  renamable $rcx = nuw nsw INC64r killed renamable $rcx(tied-def 0), implicit-def dead $eflags
  renamable $rax = DEC64r killed renamable $rax(tied-def 0), implicit-def $eflags
  JCC_1 %bb.6, 5, implicit killed $eflags

bb.7 (%ir-block.31):
; predecessors: %bb.6, %bb.1, %bb.4, %bb.3
  liveins: $rsi
  renamable $rdi = LEA64r $rip, 1, $noreg, @.str.1, $noreg
  dead $eax = XOR32rr undef $eax(tied-def 0), undef $eax, implicit-def dead $eflags, implicit-def $al
  CALL64pcrel32 target-flags(x86-plt) @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
  $eax = XOR32rr undef $eax(tied-def 0), undef $eax, implicit-def dead $eflags
  $rcx = frame-destroy POP64r implicit-def $rsp, implicit $rsp
  frame-destroy CFI_INSTRUCTION def_cfa_offset 8
  RET64 $eax

# End machine code for function main.

# *** IR Dump After X86 LEA Fixup (x86-fixup-LEAs) ***:
# Machine code for function main: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
Frame Objects:
  fi#0: size=4, align=4, at location [SP-4]

bb.0 (%ir-block.0):
  successors: %bb.1(0x30000000), %bb.2(0x50000000); %bb.1(37.50%), %bb.2(62.50%)

  frame-setup PUSH64r undef $rax, implicit-def $rsp, implicit $rsp
  frame-setup CFI_INSTRUCTION def_cfa_offset 16
  renamable $rdi = LEA64r $rip, 1, $noreg, @.str, $noreg
  renamable $rsi = LEA64r $rsp, 1, $noreg, 4, $noreg
  dead $eax = XOR32rr undef $eax(tied-def 0), undef $eax, implicit-def dead $eflags, implicit-def $al
  CALL64pcrel32 target-flags(x86-plt) @__isoc99_scanf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
  renamable $edx = MOV32rm $rsp, 1, $noreg, 4, $noreg, implicit-def $rdx :: (dereferenceable load (s32) from %ir.1, !tbaa !5)
  TEST32rr renamable $edx, renamable $edx, implicit-def $eflags
  JCC_1 %bb.1, 14, implicit $eflags

bb.2 (%ir-block.6):
; predecessors: %bb.0
  successors: %bb.3(0x40000000), %bb.8(0x40000000); %bb.3(50.00%), %bb.8(50.00%)
  liveins: $rdx
  renamable $rcx = LEA64r renamable $rdx, 1, $noreg, -1, $noreg
  $eax = MOV32rr $edx, implicit-def $rax
  renamable $eax = AND32ri renamable $eax(tied-def 0), 7, implicit-def dead $eflags, implicit killed $rax, implicit-def $rax
  CMP64ri32 killed renamable $rcx, 7, implicit-def $eflags
  JCC_1 %bb.8, 3, implicit killed $eflags

bb.3:
; predecessors: %bb.2
  successors: %bb.7(0x30000000), %bb.6(0x50000000); %bb.7(37.50%), %bb.6(62.50%)
  liveins: $rax
  $ecx = MOV32ri 1, implicit-def $rcx
  $esi = MOV32ri 1, implicit-def $rsi
  TEST64rr renamable $rax, renamable $rax, implicit-def $eflags
  JCC_1 %bb.6, 5, implicit $eflags
  JMP_1 %bb.7

bb.1:
; predecessors: %bb.0
  successors: %bb.7(0x80000000); %bb.7(100.00%)

  $esi = MOV32ri 1, implicit-def $rsi
  JMP_1 %bb.7

bb.8 (%ir-block.12):
; predecessors: %bb.2
  successors: %bb.9(0x80000000); %bb.9(100.00%)
  liveins: $rax, $rdx
  renamable $edx = AND32ri renamable $edx(tied-def 0), -8, implicit-def dead $eflags, implicit killed $rdx, implicit-def $rdx
  renamable $rdx = NEG64r killed renamable $rdx(tied-def 0), implicit-def dead $eflags
  $esi = MOV32ri 1, implicit-def $rsi
  $ecx = MOV32ri 8, implicit-def $rcx

bb.9 (%ir-block.34, align 16):
; predecessors: %bb.8, %bb.9
  successors: %bb.4(0x04000000), %bb.9(0x7c000000); %bb.4(3.12%), %bb.9(96.88%)
  liveins: $rax, $rcx, $rdx, $rsi
  renamable $rdi = LEA64r renamable $rcx, 1, $noreg, -7, $noreg
  renamable $rdi = IMUL64rr killed renamable $rdi(tied-def 0), killed renamable $rsi, implicit-def dead $eflags
  renamable $rsi = LEA64r renamable $rcx, 1, $noreg, -6, $noreg
  renamable $r8 = LEA64r renamable $rcx, 1, $noreg, -5, $noreg
  renamable $rsi = IMUL64rr killed renamable $rsi(tied-def 0), killed renamable $r8, implicit-def dead $eflags
  renamable $rsi = IMUL64rr killed renamable $rsi(tied-def 0), killed renamable $rdi, implicit-def dead $eflags
  renamable $rdi = LEA64r renamable $rcx, 1, $noreg, -4, $noreg
  renamable $r8 = LEA64r renamable $rcx, 1, $noreg, -3, $noreg
  renamable $rdi = IMUL64rr killed renamable $rdi(tied-def 0), killed renamable $r8, implicit-def dead $eflags
  renamable $r8 = LEA64r renamable $rcx, 1, $noreg, -2, $noreg
  renamable $r8 = IMUL64rr killed renamable $r8(tied-def 0), killed renamable $rdi, implicit-def dead $eflags
  renamable $r8 = IMUL64rr killed renamable $r8(tied-def 0), killed renamable $rsi, implicit-def dead $eflags
  renamable $rsi = LEA64r renamable $rcx, 1, $noreg, -1, $noreg
  renamable $rsi = IMUL64rr killed renamable $rsi(tied-def 0), renamable $rcx, implicit-def dead $eflags
  renamable $rsi = IMUL64rr killed renamable $rsi(tied-def 0), killed renamable $r8, implicit-def dead $eflags
  renamable $rdi = LEA64r renamable $rdx, 1, renamable $rcx, 0, $noreg
  $rdi = ADD64ri32 $rdi(tied-def 0), 8, implicit-def $eflags
  renamable $rcx = ADD64ri32 killed renamable $rcx(tied-def 0), 8, implicit-def dead $eflags
  CMP64ri32 killed renamable $rdi, 8, implicit-def $eflags
  JCC_1 %bb.9, 5, implicit $eflags

bb.4 (%ir-block.15):
; predecessors: %bb.9
  successors: %bb.7(0x30000000), %bb.6(0x50000000); %bb.7(37.50%), %bb.6(62.50%)
  liveins: $rax, $rcx, $rsi
  renamable $rcx = ADD64ri32 killed renamable $rcx(tied-def 0), -7, implicit-def dead $eflags
  TEST64rr renamable $rax, renamable $rax, implicit-def $eflags
  JCC_1 %bb.7, 4, implicit $eflags

bb.6 (%ir-block.23, align 16):
; predecessors: %bb.6, %bb.4, %bb.3
  successors: %bb.7(0x04000000), %bb.6(0x7c000000); %bb.7(3.12%), %bb.6(96.88%)
  liveins: $rax, $rcx, $rsi
  renamable $rsi = IMUL64rr killed renamable $rsi(tied-def 0), renamable $rcx, implicit-def dead $eflags
  renamable $rcx = nuw nsw INC64r killed renamable $rcx(tied-def 0), implicit-def dead $eflags
  renamable $rax = DEC64r killed renamable $rax(tied-def 0), implicit-def $eflags
  JCC_1 %bb.6, 5, implicit killed $eflags

bb.7 (%ir-block.31):
; predecessors: %bb.6, %bb.1, %bb.4, %bb.3
  liveins: $rsi
  renamable $rdi = LEA64r $rip, 1, $noreg, @.str.1, $noreg
  dead $eax = XOR32rr undef $eax(tied-def 0), undef $eax, implicit-def dead $eflags, implicit-def $al
  CALL64pcrel32 target-flags(x86-plt) @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
  $eax = XOR32rr undef $eax(tied-def 0), undef $eax, implicit-def dead $eflags
  $rcx = frame-destroy POP64r implicit-def $rsp, implicit $rsp
  frame-destroy CFI_INSTRUCTION def_cfa_offset 8
  RET64 $eax

# End machine code for function main.

# *** IR Dump After Compressing EVEX instrs when possible (x86-compress-evex) ***:
# Machine code for function main: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
Frame Objects:
  fi#0: size=4, align=4, at location [SP-4]

bb.0 (%ir-block.0):
  successors: %bb.1(0x30000000), %bb.2(0x50000000); %bb.1(37.50%), %bb.2(62.50%)

  frame-setup PUSH64r undef $rax, implicit-def $rsp, implicit $rsp
  frame-setup CFI_INSTRUCTION def_cfa_offset 16
  renamable $rdi = LEA64r $rip, 1, $noreg, @.str, $noreg
  renamable $rsi = LEA64r $rsp, 1, $noreg, 4, $noreg
  dead $eax = XOR32rr undef $eax(tied-def 0), undef $eax, implicit-def dead $eflags, implicit-def $al
  CALL64pcrel32 target-flags(x86-plt) @__isoc99_scanf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
  renamable $edx = MOV32rm $rsp, 1, $noreg, 4, $noreg, implicit-def $rdx :: (dereferenceable load (s32) from %ir.1, !tbaa !5)
  TEST32rr renamable $edx, renamable $edx, implicit-def $eflags
  JCC_1 %bb.1, 14, implicit $eflags

bb.2 (%ir-block.6):
; predecessors: %bb.0
  successors: %bb.3(0x40000000), %bb.8(0x40000000); %bb.3(50.00%), %bb.8(50.00%)
  liveins: $rdx
  renamable $rcx = LEA64r renamable $rdx, 1, $noreg, -1, $noreg
  $eax = MOV32rr $edx, implicit-def $rax
  renamable $eax = AND32ri renamable $eax(tied-def 0), 7, implicit-def dead $eflags, implicit killed $rax, implicit-def $rax
  CMP64ri32 killed renamable $rcx, 7, implicit-def $eflags
  JCC_1 %bb.8, 3, implicit killed $eflags

bb.3:
; predecessors: %bb.2
  successors: %bb.7(0x30000000), %bb.6(0x50000000); %bb.7(37.50%), %bb.6(62.50%)
  liveins: $rax
  $ecx = MOV32ri 1, implicit-def $rcx
  $esi = MOV32ri 1, implicit-def $rsi
  TEST64rr renamable $rax, renamable $rax, implicit-def $eflags
  JCC_1 %bb.6, 5, implicit $eflags
  JMP_1 %bb.7

bb.1:
; predecessors: %bb.0
  successors: %bb.7(0x80000000); %bb.7(100.00%)

  $esi = MOV32ri 1, implicit-def $rsi
  JMP_1 %bb.7

bb.8 (%ir-block.12):
; predecessors: %bb.2
  successors: %bb.9(0x80000000); %bb.9(100.00%)
  liveins: $rax, $rdx
  renamable $edx = AND32ri renamable $edx(tied-def 0), -8, implicit-def dead $eflags, implicit killed $rdx, implicit-def $rdx
  renamable $rdx = NEG64r killed renamable $rdx(tied-def 0), implicit-def dead $eflags
  $esi = MOV32ri 1, implicit-def $rsi
  $ecx = MOV32ri 8, implicit-def $rcx

bb.9 (%ir-block.34, align 16):
; predecessors: %bb.8, %bb.9
  successors: %bb.4(0x04000000), %bb.9(0x7c000000); %bb.4(3.12%), %bb.9(96.88%)
  liveins: $rax, $rcx, $rdx, $rsi
  renamable $rdi = LEA64r renamable $rcx, 1, $noreg, -7, $noreg
  renamable $rdi = IMUL64rr killed renamable $rdi(tied-def 0), killed renamable $rsi, implicit-def dead $eflags
  renamable $rsi = LEA64r renamable $rcx, 1, $noreg, -6, $noreg
  renamable $r8 = LEA64r renamable $rcx, 1, $noreg, -5, $noreg
  renamable $rsi = IMUL64rr killed renamable $rsi(tied-def 0), killed renamable $r8, implicit-def dead $eflags
  renamable $rsi = IMUL64rr killed renamable $rsi(tied-def 0), killed renamable $rdi, implicit-def dead $eflags
  renamable $rdi = LEA64r renamable $rcx, 1, $noreg, -4, $noreg
  renamable $r8 = LEA64r renamable $rcx, 1, $noreg, -3, $noreg
  renamable $rdi = IMUL64rr killed renamable $rdi(tied-def 0), killed renamable $r8, implicit-def dead $eflags
  renamable $r8 = LEA64r renamable $rcx, 1, $noreg, -2, $noreg
  renamable $r8 = IMUL64rr killed renamable $r8(tied-def 0), killed renamable $rdi, implicit-def dead $eflags
  renamable $r8 = IMUL64rr killed renamable $r8(tied-def 0), killed renamable $rsi, implicit-def dead $eflags
  renamable $rsi = LEA64r renamable $rcx, 1, $noreg, -1, $noreg
  renamable $rsi = IMUL64rr killed renamable $rsi(tied-def 0), renamable $rcx, implicit-def dead $eflags
  renamable $rsi = IMUL64rr killed renamable $rsi(tied-def 0), killed renamable $r8, implicit-def dead $eflags
  renamable $rdi = LEA64r renamable $rdx, 1, renamable $rcx, 0, $noreg
  $rdi = ADD64ri32 $rdi(tied-def 0), 8, implicit-def $eflags
  renamable $rcx = ADD64ri32 killed renamable $rcx(tied-def 0), 8, implicit-def dead $eflags
  CMP64ri32 killed renamable $rdi, 8, implicit-def $eflags
  JCC_1 %bb.9, 5, implicit $eflags

bb.4 (%ir-block.15):
; predecessors: %bb.9
  successors: %bb.7(0x30000000), %bb.6(0x50000000); %bb.7(37.50%), %bb.6(62.50%)
  liveins: $rax, $rcx, $rsi
  renamable $rcx = ADD64ri32 killed renamable $rcx(tied-def 0), -7, implicit-def dead $eflags
  TEST64rr renamable $rax, renamable $rax, implicit-def $eflags
  JCC_1 %bb.7, 4, implicit $eflags

bb.6 (%ir-block.23, align 16):
; predecessors: %bb.6, %bb.4, %bb.3
  successors: %bb.7(0x04000000), %bb.6(0x7c000000); %bb.7(3.12%), %bb.6(96.88%)
  liveins: $rax, $rcx, $rsi
  renamable $rsi = IMUL64rr killed renamable $rsi(tied-def 0), renamable $rcx, implicit-def dead $eflags
  renamable $rcx = nuw nsw INC64r killed renamable $rcx(tied-def 0), implicit-def dead $eflags
  renamable $rax = DEC64r killed renamable $rax(tied-def 0), implicit-def $eflags
  JCC_1 %bb.6, 5, implicit killed $eflags

bb.7 (%ir-block.31):
; predecessors: %bb.6, %bb.1, %bb.4, %bb.3
  liveins: $rsi
  renamable $rdi = LEA64r $rip, 1, $noreg, @.str.1, $noreg
  dead $eax = XOR32rr undef $eax(tied-def 0), undef $eax, implicit-def dead $eflags, implicit-def $al
  CALL64pcrel32 target-flags(x86-plt) @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
  $eax = XOR32rr undef $eax(tied-def 0), undef $eax, implicit-def dead $eflags
  $rcx = frame-destroy POP64r implicit-def $rsp, implicit $rsp
  frame-destroy CFI_INSTRUCTION def_cfa_offset 8
  RET64 $eax

# End machine code for function main.

# *** IR Dump After Contiguously Lay Out Funclets (funclet-layout) ***:
# Machine code for function main: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
Frame Objects:
  fi#0: size=4, align=4, at location [SP-4]

bb.0 (%ir-block.0):
  successors: %bb.1(0x30000000), %bb.2(0x50000000); %bb.1(37.50%), %bb.2(62.50%)

  frame-setup PUSH64r undef $rax, implicit-def $rsp, implicit $rsp
  frame-setup CFI_INSTRUCTION def_cfa_offset 16
  renamable $rdi = LEA64r $rip, 1, $noreg, @.str, $noreg
  renamable $rsi = LEA64r $rsp, 1, $noreg, 4, $noreg
  dead $eax = XOR32rr undef $eax(tied-def 0), undef $eax, implicit-def dead $eflags, implicit-def $al
  CALL64pcrel32 target-flags(x86-plt) @__isoc99_scanf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
  renamable $edx = MOV32rm $rsp, 1, $noreg, 4, $noreg, implicit-def $rdx :: (dereferenceable load (s32) from %ir.1, !tbaa !5)
  TEST32rr renamable $edx, renamable $edx, implicit-def $eflags
  JCC_1 %bb.1, 14, implicit $eflags

bb.2 (%ir-block.6):
; predecessors: %bb.0
  successors: %bb.3(0x40000000), %bb.8(0x40000000); %bb.3(50.00%), %bb.8(50.00%)
  liveins: $rdx
  renamable $rcx = LEA64r renamable $rdx, 1, $noreg, -1, $noreg
  $eax = MOV32rr $edx, implicit-def $rax
  renamable $eax = AND32ri renamable $eax(tied-def 0), 7, implicit-def dead $eflags, implicit killed $rax, implicit-def $rax
  CMP64ri32 killed renamable $rcx, 7, implicit-def $eflags
  JCC_1 %bb.8, 3, implicit killed $eflags

bb.3:
; predecessors: %bb.2
  successors: %bb.7(0x30000000), %bb.6(0x50000000); %bb.7(37.50%), %bb.6(62.50%)
  liveins: $rax
  $ecx = MOV32ri 1, implicit-def $rcx
  $esi = MOV32ri 1, implicit-def $rsi
  TEST64rr renamable $rax, renamable $rax, implicit-def $eflags
  JCC_1 %bb.6, 5, implicit $eflags
  JMP_1 %bb.7

bb.1:
; predecessors: %bb.0
  successors: %bb.7(0x80000000); %bb.7(100.00%)

  $esi = MOV32ri 1, implicit-def $rsi
  JMP_1 %bb.7

bb.8 (%ir-block.12):
; predecessors: %bb.2
  successors: %bb.9(0x80000000); %bb.9(100.00%)
  liveins: $rax, $rdx
  renamable $edx = AND32ri renamable $edx(tied-def 0), -8, implicit-def dead $eflags, implicit killed $rdx, implicit-def $rdx
  renamable $rdx = NEG64r killed renamable $rdx(tied-def 0), implicit-def dead $eflags
  $esi = MOV32ri 1, implicit-def $rsi
  $ecx = MOV32ri 8, implicit-def $rcx

bb.9 (%ir-block.34, align 16):
; predecessors: %bb.8, %bb.9
  successors: %bb.4(0x04000000), %bb.9(0x7c000000); %bb.4(3.12%), %bb.9(96.88%)
  liveins: $rax, $rcx, $rdx, $rsi
  renamable $rdi = LEA64r renamable $rcx, 1, $noreg, -7, $noreg
  renamable $rdi = IMUL64rr killed renamable $rdi(tied-def 0), killed renamable $rsi, implicit-def dead $eflags
  renamable $rsi = LEA64r renamable $rcx, 1, $noreg, -6, $noreg
  renamable $r8 = LEA64r renamable $rcx, 1, $noreg, -5, $noreg
  renamable $rsi = IMUL64rr killed renamable $rsi(tied-def 0), killed renamable $r8, implicit-def dead $eflags
  renamable $rsi = IMUL64rr killed renamable $rsi(tied-def 0), killed renamable $rdi, implicit-def dead $eflags
  renamable $rdi = LEA64r renamable $rcx, 1, $noreg, -4, $noreg
  renamable $r8 = LEA64r renamable $rcx, 1, $noreg, -3, $noreg
  renamable $rdi = IMUL64rr killed renamable $rdi(tied-def 0), killed renamable $r8, implicit-def dead $eflags
  renamable $r8 = LEA64r renamable $rcx, 1, $noreg, -2, $noreg
  renamable $r8 = IMUL64rr killed renamable $r8(tied-def 0), killed renamable $rdi, implicit-def dead $eflags
  renamable $r8 = IMUL64rr killed renamable $r8(tied-def 0), killed renamable $rsi, implicit-def dead $eflags
  renamable $rsi = LEA64r renamable $rcx, 1, $noreg, -1, $noreg
  renamable $rsi = IMUL64rr killed renamable $rsi(tied-def 0), renamable $rcx, implicit-def dead $eflags
  renamable $rsi = IMUL64rr killed renamable $rsi(tied-def 0), killed renamable $r8, implicit-def dead $eflags
  renamable $rdi = LEA64r renamable $rdx, 1, renamable $rcx, 0, $noreg
  $rdi = ADD64ri32 $rdi(tied-def 0), 8, implicit-def $eflags
  renamable $rcx = ADD64ri32 killed renamable $rcx(tied-def 0), 8, implicit-def dead $eflags
  CMP64ri32 killed renamable $rdi, 8, implicit-def $eflags
  JCC_1 %bb.9, 5, implicit $eflags

bb.4 (%ir-block.15):
; predecessors: %bb.9
  successors: %bb.7(0x30000000), %bb.6(0x50000000); %bb.7(37.50%), %bb.6(62.50%)
  liveins: $rax, $rcx, $rsi
  renamable $rcx = ADD64ri32 killed renamable $rcx(tied-def 0), -7, implicit-def dead $eflags
  TEST64rr renamable $rax, renamable $rax, implicit-def $eflags
  JCC_1 %bb.7, 4, implicit $eflags

bb.6 (%ir-block.23, align 16):
; predecessors: %bb.6, %bb.4, %bb.3
  successors: %bb.7(0x04000000), %bb.6(0x7c000000); %bb.7(3.12%), %bb.6(96.88%)
  liveins: $rax, $rcx, $rsi
  renamable $rsi = IMUL64rr killed renamable $rsi(tied-def 0), renamable $rcx, implicit-def dead $eflags
  renamable $rcx = nuw nsw INC64r killed renamable $rcx(tied-def 0), implicit-def dead $eflags
  renamable $rax = DEC64r killed renamable $rax(tied-def 0), implicit-def $eflags
  JCC_1 %bb.6, 5, implicit killed $eflags

bb.7 (%ir-block.31):
; predecessors: %bb.6, %bb.1, %bb.4, %bb.3
  liveins: $rsi
  renamable $rdi = LEA64r $rip, 1, $noreg, @.str.1, $noreg
  dead $eax = XOR32rr undef $eax(tied-def 0), undef $eax, implicit-def dead $eflags, implicit-def $al
  CALL64pcrel32 target-flags(x86-plt) @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
  $eax = XOR32rr undef $eax(tied-def 0), undef $eax, implicit-def dead $eflags
  $rcx = frame-destroy POP64r implicit-def $rsp, implicit $rsp
  frame-destroy CFI_INSTRUCTION def_cfa_offset 8
  RET64 $eax

# End machine code for function main.

# *** IR Dump After StackMap Liveness Analysis (stackmap-liveness) ***:
# Machine code for function main: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
Frame Objects:
  fi#0: size=4, align=4, at location [SP-4]

bb.0 (%ir-block.0):
  successors: %bb.1(0x30000000), %bb.2(0x50000000); %bb.1(37.50%), %bb.2(62.50%)

  frame-setup PUSH64r undef $rax, implicit-def $rsp, implicit $rsp
  frame-setup CFI_INSTRUCTION def_cfa_offset 16
  renamable $rdi = LEA64r $rip, 1, $noreg, @.str, $noreg
  renamable $rsi = LEA64r $rsp, 1, $noreg, 4, $noreg
  dead $eax = XOR32rr undef $eax(tied-def 0), undef $eax, implicit-def dead $eflags, implicit-def $al
  CALL64pcrel32 target-flags(x86-plt) @__isoc99_scanf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
  renamable $edx = MOV32rm $rsp, 1, $noreg, 4, $noreg, implicit-def $rdx :: (dereferenceable load (s32) from %ir.1, !tbaa !5)
  TEST32rr renamable $edx, renamable $edx, implicit-def $eflags
  JCC_1 %bb.1, 14, implicit $eflags

bb.2 (%ir-block.6):
; predecessors: %bb.0
  successors: %bb.3(0x40000000), %bb.8(0x40000000); %bb.3(50.00%), %bb.8(50.00%)
  liveins: $rdx
  renamable $rcx = LEA64r renamable $rdx, 1, $noreg, -1, $noreg
  $eax = MOV32rr $edx, implicit-def $rax
  renamable $eax = AND32ri renamable $eax(tied-def 0), 7, implicit-def dead $eflags, implicit killed $rax, implicit-def $rax
  CMP64ri32 killed renamable $rcx, 7, implicit-def $eflags
  JCC_1 %bb.8, 3, implicit killed $eflags

bb.3:
; predecessors: %bb.2
  successors: %bb.7(0x30000000), %bb.6(0x50000000); %bb.7(37.50%), %bb.6(62.50%)
  liveins: $rax
  $ecx = MOV32ri 1, implicit-def $rcx
  $esi = MOV32ri 1, implicit-def $rsi
  TEST64rr renamable $rax, renamable $rax, implicit-def $eflags
  JCC_1 %bb.6, 5, implicit $eflags
  JMP_1 %bb.7

bb.1:
; predecessors: %bb.0
  successors: %bb.7(0x80000000); %bb.7(100.00%)

  $esi = MOV32ri 1, implicit-def $rsi
  JMP_1 %bb.7

bb.8 (%ir-block.12):
; predecessors: %bb.2
  successors: %bb.9(0x80000000); %bb.9(100.00%)
  liveins: $rax, $rdx
  renamable $edx = AND32ri renamable $edx(tied-def 0), -8, implicit-def dead $eflags, implicit killed $rdx, implicit-def $rdx
  renamable $rdx = NEG64r killed renamable $rdx(tied-def 0), implicit-def dead $eflags
  $esi = MOV32ri 1, implicit-def $rsi
  $ecx = MOV32ri 8, implicit-def $rcx

bb.9 (%ir-block.34, align 16):
; predecessors: %bb.8, %bb.9
  successors: %bb.4(0x04000000), %bb.9(0x7c000000); %bb.4(3.12%), %bb.9(96.88%)
  liveins: $rax, $rcx, $rdx, $rsi
  renamable $rdi = LEA64r renamable $rcx, 1, $noreg, -7, $noreg
  renamable $rdi = IMUL64rr killed renamable $rdi(tied-def 0), killed renamable $rsi, implicit-def dead $eflags
  renamable $rsi = LEA64r renamable $rcx, 1, $noreg, -6, $noreg
  renamable $r8 = LEA64r renamable $rcx, 1, $noreg, -5, $noreg
  renamable $rsi = IMUL64rr killed renamable $rsi(tied-def 0), killed renamable $r8, implicit-def dead $eflags
  renamable $rsi = IMUL64rr killed renamable $rsi(tied-def 0), killed renamable $rdi, implicit-def dead $eflags
  renamable $rdi = LEA64r renamable $rcx, 1, $noreg, -4, $noreg
  renamable $r8 = LEA64r renamable $rcx, 1, $noreg, -3, $noreg
  renamable $rdi = IMUL64rr killed renamable $rdi(tied-def 0), killed renamable $r8, implicit-def dead $eflags
  renamable $r8 = LEA64r renamable $rcx, 1, $noreg, -2, $noreg
  renamable $r8 = IMUL64rr killed renamable $r8(tied-def 0), killed renamable $rdi, implicit-def dead $eflags
  renamable $r8 = IMUL64rr killed renamable $r8(tied-def 0), killed renamable $rsi, implicit-def dead $eflags
  renamable $rsi = LEA64r renamable $rcx, 1, $noreg, -1, $noreg
  renamable $rsi = IMUL64rr killed renamable $rsi(tied-def 0), renamable $rcx, implicit-def dead $eflags
  renamable $rsi = IMUL64rr killed renamable $rsi(tied-def 0), killed renamable $r8, implicit-def dead $eflags
  renamable $rdi = LEA64r renamable $rdx, 1, renamable $rcx, 0, $noreg
  $rdi = ADD64ri32 $rdi(tied-def 0), 8, implicit-def $eflags
  renamable $rcx = ADD64ri32 killed renamable $rcx(tied-def 0), 8, implicit-def dead $eflags
  CMP64ri32 killed renamable $rdi, 8, implicit-def $eflags
  JCC_1 %bb.9, 5, implicit $eflags

bb.4 (%ir-block.15):
; predecessors: %bb.9
  successors: %bb.7(0x30000000), %bb.6(0x50000000); %bb.7(37.50%), %bb.6(62.50%)
  liveins: $rax, $rcx, $rsi
  renamable $rcx = ADD64ri32 killed renamable $rcx(tied-def 0), -7, implicit-def dead $eflags
  TEST64rr renamable $rax, renamable $rax, implicit-def $eflags
  JCC_1 %bb.7, 4, implicit $eflags

bb.6 (%ir-block.23, align 16):
; predecessors: %bb.6, %bb.4, %bb.3
  successors: %bb.7(0x04000000), %bb.6(0x7c000000); %bb.7(3.12%), %bb.6(96.88%)
  liveins: $rax, $rcx, $rsi
  renamable $rsi = IMUL64rr killed renamable $rsi(tied-def 0), renamable $rcx, implicit-def dead $eflags
  renamable $rcx = nuw nsw INC64r killed renamable $rcx(tied-def 0), implicit-def dead $eflags
  renamable $rax = DEC64r killed renamable $rax(tied-def 0), implicit-def $eflags
  JCC_1 %bb.6, 5, implicit killed $eflags

bb.7 (%ir-block.31):
; predecessors: %bb.6, %bb.1, %bb.4, %bb.3
  liveins: $rsi
  renamable $rdi = LEA64r $rip, 1, $noreg, @.str.1, $noreg
  dead $eax = XOR32rr undef $eax(tied-def 0), undef $eax, implicit-def dead $eflags, implicit-def $al
  CALL64pcrel32 target-flags(x86-plt) @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
  $eax = XOR32rr undef $eax(tied-def 0), undef $eax, implicit-def dead $eflags
  $rcx = frame-destroy POP64r implicit-def $rsp, implicit $rsp
  frame-destroy CFI_INSTRUCTION def_cfa_offset 8
  RET64 $eax

# End machine code for function main.

# *** IR Dump After Live DEBUG_VALUE analysis (livedebugvalues) ***:
# Machine code for function main: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
Frame Objects:
  fi#0: size=4, align=4, at location [SP-4]

bb.0 (%ir-block.0):
  successors: %bb.1(0x30000000), %bb.2(0x50000000); %bb.1(37.50%), %bb.2(62.50%)

  frame-setup PUSH64r undef $rax, implicit-def $rsp, implicit $rsp
  frame-setup CFI_INSTRUCTION def_cfa_offset 16
  renamable $rdi = LEA64r $rip, 1, $noreg, @.str, $noreg
  renamable $rsi = LEA64r $rsp, 1, $noreg, 4, $noreg
  dead $eax = XOR32rr undef $eax(tied-def 0), undef $eax, implicit-def dead $eflags, implicit-def $al
  CALL64pcrel32 target-flags(x86-plt) @__isoc99_scanf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
  renamable $edx = MOV32rm $rsp, 1, $noreg, 4, $noreg, implicit-def $rdx :: (dereferenceable load (s32) from %ir.1, !tbaa !5)
  TEST32rr renamable $edx, renamable $edx, implicit-def $eflags
  JCC_1 %bb.1, 14, implicit $eflags

bb.2 (%ir-block.6):
; predecessors: %bb.0
  successors: %bb.3(0x40000000), %bb.8(0x40000000); %bb.3(50.00%), %bb.8(50.00%)
  liveins: $rdx
  renamable $rcx = LEA64r renamable $rdx, 1, $noreg, -1, $noreg
  $eax = MOV32rr $edx, implicit-def $rax
  renamable $eax = AND32ri renamable $eax(tied-def 0), 7, implicit-def dead $eflags, implicit killed $rax, implicit-def $rax
  CMP64ri32 killed renamable $rcx, 7, implicit-def $eflags
  JCC_1 %bb.8, 3, implicit killed $eflags

bb.3:
; predecessors: %bb.2
  successors: %bb.7(0x30000000), %bb.6(0x50000000); %bb.7(37.50%), %bb.6(62.50%)
  liveins: $rax
  $ecx = MOV32ri 1, implicit-def $rcx
  $esi = MOV32ri 1, implicit-def $rsi
  TEST64rr renamable $rax, renamable $rax, implicit-def $eflags
  JCC_1 %bb.6, 5, implicit $eflags
  JMP_1 %bb.7

bb.1:
; predecessors: %bb.0
  successors: %bb.7(0x80000000); %bb.7(100.00%)

  $esi = MOV32ri 1, implicit-def $rsi
  JMP_1 %bb.7

bb.8 (%ir-block.12):
; predecessors: %bb.2
  successors: %bb.9(0x80000000); %bb.9(100.00%)
  liveins: $rax, $rdx
  renamable $edx = AND32ri renamable $edx(tied-def 0), -8, implicit-def dead $eflags, implicit killed $rdx, implicit-def $rdx
  renamable $rdx = NEG64r killed renamable $rdx(tied-def 0), implicit-def dead $eflags
  $esi = MOV32ri 1, implicit-def $rsi
  $ecx = MOV32ri 8, implicit-def $rcx

bb.9 (%ir-block.34, align 16):
; predecessors: %bb.8, %bb.9
  successors: %bb.4(0x04000000), %bb.9(0x7c000000); %bb.4(3.12%), %bb.9(96.88%)
  liveins: $rax, $rcx, $rdx, $rsi
  renamable $rdi = LEA64r renamable $rcx, 1, $noreg, -7, $noreg
  renamable $rdi = IMUL64rr killed renamable $rdi(tied-def 0), killed renamable $rsi, implicit-def dead $eflags
  renamable $rsi = LEA64r renamable $rcx, 1, $noreg, -6, $noreg
  renamable $r8 = LEA64r renamable $rcx, 1, $noreg, -5, $noreg
  renamable $rsi = IMUL64rr killed renamable $rsi(tied-def 0), killed renamable $r8, implicit-def dead $eflags
  renamable $rsi = IMUL64rr killed renamable $rsi(tied-def 0), killed renamable $rdi, implicit-def dead $eflags
  renamable $rdi = LEA64r renamable $rcx, 1, $noreg, -4, $noreg
  renamable $r8 = LEA64r renamable $rcx, 1, $noreg, -3, $noreg
  renamable $rdi = IMUL64rr killed renamable $rdi(tied-def 0), killed renamable $r8, implicit-def dead $eflags
  renamable $r8 = LEA64r renamable $rcx, 1, $noreg, -2, $noreg
  renamable $r8 = IMUL64rr killed renamable $r8(tied-def 0), killed renamable $rdi, implicit-def dead $eflags
  renamable $r8 = IMUL64rr killed renamable $r8(tied-def 0), killed renamable $rsi, implicit-def dead $eflags
  renamable $rsi = LEA64r renamable $rcx, 1, $noreg, -1, $noreg
  renamable $rsi = IMUL64rr killed renamable $rsi(tied-def 0), renamable $rcx, implicit-def dead $eflags
  renamable $rsi = IMUL64rr killed renamable $rsi(tied-def 0), killed renamable $r8, implicit-def dead $eflags
  renamable $rdi = LEA64r renamable $rdx, 1, renamable $rcx, 0, $noreg
  $rdi = ADD64ri32 $rdi(tied-def 0), 8, implicit-def $eflags
  renamable $rcx = ADD64ri32 killed renamable $rcx(tied-def 0), 8, implicit-def dead $eflags
  CMP64ri32 killed renamable $rdi, 8, implicit-def $eflags
  JCC_1 %bb.9, 5, implicit $eflags

bb.4 (%ir-block.15):
; predecessors: %bb.9
  successors: %bb.7(0x30000000), %bb.6(0x50000000); %bb.7(37.50%), %bb.6(62.50%)
  liveins: $rax, $rcx, $rsi
  renamable $rcx = ADD64ri32 killed renamable $rcx(tied-def 0), -7, implicit-def dead $eflags
  TEST64rr renamable $rax, renamable $rax, implicit-def $eflags
  JCC_1 %bb.7, 4, implicit $eflags

bb.6 (%ir-block.23, align 16):
; predecessors: %bb.6, %bb.4, %bb.3
  successors: %bb.7(0x04000000), %bb.6(0x7c000000); %bb.7(3.12%), %bb.6(96.88%)
  liveins: $rax, $rcx, $rsi
  renamable $rsi = IMUL64rr killed renamable $rsi(tied-def 0), renamable $rcx, implicit-def dead $eflags
  renamable $rcx = nuw nsw INC64r killed renamable $rcx(tied-def 0), implicit-def dead $eflags
  renamable $rax = DEC64r killed renamable $rax(tied-def 0), implicit-def $eflags
  JCC_1 %bb.6, 5, implicit killed $eflags

bb.7 (%ir-block.31):
; predecessors: %bb.6, %bb.1, %bb.4, %bb.3
  liveins: $rsi
  renamable $rdi = LEA64r $rip, 1, $noreg, @.str.1, $noreg
  dead $eax = XOR32rr undef $eax(tied-def 0), undef $eax, implicit-def dead $eflags, implicit-def $al
  CALL64pcrel32 target-flags(x86-plt) @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
  $eax = XOR32rr undef $eax(tied-def 0), undef $eax, implicit-def dead $eflags
  $rcx = frame-destroy POP64r implicit-def $rsp, implicit $rsp
  frame-destroy CFI_INSTRUCTION def_cfa_offset 8
  RET64 $eax

# End machine code for function main.

# *** IR Dump After Machine Sanitizer Binary Metadata (machine-sanmd) ***:
# Machine code for function main: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
Frame Objects:
  fi#0: size=4, align=4, at location [SP-4]

bb.0 (%ir-block.0):
  successors: %bb.1(0x30000000), %bb.2(0x50000000); %bb.1(37.50%), %bb.2(62.50%)

  frame-setup PUSH64r undef $rax, implicit-def $rsp, implicit $rsp
  frame-setup CFI_INSTRUCTION def_cfa_offset 16
  renamable $rdi = LEA64r $rip, 1, $noreg, @.str, $noreg
  renamable $rsi = LEA64r $rsp, 1, $noreg, 4, $noreg
  dead $eax = XOR32rr undef $eax(tied-def 0), undef $eax, implicit-def dead $eflags, implicit-def $al
  CALL64pcrel32 target-flags(x86-plt) @__isoc99_scanf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
  renamable $edx = MOV32rm $rsp, 1, $noreg, 4, $noreg, implicit-def $rdx :: (dereferenceable load (s32) from %ir.1, !tbaa !5)
  TEST32rr renamable $edx, renamable $edx, implicit-def $eflags
  JCC_1 %bb.1, 14, implicit $eflags

bb.2 (%ir-block.6):
; predecessors: %bb.0
  successors: %bb.3(0x40000000), %bb.8(0x40000000); %bb.3(50.00%), %bb.8(50.00%)
  liveins: $rdx
  renamable $rcx = LEA64r renamable $rdx, 1, $noreg, -1, $noreg
  $eax = MOV32rr $edx, implicit-def $rax
  renamable $eax = AND32ri renamable $eax(tied-def 0), 7, implicit-def dead $eflags, implicit killed $rax, implicit-def $rax
  CMP64ri32 killed renamable $rcx, 7, implicit-def $eflags
  JCC_1 %bb.8, 3, implicit killed $eflags

bb.3:
; predecessors: %bb.2
  successors: %bb.7(0x30000000), %bb.6(0x50000000); %bb.7(37.50%), %bb.6(62.50%)
  liveins: $rax
  $ecx = MOV32ri 1, implicit-def $rcx
  $esi = MOV32ri 1, implicit-def $rsi
  TEST64rr renamable $rax, renamable $rax, implicit-def $eflags
  JCC_1 %bb.6, 5, implicit $eflags
  JMP_1 %bb.7

bb.1:
; predecessors: %bb.0
  successors: %bb.7(0x80000000); %bb.7(100.00%)

  $esi = MOV32ri 1, implicit-def $rsi
  JMP_1 %bb.7

bb.8 (%ir-block.12):
; predecessors: %bb.2
  successors: %bb.9(0x80000000); %bb.9(100.00%)
  liveins: $rax, $rdx
  renamable $edx = AND32ri renamable $edx(tied-def 0), -8, implicit-def dead $eflags, implicit killed $rdx, implicit-def $rdx
  renamable $rdx = NEG64r killed renamable $rdx(tied-def 0), implicit-def dead $eflags
  $esi = MOV32ri 1, implicit-def $rsi
  $ecx = MOV32ri 8, implicit-def $rcx

bb.9 (%ir-block.34, align 16):
; predecessors: %bb.8, %bb.9
  successors: %bb.4(0x04000000), %bb.9(0x7c000000); %bb.4(3.12%), %bb.9(96.88%)
  liveins: $rax, $rcx, $rdx, $rsi
  renamable $rdi = LEA64r renamable $rcx, 1, $noreg, -7, $noreg
  renamable $rdi = IMUL64rr killed renamable $rdi(tied-def 0), killed renamable $rsi, implicit-def dead $eflags
  renamable $rsi = LEA64r renamable $rcx, 1, $noreg, -6, $noreg
  renamable $r8 = LEA64r renamable $rcx, 1, $noreg, -5, $noreg
  renamable $rsi = IMUL64rr killed renamable $rsi(tied-def 0), killed renamable $r8, implicit-def dead $eflags
  renamable $rsi = IMUL64rr killed renamable $rsi(tied-def 0), killed renamable $rdi, implicit-def dead $eflags
  renamable $rdi = LEA64r renamable $rcx, 1, $noreg, -4, $noreg
  renamable $r8 = LEA64r renamable $rcx, 1, $noreg, -3, $noreg
  renamable $rdi = IMUL64rr killed renamable $rdi(tied-def 0), killed renamable $r8, implicit-def dead $eflags
  renamable $r8 = LEA64r renamable $rcx, 1, $noreg, -2, $noreg
  renamable $r8 = IMUL64rr killed renamable $r8(tied-def 0), killed renamable $rdi, implicit-def dead $eflags
  renamable $r8 = IMUL64rr killed renamable $r8(tied-def 0), killed renamable $rsi, implicit-def dead $eflags
  renamable $rsi = LEA64r renamable $rcx, 1, $noreg, -1, $noreg
  renamable $rsi = IMUL64rr killed renamable $rsi(tied-def 0), renamable $rcx, implicit-def dead $eflags
  renamable $rsi = IMUL64rr killed renamable $rsi(tied-def 0), killed renamable $r8, implicit-def dead $eflags
  renamable $rdi = LEA64r renamable $rdx, 1, renamable $rcx, 0, $noreg
  $rdi = ADD64ri32 $rdi(tied-def 0), 8, implicit-def $eflags
  renamable $rcx = ADD64ri32 killed renamable $rcx(tied-def 0), 8, implicit-def dead $eflags
  CMP64ri32 killed renamable $rdi, 8, implicit-def $eflags
  JCC_1 %bb.9, 5, implicit $eflags

bb.4 (%ir-block.15):
; predecessors: %bb.9
  successors: %bb.7(0x30000000), %bb.6(0x50000000); %bb.7(37.50%), %bb.6(62.50%)
  liveins: $rax, $rcx, $rsi
  renamable $rcx = ADD64ri32 killed renamable $rcx(tied-def 0), -7, implicit-def dead $eflags
  TEST64rr renamable $rax, renamable $rax, implicit-def $eflags
  JCC_1 %bb.7, 4, implicit $eflags

bb.6 (%ir-block.23, align 16):
; predecessors: %bb.6, %bb.4, %bb.3
  successors: %bb.7(0x04000000), %bb.6(0x7c000000); %bb.7(3.12%), %bb.6(96.88%)
  liveins: $rax, $rcx, $rsi
  renamable $rsi = IMUL64rr killed renamable $rsi(tied-def 0), renamable $rcx, implicit-def dead $eflags
  renamable $rcx = nuw nsw INC64r killed renamable $rcx(tied-def 0), implicit-def dead $eflags
  renamable $rax = DEC64r killed renamable $rax(tied-def 0), implicit-def $eflags
  JCC_1 %bb.6, 5, implicit killed $eflags

bb.7 (%ir-block.31):
; predecessors: %bb.6, %bb.1, %bb.4, %bb.3
  liveins: $rsi
  renamable $rdi = LEA64r $rip, 1, $noreg, @.str.1, $noreg
  dead $eax = XOR32rr undef $eax(tied-def 0), undef $eax, implicit-def dead $eflags, implicit-def $al
  CALL64pcrel32 target-flags(x86-plt) @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
  $eax = XOR32rr undef $eax(tied-def 0), undef $eax, implicit-def dead $eflags
  $rcx = frame-destroy POP64r implicit-def $rsp, implicit $rsp
  frame-destroy CFI_INSTRUCTION def_cfa_offset 8
  RET64 $eax

# End machine code for function main.

# *** IR Dump After Stack Frame Layout Analysis (stack-frame-layout) ***:
# Machine code for function main: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
Frame Objects:
  fi#0: size=4, align=4, at location [SP-4]

bb.0 (%ir-block.0):
  successors: %bb.1(0x30000000), %bb.2(0x50000000); %bb.1(37.50%), %bb.2(62.50%)

  frame-setup PUSH64r undef $rax, implicit-def $rsp, implicit $rsp
  frame-setup CFI_INSTRUCTION def_cfa_offset 16
  renamable $rdi = LEA64r $rip, 1, $noreg, @.str, $noreg
  renamable $rsi = LEA64r $rsp, 1, $noreg, 4, $noreg
  dead $eax = XOR32rr undef $eax(tied-def 0), undef $eax, implicit-def dead $eflags, implicit-def $al
  CALL64pcrel32 target-flags(x86-plt) @__isoc99_scanf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
  renamable $edx = MOV32rm $rsp, 1, $noreg, 4, $noreg, implicit-def $rdx :: (dereferenceable load (s32) from %ir.1, !tbaa !5)
  TEST32rr renamable $edx, renamable $edx, implicit-def $eflags
  JCC_1 %bb.1, 14, implicit $eflags

bb.2 (%ir-block.6):
; predecessors: %bb.0
  successors: %bb.3(0x40000000), %bb.8(0x40000000); %bb.3(50.00%), %bb.8(50.00%)
  liveins: $rdx
  renamable $rcx = LEA64r renamable $rdx, 1, $noreg, -1, $noreg
  $eax = MOV32rr $edx, implicit-def $rax
  renamable $eax = AND32ri renamable $eax(tied-def 0), 7, implicit-def dead $eflags, implicit killed $rax, implicit-def $rax
  CMP64ri32 killed renamable $rcx, 7, implicit-def $eflags
  JCC_1 %bb.8, 3, implicit killed $eflags

bb.3:
; predecessors: %bb.2
  successors: %bb.7(0x30000000), %bb.6(0x50000000); %bb.7(37.50%), %bb.6(62.50%)
  liveins: $rax
  $ecx = MOV32ri 1, implicit-def $rcx
  $esi = MOV32ri 1, implicit-def $rsi
  TEST64rr renamable $rax, renamable $rax, implicit-def $eflags
  JCC_1 %bb.6, 5, implicit $eflags
  JMP_1 %bb.7

bb.1:
; predecessors: %bb.0
  successors: %bb.7(0x80000000); %bb.7(100.00%)

  $esi = MOV32ri 1, implicit-def $rsi
  JMP_1 %bb.7

bb.8 (%ir-block.12):
; predecessors: %bb.2
  successors: %bb.9(0x80000000); %bb.9(100.00%)
  liveins: $rax, $rdx
  renamable $edx = AND32ri renamable $edx(tied-def 0), -8, implicit-def dead $eflags, implicit killed $rdx, implicit-def $rdx
  renamable $rdx = NEG64r killed renamable $rdx(tied-def 0), implicit-def dead $eflags
  $esi = MOV32ri 1, implicit-def $rsi
  $ecx = MOV32ri 8, implicit-def $rcx

bb.9 (%ir-block.34, align 16):
; predecessors: %bb.8, %bb.9
  successors: %bb.4(0x04000000), %bb.9(0x7c000000); %bb.4(3.12%), %bb.9(96.88%)
  liveins: $rax, $rcx, $rdx, $rsi
  renamable $rdi = LEA64r renamable $rcx, 1, $noreg, -7, $noreg
  renamable $rdi = IMUL64rr killed renamable $rdi(tied-def 0), killed renamable $rsi, implicit-def dead $eflags
  renamable $rsi = LEA64r renamable $rcx, 1, $noreg, -6, $noreg
  renamable $r8 = LEA64r renamable $rcx, 1, $noreg, -5, $noreg
  renamable $rsi = IMUL64rr killed renamable $rsi(tied-def 0), killed renamable $r8, implicit-def dead $eflags
  renamable $rsi = IMUL64rr killed renamable $rsi(tied-def 0), killed renamable $rdi, implicit-def dead $eflags
  renamable $rdi = LEA64r renamable $rcx, 1, $noreg, -4, $noreg
  renamable $r8 = LEA64r renamable $rcx, 1, $noreg, -3, $noreg
  renamable $rdi = IMUL64rr killed renamable $rdi(tied-def 0), killed renamable $r8, implicit-def dead $eflags
  renamable $r8 = LEA64r renamable $rcx, 1, $noreg, -2, $noreg
  renamable $r8 = IMUL64rr killed renamable $r8(tied-def 0), killed renamable $rdi, implicit-def dead $eflags
  renamable $r8 = IMUL64rr killed renamable $r8(tied-def 0), killed renamable $rsi, implicit-def dead $eflags
  renamable $rsi = LEA64r renamable $rcx, 1, $noreg, -1, $noreg
  renamable $rsi = IMUL64rr killed renamable $rsi(tied-def 0), renamable $rcx, implicit-def dead $eflags
  renamable $rsi = IMUL64rr killed renamable $rsi(tied-def 0), killed renamable $r8, implicit-def dead $eflags
  renamable $rdi = LEA64r renamable $rdx, 1, renamable $rcx, 0, $noreg
  $rdi = ADD64ri32 $rdi(tied-def 0), 8, implicit-def $eflags
  renamable $rcx = ADD64ri32 killed renamable $rcx(tied-def 0), 8, implicit-def dead $eflags
  CMP64ri32 killed renamable $rdi, 8, implicit-def $eflags
  JCC_1 %bb.9, 5, implicit $eflags

bb.4 (%ir-block.15):
; predecessors: %bb.9
  successors: %bb.7(0x30000000), %bb.6(0x50000000); %bb.7(37.50%), %bb.6(62.50%)
  liveins: $rax, $rcx, $rsi
  renamable $rcx = ADD64ri32 killed renamable $rcx(tied-def 0), -7, implicit-def dead $eflags
  TEST64rr renamable $rax, renamable $rax, implicit-def $eflags
  JCC_1 %bb.7, 4, implicit $eflags

bb.6 (%ir-block.23, align 16):
; predecessors: %bb.6, %bb.4, %bb.3
  successors: %bb.7(0x04000000), %bb.6(0x7c000000); %bb.7(3.12%), %bb.6(96.88%)
  liveins: $rax, $rcx, $rsi
  renamable $rsi = IMUL64rr killed renamable $rsi(tied-def 0), renamable $rcx, implicit-def dead $eflags
  renamable $rcx = nuw nsw INC64r killed renamable $rcx(tied-def 0), implicit-def dead $eflags
  renamable $rax = DEC64r killed renamable $rax(tied-def 0), implicit-def $eflags
  JCC_1 %bb.6, 5, implicit killed $eflags

bb.7 (%ir-block.31):
; predecessors: %bb.6, %bb.1, %bb.4, %bb.3
  liveins: $rsi
  renamable $rdi = LEA64r $rip, 1, $noreg, @.str.1, $noreg
  dead $eax = XOR32rr undef $eax(tied-def 0), undef $eax, implicit-def dead $eflags, implicit-def $al
  CALL64pcrel32 target-flags(x86-plt) @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
  $eax = XOR32rr undef $eax(tied-def 0), undef $eax, implicit-def dead $eflags
  $rcx = frame-destroy POP64r implicit-def $rsp, implicit $rsp
  frame-destroy CFI_INSTRUCTION def_cfa_offset 8
  RET64 $eax

# End machine code for function main.

# *** IR Dump After X86 Speculative Execution Side Effect Suppression (x86-seses) ***:
# Machine code for function main: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
Frame Objects:
  fi#0: size=4, align=4, at location [SP-4]

bb.0 (%ir-block.0):
  successors: %bb.1(0x30000000), %bb.2(0x50000000); %bb.1(37.50%), %bb.2(62.50%)

  frame-setup PUSH64r undef $rax, implicit-def $rsp, implicit $rsp
  frame-setup CFI_INSTRUCTION def_cfa_offset 16
  renamable $rdi = LEA64r $rip, 1, $noreg, @.str, $noreg
  renamable $rsi = LEA64r $rsp, 1, $noreg, 4, $noreg
  dead $eax = XOR32rr undef $eax(tied-def 0), undef $eax, implicit-def dead $eflags, implicit-def $al
  CALL64pcrel32 target-flags(x86-plt) @__isoc99_scanf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
  renamable $edx = MOV32rm $rsp, 1, $noreg, 4, $noreg, implicit-def $rdx :: (dereferenceable load (s32) from %ir.1, !tbaa !5)
  TEST32rr renamable $edx, renamable $edx, implicit-def $eflags
  JCC_1 %bb.1, 14, implicit $eflags

bb.2 (%ir-block.6):
; predecessors: %bb.0
  successors: %bb.3(0x40000000), %bb.8(0x40000000); %bb.3(50.00%), %bb.8(50.00%)
  liveins: $rdx
  renamable $rcx = LEA64r renamable $rdx, 1, $noreg, -1, $noreg
  $eax = MOV32rr $edx, implicit-def $rax
  renamable $eax = AND32ri renamable $eax(tied-def 0), 7, implicit-def dead $eflags, implicit killed $rax, implicit-def $rax
  CMP64ri32 killed renamable $rcx, 7, implicit-def $eflags
  JCC_1 %bb.8, 3, implicit killed $eflags

bb.3:
; predecessors: %bb.2
  successors: %bb.7(0x30000000), %bb.6(0x50000000); %bb.7(37.50%), %bb.6(62.50%)
  liveins: $rax
  $ecx = MOV32ri 1, implicit-def $rcx
  $esi = MOV32ri 1, implicit-def $rsi
  TEST64rr renamable $rax, renamable $rax, implicit-def $eflags
  JCC_1 %bb.6, 5, implicit $eflags
  JMP_1 %bb.7

bb.1:
; predecessors: %bb.0
  successors: %bb.7(0x80000000); %bb.7(100.00%)

  $esi = MOV32ri 1, implicit-def $rsi
  JMP_1 %bb.7

bb.8 (%ir-block.12):
; predecessors: %bb.2
  successors: %bb.9(0x80000000); %bb.9(100.00%)
  liveins: $rax, $rdx
  renamable $edx = AND32ri renamable $edx(tied-def 0), -8, implicit-def dead $eflags, implicit killed $rdx, implicit-def $rdx
  renamable $rdx = NEG64r killed renamable $rdx(tied-def 0), implicit-def dead $eflags
  $esi = MOV32ri 1, implicit-def $rsi
  $ecx = MOV32ri 8, implicit-def $rcx

bb.9 (%ir-block.34, align 16):
; predecessors: %bb.8, %bb.9
  successors: %bb.4(0x04000000), %bb.9(0x7c000000); %bb.4(3.12%), %bb.9(96.88%)
  liveins: $rax, $rcx, $rdx, $rsi
  renamable $rdi = LEA64r renamable $rcx, 1, $noreg, -7, $noreg
  renamable $rdi = IMUL64rr killed renamable $rdi(tied-def 0), killed renamable $rsi, implicit-def dead $eflags
  renamable $rsi = LEA64r renamable $rcx, 1, $noreg, -6, $noreg
  renamable $r8 = LEA64r renamable $rcx, 1, $noreg, -5, $noreg
  renamable $rsi = IMUL64rr killed renamable $rsi(tied-def 0), killed renamable $r8, implicit-def dead $eflags
  renamable $rsi = IMUL64rr killed renamable $rsi(tied-def 0), killed renamable $rdi, implicit-def dead $eflags
  renamable $rdi = LEA64r renamable $rcx, 1, $noreg, -4, $noreg
  renamable $r8 = LEA64r renamable $rcx, 1, $noreg, -3, $noreg
  renamable $rdi = IMUL64rr killed renamable $rdi(tied-def 0), killed renamable $r8, implicit-def dead $eflags
  renamable $r8 = LEA64r renamable $rcx, 1, $noreg, -2, $noreg
  renamable $r8 = IMUL64rr killed renamable $r8(tied-def 0), killed renamable $rdi, implicit-def dead $eflags
  renamable $r8 = IMUL64rr killed renamable $r8(tied-def 0), killed renamable $rsi, implicit-def dead $eflags
  renamable $rsi = LEA64r renamable $rcx, 1, $noreg, -1, $noreg
  renamable $rsi = IMUL64rr killed renamable $rsi(tied-def 0), renamable $rcx, implicit-def dead $eflags
  renamable $rsi = IMUL64rr killed renamable $rsi(tied-def 0), killed renamable $r8, implicit-def dead $eflags
  renamable $rdi = LEA64r renamable $rdx, 1, renamable $rcx, 0, $noreg
  $rdi = ADD64ri32 $rdi(tied-def 0), 8, implicit-def $eflags
  renamable $rcx = ADD64ri32 killed renamable $rcx(tied-def 0), 8, implicit-def dead $eflags
  CMP64ri32 killed renamable $rdi, 8, implicit-def $eflags
  JCC_1 %bb.9, 5, implicit $eflags

bb.4 (%ir-block.15):
; predecessors: %bb.9
  successors: %bb.7(0x30000000), %bb.6(0x50000000); %bb.7(37.50%), %bb.6(62.50%)
  liveins: $rax, $rcx, $rsi
  renamable $rcx = ADD64ri32 killed renamable $rcx(tied-def 0), -7, implicit-def dead $eflags
  TEST64rr renamable $rax, renamable $rax, implicit-def $eflags
  JCC_1 %bb.7, 4, implicit $eflags

bb.6 (%ir-block.23, align 16):
; predecessors: %bb.6, %bb.4, %bb.3
  successors: %bb.7(0x04000000), %bb.6(0x7c000000); %bb.7(3.12%), %bb.6(96.88%)
  liveins: $rax, $rcx, $rsi
  renamable $rsi = IMUL64rr killed renamable $rsi(tied-def 0), renamable $rcx, implicit-def dead $eflags
  renamable $rcx = nuw nsw INC64r killed renamable $rcx(tied-def 0), implicit-def dead $eflags
  renamable $rax = DEC64r killed renamable $rax(tied-def 0), implicit-def $eflags
  JCC_1 %bb.6, 5, implicit killed $eflags

bb.7 (%ir-block.31):
; predecessors: %bb.6, %bb.1, %bb.4, %bb.3
  liveins: $rsi
  renamable $rdi = LEA64r $rip, 1, $noreg, @.str.1, $noreg
  dead $eax = XOR32rr undef $eax(tied-def 0), undef $eax, implicit-def dead $eflags, implicit-def $al
  CALL64pcrel32 target-flags(x86-plt) @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
  $eax = XOR32rr undef $eax(tied-def 0), undef $eax, implicit-def dead $eflags
  $rcx = frame-destroy POP64r implicit-def $rsp, implicit $rsp
  frame-destroy CFI_INSTRUCTION def_cfa_offset 8
  RET64 $eax

# End machine code for function main.

# *** IR Dump After X86 Return Thunks (x86-return-thunks) ***:
# Machine code for function main: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
Frame Objects:
  fi#0: size=4, align=4, at location [SP-4]

bb.0 (%ir-block.0):
  successors: %bb.1(0x30000000), %bb.2(0x50000000); %bb.1(37.50%), %bb.2(62.50%)

  frame-setup PUSH64r undef $rax, implicit-def $rsp, implicit $rsp
  frame-setup CFI_INSTRUCTION def_cfa_offset 16
  renamable $rdi = LEA64r $rip, 1, $noreg, @.str, $noreg
  renamable $rsi = LEA64r $rsp, 1, $noreg, 4, $noreg
  dead $eax = XOR32rr undef $eax(tied-def 0), undef $eax, implicit-def dead $eflags, implicit-def $al
  CALL64pcrel32 target-flags(x86-plt) @__isoc99_scanf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
  renamable $edx = MOV32rm $rsp, 1, $noreg, 4, $noreg, implicit-def $rdx :: (dereferenceable load (s32) from %ir.1, !tbaa !5)
  TEST32rr renamable $edx, renamable $edx, implicit-def $eflags
  JCC_1 %bb.1, 14, implicit $eflags

bb.2 (%ir-block.6):
; predecessors: %bb.0
  successors: %bb.3(0x40000000), %bb.8(0x40000000); %bb.3(50.00%), %bb.8(50.00%)
  liveins: $rdx
  renamable $rcx = LEA64r renamable $rdx, 1, $noreg, -1, $noreg
  $eax = MOV32rr $edx, implicit-def $rax
  renamable $eax = AND32ri renamable $eax(tied-def 0), 7, implicit-def dead $eflags, implicit killed $rax, implicit-def $rax
  CMP64ri32 killed renamable $rcx, 7, implicit-def $eflags
  JCC_1 %bb.8, 3, implicit killed $eflags

bb.3:
; predecessors: %bb.2
  successors: %bb.7(0x30000000), %bb.6(0x50000000); %bb.7(37.50%), %bb.6(62.50%)
  liveins: $rax
  $ecx = MOV32ri 1, implicit-def $rcx
  $esi = MOV32ri 1, implicit-def $rsi
  TEST64rr renamable $rax, renamable $rax, implicit-def $eflags
  JCC_1 %bb.6, 5, implicit $eflags
  JMP_1 %bb.7

bb.1:
; predecessors: %bb.0
  successors: %bb.7(0x80000000); %bb.7(100.00%)

  $esi = MOV32ri 1, implicit-def $rsi
  JMP_1 %bb.7

bb.8 (%ir-block.12):
; predecessors: %bb.2
  successors: %bb.9(0x80000000); %bb.9(100.00%)
  liveins: $rax, $rdx
  renamable $edx = AND32ri renamable $edx(tied-def 0), -8, implicit-def dead $eflags, implicit killed $rdx, implicit-def $rdx
  renamable $rdx = NEG64r killed renamable $rdx(tied-def 0), implicit-def dead $eflags
  $esi = MOV32ri 1, implicit-def $rsi
  $ecx = MOV32ri 8, implicit-def $rcx

bb.9 (%ir-block.34, align 16):
; predecessors: %bb.8, %bb.9
  successors: %bb.4(0x04000000), %bb.9(0x7c000000); %bb.4(3.12%), %bb.9(96.88%)
  liveins: $rax, $rcx, $rdx, $rsi
  renamable $rdi = LEA64r renamable $rcx, 1, $noreg, -7, $noreg
  renamable $rdi = IMUL64rr killed renamable $rdi(tied-def 0), killed renamable $rsi, implicit-def dead $eflags
  renamable $rsi = LEA64r renamable $rcx, 1, $noreg, -6, $noreg
  renamable $r8 = LEA64r renamable $rcx, 1, $noreg, -5, $noreg
  renamable $rsi = IMUL64rr killed renamable $rsi(tied-def 0), killed renamable $r8, implicit-def dead $eflags
  renamable $rsi = IMUL64rr killed renamable $rsi(tied-def 0), killed renamable $rdi, implicit-def dead $eflags
  renamable $rdi = LEA64r renamable $rcx, 1, $noreg, -4, $noreg
  renamable $r8 = LEA64r renamable $rcx, 1, $noreg, -3, $noreg
  renamable $rdi = IMUL64rr killed renamable $rdi(tied-def 0), killed renamable $r8, implicit-def dead $eflags
  renamable $r8 = LEA64r renamable $rcx, 1, $noreg, -2, $noreg
  renamable $r8 = IMUL64rr killed renamable $r8(tied-def 0), killed renamable $rdi, implicit-def dead $eflags
  renamable $r8 = IMUL64rr killed renamable $r8(tied-def 0), killed renamable $rsi, implicit-def dead $eflags
  renamable $rsi = LEA64r renamable $rcx, 1, $noreg, -1, $noreg
  renamable $rsi = IMUL64rr killed renamable $rsi(tied-def 0), renamable $rcx, implicit-def dead $eflags
  renamable $rsi = IMUL64rr killed renamable $rsi(tied-def 0), killed renamable $r8, implicit-def dead $eflags
  renamable $rdi = LEA64r renamable $rdx, 1, renamable $rcx, 0, $noreg
  $rdi = ADD64ri32 $rdi(tied-def 0), 8, implicit-def $eflags
  renamable $rcx = ADD64ri32 killed renamable $rcx(tied-def 0), 8, implicit-def dead $eflags
  CMP64ri32 killed renamable $rdi, 8, implicit-def $eflags
  JCC_1 %bb.9, 5, implicit $eflags

bb.4 (%ir-block.15):
; predecessors: %bb.9
  successors: %bb.7(0x30000000), %bb.6(0x50000000); %bb.7(37.50%), %bb.6(62.50%)
  liveins: $rax, $rcx, $rsi
  renamable $rcx = ADD64ri32 killed renamable $rcx(tied-def 0), -7, implicit-def dead $eflags
  TEST64rr renamable $rax, renamable $rax, implicit-def $eflags
  JCC_1 %bb.7, 4, implicit $eflags

bb.6 (%ir-block.23, align 16):
; predecessors: %bb.6, %bb.4, %bb.3
  successors: %bb.7(0x04000000), %bb.6(0x7c000000); %bb.7(3.12%), %bb.6(96.88%)
  liveins: $rax, $rcx, $rsi
  renamable $rsi = IMUL64rr killed renamable $rsi(tied-def 0), renamable $rcx, implicit-def dead $eflags
  renamable $rcx = nuw nsw INC64r killed renamable $rcx(tied-def 0), implicit-def dead $eflags
  renamable $rax = DEC64r killed renamable $rax(tied-def 0), implicit-def $eflags
  JCC_1 %bb.6, 5, implicit killed $eflags

bb.7 (%ir-block.31):
; predecessors: %bb.6, %bb.1, %bb.4, %bb.3
  liveins: $rsi
  renamable $rdi = LEA64r $rip, 1, $noreg, @.str.1, $noreg
  dead $eax = XOR32rr undef $eax(tied-def 0), undef $eax, implicit-def dead $eflags, implicit-def $al
  CALL64pcrel32 target-flags(x86-plt) @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
  $eax = XOR32rr undef $eax(tied-def 0), undef $eax, implicit-def dead $eflags
  $rcx = frame-destroy POP64r implicit-def $rsp, implicit $rsp
  frame-destroy CFI_INSTRUCTION def_cfa_offset 8
  RET64 $eax

# End machine code for function main.

# *** IR Dump After Check CFA info and insert CFI instructions if needed (cfi-instr-inserter) ***:
# Machine code for function main: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
Frame Objects:
  fi#0: size=4, align=4, at location [SP-4]

bb.0 (%ir-block.0):
  successors: %bb.1(0x30000000), %bb.2(0x50000000); %bb.1(37.50%), %bb.2(62.50%)

  frame-setup PUSH64r undef $rax, implicit-def $rsp, implicit $rsp
  frame-setup CFI_INSTRUCTION def_cfa_offset 16
  renamable $rdi = LEA64r $rip, 1, $noreg, @.str, $noreg
  renamable $rsi = LEA64r $rsp, 1, $noreg, 4, $noreg
  dead $eax = XOR32rr undef $eax(tied-def 0), undef $eax, implicit-def dead $eflags, implicit-def $al
  CALL64pcrel32 target-flags(x86-plt) @__isoc99_scanf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
  renamable $edx = MOV32rm $rsp, 1, $noreg, 4, $noreg, implicit-def $rdx :: (dereferenceable load (s32) from %ir.1, !tbaa !5)
  TEST32rr renamable $edx, renamable $edx, implicit-def $eflags
  JCC_1 %bb.1, 14, implicit $eflags

bb.2 (%ir-block.6):
; predecessors: %bb.0
  successors: %bb.3(0x40000000), %bb.8(0x40000000); %bb.3(50.00%), %bb.8(50.00%)
  liveins: $rdx
  renamable $rcx = LEA64r renamable $rdx, 1, $noreg, -1, $noreg
  $eax = MOV32rr $edx, implicit-def $rax
  renamable $eax = AND32ri renamable $eax(tied-def 0), 7, implicit-def dead $eflags, implicit killed $rax, implicit-def $rax
  CMP64ri32 killed renamable $rcx, 7, implicit-def $eflags
  JCC_1 %bb.8, 3, implicit killed $eflags

bb.3:
; predecessors: %bb.2
  successors: %bb.7(0x30000000), %bb.6(0x50000000); %bb.7(37.50%), %bb.6(62.50%)
  liveins: $rax
  $ecx = MOV32ri 1, implicit-def $rcx
  $esi = MOV32ri 1, implicit-def $rsi
  TEST64rr renamable $rax, renamable $rax, implicit-def $eflags
  JCC_1 %bb.6, 5, implicit $eflags
  JMP_1 %bb.7

bb.1:
; predecessors: %bb.0
  successors: %bb.7(0x80000000); %bb.7(100.00%)

  $esi = MOV32ri 1, implicit-def $rsi
  JMP_1 %bb.7

bb.8 (%ir-block.12):
; predecessors: %bb.2
  successors: %bb.9(0x80000000); %bb.9(100.00%)
  liveins: $rax, $rdx
  renamable $edx = AND32ri renamable $edx(tied-def 0), -8, implicit-def dead $eflags, implicit killed $rdx, implicit-def $rdx
  renamable $rdx = NEG64r killed renamable $rdx(tied-def 0), implicit-def dead $eflags
  $esi = MOV32ri 1, implicit-def $rsi
  $ecx = MOV32ri 8, implicit-def $rcx

bb.9 (%ir-block.34, align 16):
; predecessors: %bb.8, %bb.9
  successors: %bb.4(0x04000000), %bb.9(0x7c000000); %bb.4(3.12%), %bb.9(96.88%)
  liveins: $rax, $rcx, $rdx, $rsi
  renamable $rdi = LEA64r renamable $rcx, 1, $noreg, -7, $noreg
  renamable $rdi = IMUL64rr killed renamable $rdi(tied-def 0), killed renamable $rsi, implicit-def dead $eflags
  renamable $rsi = LEA64r renamable $rcx, 1, $noreg, -6, $noreg
  renamable $r8 = LEA64r renamable $rcx, 1, $noreg, -5, $noreg
  renamable $rsi = IMUL64rr killed renamable $rsi(tied-def 0), killed renamable $r8, implicit-def dead $eflags
  renamable $rsi = IMUL64rr killed renamable $rsi(tied-def 0), killed renamable $rdi, implicit-def dead $eflags
  renamable $rdi = LEA64r renamable $rcx, 1, $noreg, -4, $noreg
  renamable $r8 = LEA64r renamable $rcx, 1, $noreg, -3, $noreg
  renamable $rdi = IMUL64rr killed renamable $rdi(tied-def 0), killed renamable $r8, implicit-def dead $eflags
  renamable $r8 = LEA64r renamable $rcx, 1, $noreg, -2, $noreg
  renamable $r8 = IMUL64rr killed renamable $r8(tied-def 0), killed renamable $rdi, implicit-def dead $eflags
  renamable $r8 = IMUL64rr killed renamable $r8(tied-def 0), killed renamable $rsi, implicit-def dead $eflags
  renamable $rsi = LEA64r renamable $rcx, 1, $noreg, -1, $noreg
  renamable $rsi = IMUL64rr killed renamable $rsi(tied-def 0), renamable $rcx, implicit-def dead $eflags
  renamable $rsi = IMUL64rr killed renamable $rsi(tied-def 0), killed renamable $r8, implicit-def dead $eflags
  renamable $rdi = LEA64r renamable $rdx, 1, renamable $rcx, 0, $noreg
  $rdi = ADD64ri32 $rdi(tied-def 0), 8, implicit-def $eflags
  renamable $rcx = ADD64ri32 killed renamable $rcx(tied-def 0), 8, implicit-def dead $eflags
  CMP64ri32 killed renamable $rdi, 8, implicit-def $eflags
  JCC_1 %bb.9, 5, implicit $eflags

bb.4 (%ir-block.15):
; predecessors: %bb.9
  successors: %bb.7(0x30000000), %bb.6(0x50000000); %bb.7(37.50%), %bb.6(62.50%)
  liveins: $rax, $rcx, $rsi
  renamable $rcx = ADD64ri32 killed renamable $rcx(tied-def 0), -7, implicit-def dead $eflags
  TEST64rr renamable $rax, renamable $rax, implicit-def $eflags
  JCC_1 %bb.7, 4, implicit $eflags

bb.6 (%ir-block.23, align 16):
; predecessors: %bb.6, %bb.4, %bb.3
  successors: %bb.7(0x04000000), %bb.6(0x7c000000); %bb.7(3.12%), %bb.6(96.88%)
  liveins: $rax, $rcx, $rsi
  renamable $rsi = IMUL64rr killed renamable $rsi(tied-def 0), renamable $rcx, implicit-def dead $eflags
  renamable $rcx = nuw nsw INC64r killed renamable $rcx(tied-def 0), implicit-def dead $eflags
  renamable $rax = DEC64r killed renamable $rax(tied-def 0), implicit-def $eflags
  JCC_1 %bb.6, 5, implicit killed $eflags

bb.7 (%ir-block.31):
; predecessors: %bb.6, %bb.1, %bb.4, %bb.3
  liveins: $rsi
  renamable $rdi = LEA64r $rip, 1, $noreg, @.str.1, $noreg
  dead $eax = XOR32rr undef $eax(tied-def 0), undef $eax, implicit-def dead $eflags, implicit-def $al
  CALL64pcrel32 target-flags(x86-plt) @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
  $eax = XOR32rr undef $eax(tied-def 0), undef $eax, implicit-def dead $eflags
  $rcx = frame-destroy POP64r implicit-def $rsp, implicit $rsp
  frame-destroy CFI_INSTRUCTION def_cfa_offset 8
  RET64 $eax

# End machine code for function main.

# *** IR Dump After X86 Load Value Injection (LVI) Ret-Hardening (x86-lvi-ret) ***:
# Machine code for function main: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
Frame Objects:
  fi#0: size=4, align=4, at location [SP-4]

bb.0 (%ir-block.0):
  successors: %bb.1(0x30000000), %bb.2(0x50000000); %bb.1(37.50%), %bb.2(62.50%)

  frame-setup PUSH64r undef $rax, implicit-def $rsp, implicit $rsp
  frame-setup CFI_INSTRUCTION def_cfa_offset 16
  renamable $rdi = LEA64r $rip, 1, $noreg, @.str, $noreg
  renamable $rsi = LEA64r $rsp, 1, $noreg, 4, $noreg
  dead $eax = XOR32rr undef $eax(tied-def 0), undef $eax, implicit-def dead $eflags, implicit-def $al
  CALL64pcrel32 target-flags(x86-plt) @__isoc99_scanf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
  renamable $edx = MOV32rm $rsp, 1, $noreg, 4, $noreg, implicit-def $rdx :: (dereferenceable load (s32) from %ir.1, !tbaa !5)
  TEST32rr renamable $edx, renamable $edx, implicit-def $eflags
  JCC_1 %bb.1, 14, implicit $eflags

bb.2 (%ir-block.6):
; predecessors: %bb.0
  successors: %bb.3(0x40000000), %bb.8(0x40000000); %bb.3(50.00%), %bb.8(50.00%)
  liveins: $rdx
  renamable $rcx = LEA64r renamable $rdx, 1, $noreg, -1, $noreg
  $eax = MOV32rr $edx, implicit-def $rax
  renamable $eax = AND32ri renamable $eax(tied-def 0), 7, implicit-def dead $eflags, implicit killed $rax, implicit-def $rax
  CMP64ri32 killed renamable $rcx, 7, implicit-def $eflags
  JCC_1 %bb.8, 3, implicit killed $eflags

bb.3:
; predecessors: %bb.2
  successors: %bb.7(0x30000000), %bb.6(0x50000000); %bb.7(37.50%), %bb.6(62.50%)
  liveins: $rax
  $ecx = MOV32ri 1, implicit-def $rcx
  $esi = MOV32ri 1, implicit-def $rsi
  TEST64rr renamable $rax, renamable $rax, implicit-def $eflags
  JCC_1 %bb.6, 5, implicit $eflags
  JMP_1 %bb.7

bb.1:
; predecessors: %bb.0
  successors: %bb.7(0x80000000); %bb.7(100.00%)

  $esi = MOV32ri 1, implicit-def $rsi
  JMP_1 %bb.7

bb.8 (%ir-block.12):
; predecessors: %bb.2
  successors: %bb.9(0x80000000); %bb.9(100.00%)
  liveins: $rax, $rdx
  renamable $edx = AND32ri renamable $edx(tied-def 0), -8, implicit-def dead $eflags, implicit killed $rdx, implicit-def $rdx
  renamable $rdx = NEG64r killed renamable $rdx(tied-def 0), implicit-def dead $eflags
  $esi = MOV32ri 1, implicit-def $rsi
  $ecx = MOV32ri 8, implicit-def $rcx

bb.9 (%ir-block.34, align 16):
; predecessors: %bb.8, %bb.9
  successors: %bb.4(0x04000000), %bb.9(0x7c000000); %bb.4(3.12%), %bb.9(96.88%)
  liveins: $rax, $rcx, $rdx, $rsi
  renamable $rdi = LEA64r renamable $rcx, 1, $noreg, -7, $noreg
  renamable $rdi = IMUL64rr killed renamable $rdi(tied-def 0), killed renamable $rsi, implicit-def dead $eflags
  renamable $rsi = LEA64r renamable $rcx, 1, $noreg, -6, $noreg
  renamable $r8 = LEA64r renamable $rcx, 1, $noreg, -5, $noreg
  renamable $rsi = IMUL64rr killed renamable $rsi(tied-def 0), killed renamable $r8, implicit-def dead $eflags
  renamable $rsi = IMUL64rr killed renamable $rsi(tied-def 0), killed renamable $rdi, implicit-def dead $eflags
  renamable $rdi = LEA64r renamable $rcx, 1, $noreg, -4, $noreg
  renamable $r8 = LEA64r renamable $rcx, 1, $noreg, -3, $noreg
  renamable $rdi = IMUL64rr killed renamable $rdi(tied-def 0), killed renamable $r8, implicit-def dead $eflags
  renamable $r8 = LEA64r renamable $rcx, 1, $noreg, -2, $noreg
  renamable $r8 = IMUL64rr killed renamable $r8(tied-def 0), killed renamable $rdi, implicit-def dead $eflags
  renamable $r8 = IMUL64rr killed renamable $r8(tied-def 0), killed renamable $rsi, implicit-def dead $eflags
  renamable $rsi = LEA64r renamable $rcx, 1, $noreg, -1, $noreg
  renamable $rsi = IMUL64rr killed renamable $rsi(tied-def 0), renamable $rcx, implicit-def dead $eflags
  renamable $rsi = IMUL64rr killed renamable $rsi(tied-def 0), killed renamable $r8, implicit-def dead $eflags
  renamable $rdi = LEA64r renamable $rdx, 1, renamable $rcx, 0, $noreg
  $rdi = ADD64ri32 $rdi(tied-def 0), 8, implicit-def $eflags
  renamable $rcx = ADD64ri32 killed renamable $rcx(tied-def 0), 8, implicit-def dead $eflags
  CMP64ri32 killed renamable $rdi, 8, implicit-def $eflags
  JCC_1 %bb.9, 5, implicit $eflags

bb.4 (%ir-block.15):
; predecessors: %bb.9
  successors: %bb.7(0x30000000), %bb.6(0x50000000); %bb.7(37.50%), %bb.6(62.50%)
  liveins: $rax, $rcx, $rsi
  renamable $rcx = ADD64ri32 killed renamable $rcx(tied-def 0), -7, implicit-def dead $eflags
  TEST64rr renamable $rax, renamable $rax, implicit-def $eflags
  JCC_1 %bb.7, 4, implicit $eflags

bb.6 (%ir-block.23, align 16):
; predecessors: %bb.6, %bb.4, %bb.3
  successors: %bb.7(0x04000000), %bb.6(0x7c000000); %bb.7(3.12%), %bb.6(96.88%)
  liveins: $rax, $rcx, $rsi
  renamable $rsi = IMUL64rr killed renamable $rsi(tied-def 0), renamable $rcx, implicit-def dead $eflags
  renamable $rcx = nuw nsw INC64r killed renamable $rcx(tied-def 0), implicit-def dead $eflags
  renamable $rax = DEC64r killed renamable $rax(tied-def 0), implicit-def $eflags
  JCC_1 %bb.6, 5, implicit killed $eflags

bb.7 (%ir-block.31):
; predecessors: %bb.6, %bb.1, %bb.4, %bb.3
  liveins: $rsi
  renamable $rdi = LEA64r $rip, 1, $noreg, @.str.1, $noreg
  dead $eax = XOR32rr undef $eax(tied-def 0), undef $eax, implicit-def dead $eflags, implicit-def $al
  CALL64pcrel32 target-flags(x86-plt) @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
  $eax = XOR32rr undef $eax(tied-def 0), undef $eax, implicit-def dead $eflags
  $rcx = frame-destroy POP64r implicit-def $rsp, implicit $rsp
  frame-destroy CFI_INSTRUCTION def_cfa_offset 8
  RET64 $eax

# End machine code for function main.

# *** IR Dump After Pseudo Probe Inserter (pseudo-probe-inserter) ***:
# Machine code for function main: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
Frame Objects:
  fi#0: size=4, align=4, at location [SP-4]

bb.0 (%ir-block.0):
  successors: %bb.1(0x30000000), %bb.2(0x50000000); %bb.1(37.50%), %bb.2(62.50%)

  frame-setup PUSH64r undef $rax, implicit-def $rsp, implicit $rsp
  frame-setup CFI_INSTRUCTION def_cfa_offset 16
  renamable $rdi = LEA64r $rip, 1, $noreg, @.str, $noreg
  renamable $rsi = LEA64r $rsp, 1, $noreg, 4, $noreg
  dead $eax = XOR32rr undef $eax(tied-def 0), undef $eax, implicit-def dead $eflags, implicit-def $al
  CALL64pcrel32 target-flags(x86-plt) @__isoc99_scanf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
  renamable $edx = MOV32rm $rsp, 1, $noreg, 4, $noreg, implicit-def $rdx :: (dereferenceable load (s32) from %ir.1, !tbaa !5)
  TEST32rr renamable $edx, renamable $edx, implicit-def $eflags
  JCC_1 %bb.1, 14, implicit $eflags

bb.2 (%ir-block.6):
; predecessors: %bb.0
  successors: %bb.3(0x40000000), %bb.8(0x40000000); %bb.3(50.00%), %bb.8(50.00%)
  liveins: $rdx
  renamable $rcx = LEA64r renamable $rdx, 1, $noreg, -1, $noreg
  $eax = MOV32rr $edx, implicit-def $rax
  renamable $eax = AND32ri renamable $eax(tied-def 0), 7, implicit-def dead $eflags, implicit killed $rax, implicit-def $rax
  CMP64ri32 killed renamable $rcx, 7, implicit-def $eflags
  JCC_1 %bb.8, 3, implicit killed $eflags

bb.3:
; predecessors: %bb.2
  successors: %bb.7(0x30000000), %bb.6(0x50000000); %bb.7(37.50%), %bb.6(62.50%)
  liveins: $rax
  $ecx = MOV32ri 1, implicit-def $rcx
  $esi = MOV32ri 1, implicit-def $rsi
  TEST64rr renamable $rax, renamable $rax, implicit-def $eflags
  JCC_1 %bb.6, 5, implicit $eflags
  JMP_1 %bb.7

bb.1:
; predecessors: %bb.0
  successors: %bb.7(0x80000000); %bb.7(100.00%)

  $esi = MOV32ri 1, implicit-def $rsi
  JMP_1 %bb.7

bb.8 (%ir-block.12):
; predecessors: %bb.2
  successors: %bb.9(0x80000000); %bb.9(100.00%)
  liveins: $rax, $rdx
  renamable $edx = AND32ri renamable $edx(tied-def 0), -8, implicit-def dead $eflags, implicit killed $rdx, implicit-def $rdx
  renamable $rdx = NEG64r killed renamable $rdx(tied-def 0), implicit-def dead $eflags
  $esi = MOV32ri 1, implicit-def $rsi
  $ecx = MOV32ri 8, implicit-def $rcx

bb.9 (%ir-block.34, align 16):
; predecessors: %bb.8, %bb.9
  successors: %bb.4(0x04000000), %bb.9(0x7c000000); %bb.4(3.12%), %bb.9(96.88%)
  liveins: $rax, $rcx, $rdx, $rsi
  renamable $rdi = LEA64r renamable $rcx, 1, $noreg, -7, $noreg
  renamable $rdi = IMUL64rr killed renamable $rdi(tied-def 0), killed renamable $rsi, implicit-def dead $eflags
  renamable $rsi = LEA64r renamable $rcx, 1, $noreg, -6, $noreg
  renamable $r8 = LEA64r renamable $rcx, 1, $noreg, -5, $noreg
  renamable $rsi = IMUL64rr killed renamable $rsi(tied-def 0), killed renamable $r8, implicit-def dead $eflags
  renamable $rsi = IMUL64rr killed renamable $rsi(tied-def 0), killed renamable $rdi, implicit-def dead $eflags
  renamable $rdi = LEA64r renamable $rcx, 1, $noreg, -4, $noreg
  renamable $r8 = LEA64r renamable $rcx, 1, $noreg, -3, $noreg
  renamable $rdi = IMUL64rr killed renamable $rdi(tied-def 0), killed renamable $r8, implicit-def dead $eflags
  renamable $r8 = LEA64r renamable $rcx, 1, $noreg, -2, $noreg
  renamable $r8 = IMUL64rr killed renamable $r8(tied-def 0), killed renamable $rdi, implicit-def dead $eflags
  renamable $r8 = IMUL64rr killed renamable $r8(tied-def 0), killed renamable $rsi, implicit-def dead $eflags
  renamable $rsi = LEA64r renamable $rcx, 1, $noreg, -1, $noreg
  renamable $rsi = IMUL64rr killed renamable $rsi(tied-def 0), renamable $rcx, implicit-def dead $eflags
  renamable $rsi = IMUL64rr killed renamable $rsi(tied-def 0), killed renamable $r8, implicit-def dead $eflags
  renamable $rdi = LEA64r renamable $rdx, 1, renamable $rcx, 0, $noreg
  $rdi = ADD64ri32 $rdi(tied-def 0), 8, implicit-def $eflags
  renamable $rcx = ADD64ri32 killed renamable $rcx(tied-def 0), 8, implicit-def dead $eflags
  CMP64ri32 killed renamable $rdi, 8, implicit-def $eflags
  JCC_1 %bb.9, 5, implicit $eflags

bb.4 (%ir-block.15):
; predecessors: %bb.9
  successors: %bb.7(0x30000000), %bb.6(0x50000000); %bb.7(37.50%), %bb.6(62.50%)
  liveins: $rax, $rcx, $rsi
  renamable $rcx = ADD64ri32 killed renamable $rcx(tied-def 0), -7, implicit-def dead $eflags
  TEST64rr renamable $rax, renamable $rax, implicit-def $eflags
  JCC_1 %bb.7, 4, implicit $eflags

bb.6 (%ir-block.23, align 16):
; predecessors: %bb.6, %bb.4, %bb.3
  successors: %bb.7(0x04000000), %bb.6(0x7c000000); %bb.7(3.12%), %bb.6(96.88%)
  liveins: $rax, $rcx, $rsi
  renamable $rsi = IMUL64rr killed renamable $rsi(tied-def 0), renamable $rcx, implicit-def dead $eflags
  renamable $rcx = nuw nsw INC64r killed renamable $rcx(tied-def 0), implicit-def dead $eflags
  renamable $rax = DEC64r killed renamable $rax(tied-def 0), implicit-def $eflags
  JCC_1 %bb.6, 5, implicit killed $eflags

bb.7 (%ir-block.31):
; predecessors: %bb.6, %bb.1, %bb.4, %bb.3
  liveins: $rsi
  renamable $rdi = LEA64r $rip, 1, $noreg, @.str.1, $noreg
  dead $eax = XOR32rr undef $eax(tied-def 0), undef $eax, implicit-def dead $eflags, implicit-def $al
  CALL64pcrel32 target-flags(x86-plt) @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
  $eax = XOR32rr undef $eax(tied-def 0), undef $eax, implicit-def dead $eflags
  $rcx = frame-destroy POP64r implicit-def $rsp, implicit $rsp
  frame-destroy CFI_INSTRUCTION def_cfa_offset 8
  RET64 $eax

# End machine code for function main.

# *** IR Dump After Unpack machine instruction bundles (unpack-mi-bundles) ***:
# Machine code for function main: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
Frame Objects:
  fi#0: size=4, align=4, at location [SP-4]

bb.0 (%ir-block.0):
  successors: %bb.1(0x30000000), %bb.2(0x50000000); %bb.1(37.50%), %bb.2(62.50%)

  frame-setup PUSH64r undef $rax, implicit-def $rsp, implicit $rsp
  frame-setup CFI_INSTRUCTION def_cfa_offset 16
  renamable $rdi = LEA64r $rip, 1, $noreg, @.str, $noreg
  renamable $rsi = LEA64r $rsp, 1, $noreg, 4, $noreg
  dead $eax = XOR32rr undef $eax(tied-def 0), undef $eax, implicit-def dead $eflags, implicit-def $al
  CALL64pcrel32 target-flags(x86-plt) @__isoc99_scanf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
  renamable $edx = MOV32rm $rsp, 1, $noreg, 4, $noreg, implicit-def $rdx :: (dereferenceable load (s32) from %ir.1, !tbaa !5)
  TEST32rr renamable $edx, renamable $edx, implicit-def $eflags
  JCC_1 %bb.1, 14, implicit $eflags

bb.2 (%ir-block.6):
; predecessors: %bb.0
  successors: %bb.3(0x40000000), %bb.8(0x40000000); %bb.3(50.00%), %bb.8(50.00%)
  liveins: $rdx
  renamable $rcx = LEA64r renamable $rdx, 1, $noreg, -1, $noreg
  $eax = MOV32rr $edx, implicit-def $rax
  renamable $eax = AND32ri renamable $eax(tied-def 0), 7, implicit-def dead $eflags, implicit killed $rax, implicit-def $rax
  CMP64ri32 killed renamable $rcx, 7, implicit-def $eflags
  JCC_1 %bb.8, 3, implicit killed $eflags

bb.3:
; predecessors: %bb.2
  successors: %bb.7(0x30000000), %bb.6(0x50000000); %bb.7(37.50%), %bb.6(62.50%)
  liveins: $rax
  $ecx = MOV32ri 1, implicit-def $rcx
  $esi = MOV32ri 1, implicit-def $rsi
  TEST64rr renamable $rax, renamable $rax, implicit-def $eflags
  JCC_1 %bb.6, 5, implicit $eflags
  JMP_1 %bb.7

bb.1:
; predecessors: %bb.0
  successors: %bb.7(0x80000000); %bb.7(100.00%)

  $esi = MOV32ri 1, implicit-def $rsi
  JMP_1 %bb.7

bb.8 (%ir-block.12):
; predecessors: %bb.2
  successors: %bb.9(0x80000000); %bb.9(100.00%)
  liveins: $rax, $rdx
  renamable $edx = AND32ri renamable $edx(tied-def 0), -8, implicit-def dead $eflags, implicit killed $rdx, implicit-def $rdx
  renamable $rdx = NEG64r killed renamable $rdx(tied-def 0), implicit-def dead $eflags
  $esi = MOV32ri 1, implicit-def $rsi
  $ecx = MOV32ri 8, implicit-def $rcx

bb.9 (%ir-block.34, align 16):
; predecessors: %bb.8, %bb.9
  successors: %bb.4(0x04000000), %bb.9(0x7c000000); %bb.4(3.12%), %bb.9(96.88%)
  liveins: $rax, $rcx, $rdx, $rsi
  renamable $rdi = LEA64r renamable $rcx, 1, $noreg, -7, $noreg
  renamable $rdi = IMUL64rr killed renamable $rdi(tied-def 0), killed renamable $rsi, implicit-def dead $eflags
  renamable $rsi = LEA64r renamable $rcx, 1, $noreg, -6, $noreg
  renamable $r8 = LEA64r renamable $rcx, 1, $noreg, -5, $noreg
  renamable $rsi = IMUL64rr killed renamable $rsi(tied-def 0), killed renamable $r8, implicit-def dead $eflags
  renamable $rsi = IMUL64rr killed renamable $rsi(tied-def 0), killed renamable $rdi, implicit-def dead $eflags
  renamable $rdi = LEA64r renamable $rcx, 1, $noreg, -4, $noreg
  renamable $r8 = LEA64r renamable $rcx, 1, $noreg, -3, $noreg
  renamable $rdi = IMUL64rr killed renamable $rdi(tied-def 0), killed renamable $r8, implicit-def dead $eflags
  renamable $r8 = LEA64r renamable $rcx, 1, $noreg, -2, $noreg
  renamable $r8 = IMUL64rr killed renamable $r8(tied-def 0), killed renamable $rdi, implicit-def dead $eflags
  renamable $r8 = IMUL64rr killed renamable $r8(tied-def 0), killed renamable $rsi, implicit-def dead $eflags
  renamable $rsi = LEA64r renamable $rcx, 1, $noreg, -1, $noreg
  renamable $rsi = IMUL64rr killed renamable $rsi(tied-def 0), renamable $rcx, implicit-def dead $eflags
  renamable $rsi = IMUL64rr killed renamable $rsi(tied-def 0), killed renamable $r8, implicit-def dead $eflags
  renamable $rdi = LEA64r renamable $rdx, 1, renamable $rcx, 0, $noreg
  $rdi = ADD64ri32 $rdi(tied-def 0), 8, implicit-def $eflags
  renamable $rcx = ADD64ri32 killed renamable $rcx(tied-def 0), 8, implicit-def dead $eflags
  CMP64ri32 killed renamable $rdi, 8, implicit-def $eflags
  JCC_1 %bb.9, 5, implicit $eflags

bb.4 (%ir-block.15):
; predecessors: %bb.9
  successors: %bb.7(0x30000000), %bb.6(0x50000000); %bb.7(37.50%), %bb.6(62.50%)
  liveins: $rax, $rcx, $rsi
  renamable $rcx = ADD64ri32 killed renamable $rcx(tied-def 0), -7, implicit-def dead $eflags
  TEST64rr renamable $rax, renamable $rax, implicit-def $eflags
  JCC_1 %bb.7, 4, implicit $eflags

bb.6 (%ir-block.23, align 16):
; predecessors: %bb.6, %bb.4, %bb.3
  successors: %bb.7(0x04000000), %bb.6(0x7c000000); %bb.7(3.12%), %bb.6(96.88%)
  liveins: $rax, $rcx, $rsi
  renamable $rsi = IMUL64rr killed renamable $rsi(tied-def 0), renamable $rcx, implicit-def dead $eflags
  renamable $rcx = nuw nsw INC64r killed renamable $rcx(tied-def 0), implicit-def dead $eflags
  renamable $rax = DEC64r killed renamable $rax(tied-def 0), implicit-def $eflags
  JCC_1 %bb.6, 5, implicit killed $eflags

bb.7 (%ir-block.31):
; predecessors: %bb.6, %bb.1, %bb.4, %bb.3
  liveins: $rsi
  renamable $rdi = LEA64r $rip, 1, $noreg, @.str.1, $noreg
  dead $eax = XOR32rr undef $eax(tied-def 0), undef $eax, implicit-def dead $eflags, implicit-def $al
  CALL64pcrel32 target-flags(x86-plt) @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
  $eax = XOR32rr undef $eax(tied-def 0), undef $eax, implicit-def dead $eflags
  $rcx = frame-destroy POP64r implicit-def $rsp, implicit $rsp
  frame-destroy CFI_INSTRUCTION def_cfa_offset 8
  RET64 $eax

# End machine code for function main.

